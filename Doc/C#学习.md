# C#运行环境

## 什么是.net(dotnet)?

全称应该为.net framework。.NET框架是一个多语言组件开发和执行环境，它提供了一个跨语言的统一编程环境。.NET框架又包括三个主要组成部分：公共语言运行库（CLR：Common Language Runtime）、[服务框架](https://baike.baidu.com/item/服务框架)（Services Framework）和上层的两类应用模板——传统的Windows应用程序模板（Win Forms）和基于ASP.NET的面向Web的网络应用程序模板（Web Forms和Web Services）。

.NET FrameWork的核心是其运行库执行环境，称为公共语言运行库(CLR，Common Language Runtime)。

.Net 编程语言的编译器会将代码编译成中间语言（Intermediate Language,IL）代码。IL代码看起来像面向对象的机器码，使用工具ildasm.exe可以打开包含.net代码的dll或exe文件来检查il代码。CLR包含了一个及时（just-in-time,jit)编译器，当程序开始运行时，jit编译器会从il代码生成本地代码。

## .net编程语言的编译过程以及CLR作用？

**在.net中，**
**(1)将源代码编译成mircrosoft中间语言（Intermediate Language,IL）代码。**
**(2)CLR把IL编译为平台专用的本地代码。**
**IL代码在.net程序集中可用。在运行时，jit编译器编译IL代码，创建特定于平台的本地代码。**

**CLR还包括一个带有类型加载器的类型系统，类型加载器负责从程序集中加载类型。CLR的另一个功能是垃圾回收器，垃圾回收器从托管堆中清除不再引用的内存。CLR还负责线程的处理。在C#中创建托管的线程不一定来自底层操作系统。线程的虚拟化和管理由CLR负责。**

# C#语言基础

# 1. 变量

变量声明

```C#
int i;
```

该语句声明int变量i。**实际上编译器不允许在表达式中使用这个变量，除非用一个值初始化了该变量。**
如果在一条语句中声明和初始化了多个变量，那么所有的变量都具有相同的数据类型： 

```C#
int x = 10, y =20; // x and y are both ints 
```

要声明不同类型的变量，需要使用单独的语句。在一条多变量的声明中，不能指定不同的数据类型：

```C#
int x = 10; bool y = true; // Creates a variable that stores true or false int x = 10, bool y = true; // This won't compile!
```

##  1.1 变量的初始化

变量的初始化是C#强调安全性的另一个例子。简单地说，C#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用该变量。**大多数现代编译器把没有初始化标记为警告**，**但C#编译器把它当成错误来看待**。这就可以防止我们无意中从其他程序遗留下来的内存中检索垃圾值。 C#有两个方法可确保变量在使用前进行了初始化：
 ● 变量是类或结构中的字段，如果没有显式初始化，则创建这些变量时，其默认值就是0（类和结构在后面讨论）。
 ● 方法的局部变量必须在代码中显式初始化，之后才能在语句中使用它们的值。此时，初始化不是在声明该变量时进行的，但编译器会通过方法检查所有可能的路径，如果检测到局部变量在初始化之前就使用了其值，就会标记为错误。

## 1.2 类型推断

**类型推断使用var关键字。声明变量的语法有些变化：使用var关键字替代实际的类型。编译器可以根据变量的初始化值“推断”变量的类型。**

 类型推断需要遵从一些规则：
● 变量必须初始化。否则，编译器就没有推断变量类型的依据。
● 初始化器不能为空。 
● 初始化器必须放在表达式中。 
● 不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象。

## 1.3 变量的作用域

变量的作用域是可以访问该变量的代码区域。一般情况下，确定作用域遵循以下规则： 
● 只要类在某个作用域内，其字段（也称为成员变量）也在该作用域内。 
● 局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内。 
● 在for、while或类似语句中声明的局部变量存在于该循环体内。

有两种冲突情况

1.局部作用域内的冲突
大型程序在不同部分为不同的变量使用相同的变量名很常见。只要变量的作用域是程序的不同部分，就不会有问题，也不会产生多义性。但要注意，同名的局部变量不能在同一作用域内声明两次。声明两次会无法通过编译。
2.局部变量与类字段的冲突
某些情况下，可以区分名称相同（尽管其完全限定名不同）、作用域相同的两个标识符。此时编译器允许声明第二个变量。原因是C#在变量之间有一个基本的区分，它把在类型级别声明的变量看成字段，而把在方法中声明的变量看成局部变量。
**<u>但是，如果要引用类级别变量，该怎么办？可以使用语法object.fieldname，在对象的外部引用类或结构的字段。</u>**

## 1.4 常量

顾名思义，常量是其值在使用过程（生命周期）中不会发生变化的变量。在声明和初始化变量时，在变量的前面加上关键字const，就可以把该变量指定为一个常量。
常量具有如下特点：
● 常量必须在声明时初始化。指定了其值后，就不能再改写了。 
● 常量的值必须能在编译时用于计算。因此，不能用从变量中提取的值来初始化常量。如果需要这么做，应使用只读字段（详见第3章）。 
● **常量总是隐式静态的。但注意，不必（实际上，是不允许）在常量声明中包含修饰符static。** 

在程序中使用常量至少有3个好处： 
● 由于使用易于读取的名称（名称的值易于理解）替代了较难读取的数字和字符串，常量使程序变得更易于阅读。 
● 常量使程序更易于修改。例如，在C#程序中有一个SalesTax常量，该常量的值为6%。如果以后销售税率发生变化，把新值赋给这个常量，就可以修改所有的税款计算结果，而不必查找整个程序去修改税率为0.06的每个项。
● 常量更容易避免程序出现错误。如果在声明常量的位置以外的某个地方将另一个值赋给常量，编译器就会标记错误。

## 1.5 预定义数据类型(变量的类型)

两中大的分类：

1.值类型
2.引用类型

从概念上看，其区别是值类型直接存储其值，而引用类型存储对值的引用。
这两种类型存储在内存的不同地方：值类型存储在堆栈（stack）中，而引用类型存储在托管堆（managed heap）上。注意区分某个类型是值类型还是引用类型，因为这会有不同的影响。例如，int是值类型，这表示下面的语句会在内存的两个地方存储值20：

C#把基本类型（如int和bool）规定为值类型，而把包含许多字段的较大类型（通常在有类的情况下）规定为引用类型，C#设计这种方式是为了得到最佳性能。如果要把自己的类型定义为值类型，**就应把它声明为一个结构。**

**大多数更复杂的C#数据类型，包括我们自己声明的类，都是引用类型。它们分配在堆中，其生存期可以跨多个函数调用，可以通过一个或几个别名来访问。CLR实现一种精细的算法，来跟踪哪些引用变量仍是可以访问的，哪些引用变量已经不能访问了。CLR会定期删除不能访问的对象，把它们占用的内存返回给操作系统。这是通过垃圾回收器实现的。**

### 1.5.1 .net类型

数据类型的C#关键字（如int、short和string）从编译器映射到.NET数据类型。例如，在C#中声明一个int类型的数据时，声明的实际上是.NET结构System.Int32的一个实例。这听起来似乎很深奥，但其意义深远：这表示在语法上，可以把所有的基本数据类型看成支持某些方法的类。例如，要把int i转换为string类型，可以编写下面的代码： string s = i.ToString(); **<u>应强调的是，在这种便利语法的背后，类型实际上仍存储为基本类型。</u>**基本类型在概念上用.NET结构表示，所以肯定没有性能损失。 

下面看看C#中定义的内置类型。我们将列出每个类型，以及它们的定义和对应.NET类型的名称。C#有15个预定义类型，其中13个是值类型，两个是引用类型（string和object）。

### 1.5.2 C#类型

具体的定义略，可以参考，**[美] Christian Nagel. C#高级编程(第10版) C# 6 & .NET Core 1.0 (2.4.3). 清华大学出版社.**

**有些C#类型的名称与C++和Java类型一致，但定义不同。例如，在C#中，int总是32位有符号的整数。而在C++中，int是有符号的整数，但其位数取决于平台（在Windows上是32位）。在C#中，所有的数据类型都以与平台无关的方式定义，以备将来从C#和.NET迁移到其他平台上。**

**如果对一个int、uint、long还是ulong类型的整数没有任何显式的声明，则该变量默认为int类型。为了把输入的值指定为其他整数类型，可以在数字后面加上如下字符：**

```C#
uint ui = 1234U; long l = 1234L; ulong ul = 1234UL;
```

**bool值和整数值不能相互隐式转换。如果变量（或函数的返回类型）声明为bool类型，就只能使用值true或false。如果试图使用0表示false，非0值表示true，就会出错。**

**char类型的字面量是用单引号括起来的，如’A'。如果把字符放在双引号中，编译器会把它看成字符串，从而产生错误。**

**<u>*C#有string关键字，转换为.NET类System.String。有了它，像字符串连接和字符串复制这样的操作就很简单了。尽管它为引用类型，string类已实现，其语义遵循一般的、直观的字符串规则。*</u>**

**名称空间的别名**,如下

```C#
using alias = NamespaceName;
```



## 1.6  XML文档

如前所述，除了C风格的注释外，C#还有一个非常出色的功能（本章将讨论这一功能）：根据特定的注释自动创建XML格式的文档说明。这些注释都是单行注释，但都以3条斜杠（///）开头，而不是通常的两条斜杠。在这些注释中，可以把包含类型和类型成员的文档说明的XML标记放在代码中。

编译器可以识别一些格式的注释文档。

## 1.7  C#预处理器指令

**注意： C++开发人员应该知道，在C和C++中预处理器指令非常重要。但是，在C#中，并没有那么多的预处理器指令，它们的使用也不太频繁。C#提供了其他机制来实现许多C++指令的功能，如定制特性。还要注意，C#并没有一个像C++那样的独立预处理器，所谓的预处理器指令实际上是由编译器处理的。尽管如此，C#仍保留了一些预处理器指令名称，因为这些命令会让人觉得就是预处理器。**

# 2. 对象与类型

结构不同于类，因为它们不需要在堆上分配空间（类是引用类型，总是存储在堆（heap）上），而结构是值类型，通常存储在栈（stack）上，另外，结构不支持继承。对于类和结构，都使用关键字new来声明实例：这个关键字创建对象并对其进行初始化。

**类和结构的一个重要区别是，类类型的对象通过引用传递，结构类型的对象按值传递。**

类中的成员说明：

| 成员     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 字段     | 字段是类的数据成员，它是类型的一个变量，该类型是类的一个成员 |
| 方法     | 方法是与特定类相关联的函数                                   |
| 常量     | 常量与类相关（尽管它们没有static修饰符）。编译器使用真实值代替常量 |
| 属性     | 属性是可以从客户端访问的函数组，其访问方式与访问类的公共字段类似。C#为读写类中的属性提供了专用语法，所以不必使用那些名称中嵌有Get或Set的方法。因为属性的这种语法不同于一般函数的语法，所有在客户端代码中，虚拟的对象被当作实际的东西 |
| 构造函数 | 构造函数是在实例化对象时自动调用的特殊函数。它们必须与所属的类同名，且不能有返回类型。构造函数用于初始化字段的值 |
| 索引器   | 索引器允许对象用访问数组的方式访问。索引器参见第8章          |
| 运算符   | 运算符执行的最简单的操作就是加法和减法。在两个整数相加时，严格地说，就是对整数使用“+”运算符。C#还允许指定把已有的运算符应用于自己的类（运算符重载）。第8章将详细论述运算符 |
| 事件     | 事件是类的成员，在发生某些行为（如修改类的字段或属性，或者进行了某种形式的用户交互操作）时，它可以让对象通知调用方。客户可以包含所谓“事件处理程序”的代码来响应该事件。第9章将详细介绍事件 |
| 析构函数 | 析构函数或终结器的语法类似于构造函数的语法，但是在CLR检测到不再需要某个对象时调用它。它们的名称与类相同，但前面有一个“～”符号。不可能预测什么时候调用终结器。终结器详见第5章 |
| 类型     | 类可以包含内部类。如果内部类型只和外部类型结合使用，就很有趣 |

## 2.1 属性

属性（property）的概念是：它是一个方法或一对方法，在客户端代码看来，它（们）是一个字段。

1．自动实现的属性 如果属性的set和get访问器中没有任何逻辑，就可以使用自动实现的属性。这种属性会自动实现后备成员变量。

示例的代码如下： 

```C#
public int Age { get; set; }
```

这种方法后备成员变量就不知道是啥名。

自动实现的属性可以使用属性初始化器来初始化：示例代码如下：

```C#
public int Age { get; set; } = 42;
```

2．属性的访问修饰符 C#允许给属性的get和set访问器设置不同的访问修饰符，所以属性可以有公有的get访问器和私有或受保护的set访问器。

```C#
public string Name { get { return _name; } private set { _name = value; } } 
```

通过自动实现的属性，也可以设置不同的访问级别： 

```C#
public int Age { get; private set; }
```

**Note:属性默认的访问属性就是public，因此不能用public修饰，并且两个不能同时不为public访问属性，否则会编译报错**

## 2.2 方法

注意，正式的C#术语区分函数和方法。在C#术语中，“函数成员”不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数和析构函数等，甚至还有属性。这些都不是数据成员，字段、常量和事件才是数据成员。
2．表达式体方法

方法声明：

```C#
[modifiers] return_type MethodName([parameters]) { // Method body }
```

2．表达式体方法

如果方法的实现只有一个语句，C# 6为方法定义提供了一个简化的语法：表达式体方法。使用新的语法，不需要编写花括号和return关键字，而使用运算符= >（lambda操作符）区分操作符左边的声明和操作符右边的实现代码。

```C#
public bool IsSquare(Rectangle rect) => rect.Height == rect.Width;
```

4．方法的重载 C#支持方法的重载——方法的几个版本有不同的签名（即，方法名相同，但参数的个数和/或数据类型不同）。为了重载方法，只需要声明同名但参数个数或类型不同的方法即可。

6．可选参数，参数也可以是可选的。必须为可选参数提供默认值。可选参数还必须是方法定义的最后的参数。

```C#
public void TestMethod(int notOptionalNumber, int optionalNumber = 42) { WriteLine(optionalNumber + notOptionalNumber); }
```

通过多个可选参数，命名参数的特性就会发挥作用。使用命名参数，可以传递任何可选参数，例如，下面的例子仅传递最后一个参数： 

```C#
public void TestMethod(int n, int opt1 = 11 , int opt2 = 22 , int opt3 = 33 ) { WriteLine(n + opt1 + opt2 + opt3); }
TestMethod(1, opt3: 4);
```

7．个数可变的参数 使用可选参数，可以定义数量可变的参数。然而，还有另一种语法允许传递数量可变的参数——这个语法没有版本控制问题。 声明数组类型的参数（示例代码使用一个int数组），添加params关键字，就可以使用任意数量的int参数调用该方法。 

```C#
public void AnyNumberOfArguments(params int[] data) { foreach (var x in data) { WriteLine(x); } }
```

**如果params关键字与方法签名定义的多个参数一起使用，则params只能使用一次，而且它必须是最后一个参数**



## 2.3 构造函数

没有必要给类提供构造函数，到目前为止本书的例子中没有提供这样的构造函数。一般情况下，如果没有提供任何构造函数，编译器会在后台生成一个默认的构造函数。**<u>*这是一个非常基本的构造函数，它只能把所有的成员字段初始化为标准的默认值（例如，引用类型为空引用，数值数据类型为0, bool为false）。这通常就足够了，否则就需要编写自己的构造函数。*</u>** 

**<u>*但是，如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数。只有在没有定义任何构造函数时，编译器才会自动提供默认的构造函数。*</u>**

构造函数的重载遵循与其他方法相同的规则。换言之，可以为构造函数提供任意多的重载，只要它们的签名有明显的区别即可。

● 类仅用作某些静态成员或属性的容器，因此永远不会实例化它。在这种情况下，可以用static修饰符声明类。使用这个修饰符，类只能包含静态成员，不能实例化。 
● 希望类仅通过调用某个静态成员函数来实例化（这就是所谓对象实例化的类工厂方法）。单例模式的实现如下面的代码片段所示：

```C#
public class Singleton { 
    private static Singleton s_instance; 
    private int _state; private Singleton(int state) { _state = state; } 
    public static Singleton Instance { get { return s_instance ? ? (s_instance = new MySingleton(42); } } 
}
```

**<u>*类中的数据成员即便不在定义的构造函数里初始化，也会变初始化标准的默认值（例如，引用类型为空引用，数值数据类型为0, bool为false）*</u>**

### 2.3.1 从构造函数中调用其他构造函数

省事

```C#
class Car { 
    private string _description; 
    private uint _nWheels; 
    public Car(string description, uint nWheels) { 
        _description = description;
        _nWheels = nWheels; 
    } 
    public Car(string description) { 
        _description = description; 
        _nWheels = 4; 
    } // etc.
}
//优化如下
class Car { 
    private string _description; 
    private uint _nWheels; 
    public Car(string description, uint nWheels) { 
        _description = description; 
        _nWheels = nWheels; 
    } 
    public Car(string description): this (description, 4) { } // etc
}
```

### 2.3.2 静态构造函数

**<u>*C#的一个新特征是也可以给类编写无参数的静态构造函数。这种构造函数只执行一次，而前面的构造函数是实例构造函数，只要创建类的对象，就会执行它。*</u>**

编写静态构造函数的一个原因是，类有一些静态字段或属性，需要在第一次使用类之前，从外部源中初始化这些静态字段和属性。

<u>*.NET运行库没有确保什么时候执行静态构造函数，所以不应把要求在某个特定时刻（例如，加载程序集时）执行的代码放在静态构造函数中。也不能预计不同类的静态构造函数按照什么顺序执行。但是，可以确保静态构造函数至多运行一次，即在代码引用类之前调用它。**在C#中，通常在第一次调用类的任何成员之前执行静态构造函数**。*</u>



<u>***注意，静态构造函数没有访问修饰符，其他C#代码从来不显式调用它，但在加载类时，总是由.NET运行库调用它，所以像public或private这样的访问修饰符就没有任何意义。出于同样原因，静态构造函数不能带任何参数，一个类也只能有一个静态构造函数。很显然，静态构造函数只能访问类的静态成员，不能访问类的实例成员。***</u>

### 2.3.3 只读成员

如果不希望在初始化后修改数据成员，就可以使用readonly关键字。下面详细描述只读字段和只读属性。

#### 只读字段

为了保证对象的字段不能改变，字段可以用readonly修饰符声明。**<u>*带有readonly修饰符的字段只能在构造函数中分配值。*</u>**
**<u>*它与const修饰符不同。编译器通过const修饰符，用其值取代了使用它的变量。编译器知道常量的值。只读字段在运行期间通过构造函数指定。*</u>*****<u>与常量字段相反，只读字段可以是实例成员。使用只读字段作为类成员时，需要把static修饰符分配给该字段。</u>***

NOTE:还要注意，在构造函数中不必给只读字段赋值。如果没有赋值，它的值就是其特定数据类型的默认值，或者在声明时给它初始化的值。这适用于只读的静态字段和实例字段。即便是正常的字段，在.net 6.0的环境下也会被初始化（没有在构造函数中进行初始化）。

#### 只读属性

只读属性:在属性定义中省略set访问器，就可以创建只读属性。因此，如下代码把Name变成只读属性：

```C#
private readonly string _name; public string Name { get { return _name; } } 
```

 用readonly修饰符声明字段，只允许在构造函数中初始化属性的值。 同样，在属性定义中省略get访问器，就可以创建只写属性。**<u>*但是，这是不好的编程方式，因为这可能会使客户端代码的作者感到迷惑。一般情况下，如果要这么做，最好使用一个方法替代。*</u>**

C# 6提供了一个简单的语法，使用自动实现的属性创建只读属性，访问只读字段。这些属性可以使用属性初始化器来初始化。 当然，只读属性也可以在构造函数中初始化。

```C#
public string Id { get; } = Guid.NewGuid().ToString();
```

#### 表达式属性

C# 6中与属性相关的另一个扩展是表达式体属性。类似于表达式体方法，表达式体属性不需要花括号和返回语句。表达式体属性是带有get访问器的属性，但不需要编写get关键字。只是get访问器的实现后跟lambda操作符。对于Person类，FullName属性使用表达式体属性实现，通过该属性返回FirstName和LastName属性值的组合：

```C#
public class Person { 
    public Person(string firstName, string lastName) { 
        FirstName = firstName; 
        LastName = lastName; 
    } 
    public string FirstName { get; } 
    public string LastName { get; } 
    public string FullName => $"{FirstName} {LastName}"; 
}
```

#### 不可变的类型

**<u>*如果类型包含可以改变的成员，它就是一个可变的类型。使用readonly修饰符，编译器会在状态改变时报错。状态只能在构造函数中初始化。如果对象没有任何可以改变的成员，只有只读成员，它就是一个不可变类型。其内容只能在初始化时设置。这对于多线程是非常有用的，因为多个线程可以访问信息永远不会改变的同一个对象。因为内容不能改变，所以不需要同步。*</u>**



## 2.4 匿名类型

var关键字，它用于表示隐式类型化的变量。var与new关键字一起使用时，可以创建匿名类型。匿名类型只是一个继承自Object且没有名称的类。**<u>该类的定义从初始化器中推断，类似于隐式类型化的变量。</u>**

如果所设置的值来自于另一个对象，就可以简化初始化器。如果已经有一个包含FirstName、MiddleName和LastName属性的类，且有该类的一个实例（person）, captain对象就可以初始化为： 

```C#
var captain = new { person.FirstName, person.MiddleName, person.LastName }; 
```

person对象的属性名应投射到新对象名captain，所以captain对象应有FirstName、MiddleName和LastName属性。

**<u>*这些新对象的类型名未知。编译器为类型“伪造”了一个名称，但只有编译器才能使用它。我们不能也不应使用新对象上的任何类型反射，因为这不会得到一致的结果。*</u>**

## 2.5 结构



结构是值类型，不是引用类型。**<u>*它们存储在栈中或存储为内联（如果它们是存储在堆中的另一个对象的一部分）*</u>**，其生存期的限制与简单的数据类型一样。 

● 结构不支持继承。 
● 对于结构，构造函数的工作方式有一些区别。如果没有提供默认的构造函数，编译器会自动提供一个，把成员初始化为其默认值。 
● 使用结构，可以指定字段如何在内存中布局



因为结构实际上是把数据项组合在一起，所以有时大多数或者全部字段都声明为public。**<u>*严格来说，这与编写.NET代码的规则相反——根据Microsoft，字段（除了const字段之外）应总是私有的，并由公有属性封装。*</u>**但是，对于简单的结构，许多开发人员都认为公有字段是可接受的编程方式。


### 2.5.1 结构是值类型

注意，因为结构是值类型，所以new运算符与类和其他引用类型的工作方式不同。**<u>*new运算符并不分配堆中的内存，而是只调用相应的构造函数，根据传送给它的参数，初始化所有的字段*</u>**。对于结构，可以编写下述完全合法的代码：

```C#
Dimensions point; 
point.Length = 3; 
point.Width = 6; 
```

**<u>*结构遵循其他数据类型都遵循的规则：在使用前所有的元素都必须进行初始化。*</u>**在结构上调用new运算符，或者给所有的字段分别赋值，结构就完全初始化了。当然，如果结构定义为类的成员字段，在初始化包含的对象时，该结构会自动初始化为0。

<u>***NOTE:在net6.0环境下，这种代码无法通过编译，最好还是先初始化对象再进行使用。***</u>

结构不是为继承设计的。这意味着：**<u>*它不能从一个结构中继承。唯一的例外是对应的结构（和C#中的其他类型一样）最终派生于类System.Object。因此，结构也可以访问System.Object的方法。在结构中，甚至可以重写System.Object中的方法——如重写ToString（）方法。结构的继承链是：每个结构派生自System.ValueType类，System.ValueType类又派生自System.Object。ValueType并没有给Object添加任何新成员，但提供了一些更适合结构的实现方式。注意，不能为结构提供其他基类：每个结构都派生自ValueType。*</u>** 

为结构定义构造函数的方式与为类定义构造函数的方式相同。 前面说过，默认构造函数把数值字段都初始化为0，且总是隐式地给出，即使提供了其他带参数的构造函数，也是如此。

## 2.6 按值和引用传递参数

结构按值传递，通过按值传递。类按引用传递。

```C#
public struct Dimensions { 
    public double Length { get; set; }
    public double Width { get; set; } 
    public Dimensions(double length, double width) { Length = length; Width = width; } 
    //表达式属性,返回了Math.Sqrt(Length * Length + Width * Width)
    public double Diagonal => Math.Sqrt(Length * Length + Width * Width); 
}
public class Dimensions1 { 
    public double Length { get; set; }
    public double Width { get; set; } 
    public Dimensions1(double length, double width) { Length = length; Width = width; } 
    //表达式属性,返回了Math.Sqrt(Length * Length + Width * Width)
    public double Diagonal => Math.Sqrt(Length * Length + Width * Width); 
}
public static void ChangeValue(Dimensions a){
    a.Length = 100;
}
public static void ChangeValue(Dimensions1 a){
    a.Length = 100;
}
Dimensions d1 = new Dimensions(10,10);
Dimensions1 d2 = new Dimensions1(0,0);
//d1为结构体，d2为类，d1为值传递，d2为引用传递
ChangeValue(d1);
ChangeValue(d2);
Console.WriteLine($"d1.Length:{d1.Length}");
Console.WriteLine($"d2.Length:{d2.Length}");
//输出
//d1.Length:10
//d2.Length:100
```

### 2.6.1 ref参数

也可以通过引用传递结构。如果A是结构类型，就添加ref修饰符，方法的声明，通过引用传递变量。在调用方法时需要添加它。

对于引用类型，如果要在函数中创建新对象并更改原先的引用，需要添加ref修饰符。

```C#
 public static void ChangeValue(Dimensions1 a){
     a.Length = 100;
     a = new Dimensions1(1001,1001);
 }
public static void ChangeValue(ref Dimensions1 a){
    a.Length = 1000;
    a = new Dimensions1(10000,10000);
}
```

### 2.6.2　out参数

如果方法返回一个值，该方法通常声明返回类型，并返回结果。<u>如果方法返回多个值，可能类型还不同，该怎么办？</u>这有不同的选项。**<u>*一个选项是声明类和结构，把应该返回的所有信息都定义为该类型的成员。另一个选项是使用元组类型。第三个选项是使用out关键字。*</u>**

使用out参数，变量不需要预先初始化，变量在方法中初始化。类似于ref关键字，out关键字也需要在调用方法时提供，而不仅仅在声明方法时提供。

使用示例：

```C#
string input2 = Console.ReadLine(); 
int result; 
if (int.TryParse(input2, out result) ) 
{ 
    Console.WriteLine($"n: {result}"); 
} 
else 
{ 
    Console.WriteLine("not a number"); 
}
```

## 2.7 可空类型

可空类型是可以为空的值类型。可空类型只需要在类型的后面添加“？”（它必须是结构）。与基本结构相比，值类型唯一的开销是一个可以确定它是否为空的布尔成员。（勘误，应该是可空类型的唯一开销）。

**对于可空类型，可以使用能用于基本类型的所有可用操作符，例如，可用于int？的+、-、*、/等。每个结构类型都可以使用可空类型，而不仅是预定义的C#类型。**

## 2.8 枚举类型

枚举是一个值类型，包含一组命名的常量，如这里的Color类型。枚举类型用enum关键字定义

```C#
 public enum Color { Red, Green, Blue }
```

默认情况下，enum的类型是int。这个基本类型可以改为其他整数类型（byte、short、int、带符号的long和无符号变量）。命名常量的值从0开始递增，但它们可以改为其他值：

```C#
public enum Color : short { Red = 1, Green = 2, Blue = 3 }
```

使用强制类型转换可以把数字改为枚举值，把枚举值改为数字。(不使用强制类型转换可以转换嘛？无法隐式转换，必须强制类型转换)



**<u>*还可以使用enum类型把多个选项分配给一个变量，而不仅仅是一个枚举常量。为此，分配给常量的值必须是不同的位，Flags属性需要用枚举设置。*</u>**

```C#
[Flags] public enum DaysOfWeek { 
    Monday = 0x1, Tuesday = 0x2, Wednesday = 0x4, Thursday = 0x8, Friday = 0x10, Saturday = 0x20, Sunday = 0x40 
}
```



设置不同的位，也可以结合单个位来包括多个值，如Weekend的值0x60是用逻辑或运算符结合了Saturday和Sunday。Workday则结合了从Monday到Friday的所有日子，AllWeek用逻辑或运算符结合了Workday和Weekend 

Enum.GetNames方法返回一个包含所有枚举名的字符串数组。

为了获得枚举的所有值，可以使用方法Enum.GetValues。Enum.GetValues返回枚举值的一个数组。为了获得整数值，需要把它转换为枚举的底层类型。

## 2.9 部分类

partial关键字允许把类、结构、方法或接口放在多个文件中。一般情况下，某种类型的代码生成器生成了一个类的某部分，所以把类放在多个文件中是有益的。假定要给类添加一些从工具中自动生成的内容。如果重新运行该工具，前面所做的修改就会丢失。partial关键字有助于把类分开放在两个文件中，而对不由代码生成器定义的文件进行修改。

## 2.10 扩展方法

有许多扩展类的方式。继承就是给对象添加功能的好方法。扩展方法是给对象添加功能的另一个选项，在不能使用继承时，也可以使用这个选项（例如类是密封的）。扩展方法是静态方法，它是类的一部分，但实际上没有放在类的源代码中。

示例：

```C#
public static class StringExtension { 
    public static int GetWordCount(this string s) => s.Split().Length; 
}
```

**<u>*使用this关键字和第一个参数来扩展字符串。这个关键字定义了要扩展的类型。*</u>**

使用：

```C#
string fox = "the quick brown fox jumped over the lazy dogs down " + "9876543210 times"; 
int wordCount = fox.GetWordCount(); 
WriteLine($"{wordCount} words");
```

**<u>*编译器如何找到某个类型的扩展方法？this关键字必须匹配类型的扩展方法，而且需要打开定义扩展方法的静态类所在的名称空间。如果把StringExtensions类放在名称空间Wrox. Extensions中，则只有用using指令打开Wrox.Extensions，编译器才能找到GetWordCount方法。如果类型还定义了同名的实例方法，扩展方法就永远不会使用。类中已有的任何实例方法都优先。当多个同名的扩展方法扩展相同的类型，打开所有这些类型的名称空间时，编译器会产生一个错误，指出调用是模棱两可的，它不能决定在多个实现代码中选择哪个。然而，如果调用代码在一个名称空间中，这个名称空间就优先。*</u>**

## 2.11 Object类

**<u>*前面提到，所有的.NET类最终都派生自System.Object。实际上，如果在定义类时没有指定基类，编译器就会自动假定这个类派生自Object。本章没有使用继承，所以前面介绍的每个类都派生自System.Object（如前所述，对于结构，这个派生是间接的：结构总是派生自System.ValueType, System.ValueType又派生自System.Object）。*</u>**

其实际意义在于，除了自己定义的方法和属性等外，还可以访问为Object类定义的许多公有的和受保护的成员方法。这些方法可用于自己定义的所有其他类中。 下面将简要总结每个方法的作用：

● ToString（）方法： 是获取对象的字符串表示的一种便捷方式。当只需要快速获取对象的内容，以进行调试时，就可以使用这个方法。在数据的格式化方面，它几乎没有提供选择：例如，在原则上日期可以表示为许多不同的格式，但DateTime.ToString（）没有在这方面提供任何选择。如果需要更复杂的字符串表示，例如，考虑用户的格式化首选项或区域性，就应实现IFormattable接口。

 ● GetHashCode（）方法： 如果对象放在名为映射（也称为散列表或字典）的数据结构中，就可以使用这个方法。处理这些结构的类使用该方法确定把对象放在结构的什么地方。如果希望把类用作字典的一个键，就需要重写GetHashCode（）方法。实现该方法重载的方式有一些相当严格的限制，这些将在第11章介绍字典时讨论。 

● Equals（）（两个版本）和ReferenceEquals（）方法： 注意有3个用于比较对象相等性的不同方法，这说明.NET Framework在比较相等性方面有相当复杂的模式。这3个方法和比较运算符“==”在使用方式上有微妙的区别。而且，在重写带一个参数的虚Equals（）方法时也有一些限制，因为System.Collections名称空间中的一些基类要调用该方法，并希望它以特定的方式执行。第8章在介绍运算符时将探讨这些方法的使用。 

● Finalize（）方法： 第5章将介绍这个方法，**<u>*它最接近C++风格的析构函数*</u>**，在引用对象作为垃圾被回收以清理资源时调用它。Object中实现的Finalize（）方法实际上什么也没有做，因而被垃圾回收器忽略。如果对象拥有对未托管资源的引用，则在该对象被删除时，就需要删除这些引用，此时一般要重写Finalize（）。垃圾收集器不能直接删除这些对未托管资源的引用，因为它只负责托管的资源，于是它只能依赖用户提供的Finalize（）。 

● GetType（）方法： 这个方法返回从System.Type派生的类的一个实例，因此可以提供对象成员所属类的更多信息，包括基本类型、方法、属性等。System.Type还提供了.NET的反射技术的入口点。这个主题详见第16章。

● MemberwiseClone（）方法： 这是System.Object中唯一没有在本书的其他地方详细论述的方法。不需要讨论这个方法，因为它在概念上相当简单，它只复制对象，并返回对副本的一个引用（对于值类型，就是一个装箱的引用）。**<u>*注意，得到的副本是一个浅表复制，即它复制了类中的所有值类型。如果类包含内嵌的引用，就只复制引用，而不复制引用的对象。这个方法是受保护的，所以不能用于复制外部的对象。该方法不是虚方法，所以不能重写它的实现代码。*</u>**
注：在调用类的静态成员时，便会先调用类的静态构造函数

# 3. 继承

## 3.1 C#支持的面向对象特性

● 单重继承： 表示一个类可以派生自一个基类。C#就采用这种继承。 
● 多重继承： 多重继承允许一个类派生自多个类。**<u>*C#不支持类的多重继承，但允许接口的多重继承。*</u>** 
● 多层继承： **<u>*多层继承允许继承有更大的层次结构*</u>**。类B派生自类A，类C又派生自类B。 其中，类B也称为中间基类，C#支持它，也很常用。 
● 接口继承： 定义了接口的继承。这里允许多重继承。接口和接口继承参见本章后面的“接口”一节。

**<u>*对于实现继承，多重继承会给生成的代码增加复杂性，还会带来一些开销。因此，C#的设计人员决定不支持类的多重继承。*</u>**

使用结构的一个限制是结构不支持继承，但每个结构都自动派生自System.ValueType。不能编码实现结构的类型层次，但结构可以实现接口。换言之，结构并不支持实现继承，但支持接口继承。定义的结构和类可以总结为： 
● 结构总是派生自System.ValueType，它们还可以派生自任意多个接口。 
● 类总是派生自System.Object或用户选择的另一个类，它们还可以派生自任意多个接口。

## 3.2 继承实现

如果要声明派生自另一个类的一个类，就可以使用下面的语法：

```C#
class MyDerivedClass: MyBaseClass { // members }
```

  如果类（或结构）也派生自接口，则用逗号分隔列表中的基类和接口： 

```C#
public class MyDerivedClass: MyBaseClass, IInterface1, IInterface2 { // members }
```

　**<u>*如果类和接口都用于派生，则类总是必须放在接口的前面。*</u>**

### 3.2.1 虚函数



把一个基类方法声明为virtual，就可以在任何派生类中重写该方法：

重写基类的方法时，签名（所有参数类型和方法名）和返回类型必须完全匹配。否则，以后创建的新成员就不覆盖基类成员。

**<u>*C#中虚函数的概念与标准OOP的概念相同：可以在派生类中重写虚函数。在调用方法时，会调用该类对象的合适方法。在C#中，函数在默认情况下不是虚拟的，但（除了构造函数以外）可以显式地声明为virtual。这遵循C++的方式，即从性能的角度来看，除非显式指定，否则函数就不是虚拟的。而在Java中，所有的函数都是虚拟的。但C#的语法与C++的语法不同，因为C#要求在派生类的函数重写另一个函数时，要使用override关键字显式声明。*</u>**

重写方法的语法避免了C++中很容易发生的潜在运行错误：当派生类的方法签名无意中与基类版本略有差别时，该方法就不能重写基类的方法。在C#中，这会出现一个编译错误，因为编译器会认为函数已标记为override，但没有重写其基类的方法。

### 3.2.2 多态性

使用多态性，可以动态地定义调用的方法，而不是在编译期间定义。编译器创建一个虚拟方法表（vtable），其中列出了可以在运行期间调用的方法，它根据运行期间的类型调用方法。(动态绑定)

### 3.2.3 隐藏方法

如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有分别声明为virtual和override，派生类方法就会隐藏基类方法。在**<u>*大多数情况下，是要重写方法，而不是隐藏方法，因为隐藏方法会造成对于给定类的实例调用错误方法的危险。*</u>**但是，如下面的例子所示，C#语法可以确保开发人员在编译时收到这个潜在错误的警告，从而使隐藏方法（如果这确实是用户的本意）更加安全。这也是类库开发人员得到的版本方面的好处。

*<u>**注意： new方法修饰符不应该故意用于隐藏基类的成员。这个修饰符的主要目的是处理版本冲突，在修改派生类后，响应基类的变化。**</u>*

### 3.2.4 访问方法的基类版本

C#有一种特殊的语法用于从派生类中调用方法的基类版本：

```C#
base.<MethodName>()
```

*<u>**注意： 使用base关键字，可以调用基类的任何方法——而不仅仅是已重写的方法。**</u>*

### 3.2.5 抽象类与抽象方法

**<u>*C#允许把类和方法声明为abstract。抽象类不能实例化，而抽象方法不能直接实现，必须在非抽象的派生类中重写。显然，抽象方法本身也是虚拟的（尽管也不需要提供virtual关键字，实际上，如果提供了该关键字，就会产生一个语法错误）。如果类包含抽象方法，则该类也是抽象的，也必须声明为抽象的*</u>**。

**<u>*从抽象基类中派生类型时，需要实现所有抽象成员。否则，编译器会报错*</u>**

抽象类不能实例化，但是其派生类可以实例化赋值给抽象类变量。

### 3.2.6 密封类与密封方法

如果不应创建派生自某个自定义类的类，该自定义类就应密封。给类添加sealed修饰符，就不允许创建该类的子类。密封一个方法，表示不能重写该方法。



**<u>*要在方法或属性上使用sealed关键字，必须先从基类上把它声明为要重写的方法或属性。如果基类上不希望有重写的方法或属性，就不要把它声明为virtual。*</u>**

### 3.2.7 派生类的构造函数

**<u>*构造函数总是按照层次结构的顺序调用：先调用System.Object类的构造函数，再按照层次结构由上向下进行，直到到达编译器要实例化的类为止。为了实例化Ellipse类型，先调用Object构造函数，再调用Shape构造函数，最后调用Ellipse构造函数。这些构造函数都处理它自己类中字段的初始化。*</u>**

**<u>*当删除默认构造函数，重新编译程序时，不能编译Ellipse和Rectangle类，因为编译器不知道应该把什么值传递给基类唯一的非默认值构造函数。这里需要在派生类中创建一个构造函数，用构造函数初始化器初始化基类构造函数。*</u>**

编译给的不够看，写不正确会报错。注意保证每个层都初始化到就行。

## 3.3 修饰符

| 修饰符            |   应用于   |   说明    |
| ---------------------------- | ---- | ---- |
| public | 所有类型或成员 | 任何代码均可以访问该项 |
| protected | 类型和内嵌类型的所有成员 | 只有派生的类型能访问该项 |
| internal | 所有类型或成员 | 只能在包含它的程序集中访问该项 |
| private | 类型和内嵌类型的所有成员 | 只能在它所属的类型中访问该项 |
| protected internal | 类型和内嵌类型的所有成员 | 只能在包含它的程序集和派生类型的任何代码中访问该项 |
|                              |      |      |

<u>***注意： public、protected和private是逻辑访问修饰符。internal是一个物理访问修饰符，其边界是一个程序集。***</u>

不能把类型定义为protected、private或protected internal，因为这些修饰符对于包含在名称空间中的类型没有意义。因此这些修饰符只能应用于成员。但是，可以用这些修饰符定义嵌套的类型（即，包含在其他类型中的类型），因为在这种情况下，类型也具有成员的状态。于是，下面的代码是合法的：

```C#
public class OuterClass { 
    protected class InnerClass { 
        // etc. 
    } 
    // etc. 
}
```

3.3.1 其他修饰符


| 修饰符            |   应用于   |   说明    |
| ---------------------------- | ---- | ---- |
| new  | 函数成员 | 成员用相同的签名隐藏继承的成员 |
| static | 所有成员 | 成员不作用于类的具体实例，也称为类成员，而不是实例成员 |
| virtual | 仅函数成员 | 成员可以由派生类重写 |
| abstract | 仅函数成员 | 成员重写了继承的虚拟或抽象成员 |
| override | 仅函数成员 | 成员重写了继承的虚拟或抽象成员 |
| sealed | 类、方法和属性 |   对于类，不能继承自密封类。对于属性和方法，成员重写已继承的虚拟成员，但任何派生类中的任何成员都不能重写该成员。该修饰符必须与override一起使用   |
| extern |    仅静态[DllImport]方法    |   成员在外部用另一种语言实现。这个关键字的用法参见第5章   |

## 3.4 接口

**<u>*声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的实现方式。一般情况下，接口只能包含方法、属性、索引器和事件的声明。*</u>**

**<u>*类似于抽象类，永远不能实例化接口，它只能包含其成员的签名。此外，可以声明接口类型的变量。*</u>**

**<u>*在接口定义中还不允许声明成员的修饰符。接口成员总是隐式为public，不能声明为virtual。如果需要，就应由实现的类来声明，因此最好实现类来声明访问修饰符。*</u>**

### 3.4.1 定义与实现接口，继承

示例：

```C#
public interface IBankAccount { 
    void PayIn(decimal amount); 
    bool Withdraw(decimal amount); 
    decimal Balance { get; } 
}
```

接口可以彼此继承，其方式与类的继承方式相同。

## 3.5 is和as运算符

as运算符的工作原理类似于类层次结构中的cast运算符——它返回对象的引用。然而，它从不抛出InvalidCastException异常。相反，如果对象不是所要求的类型，这个运算符就返回null。这里，最好在使用引用前验证它是否为空，否则以后使用以下引用，就会抛出NullReferenceException异常。

除了使用as运算符之外，还可以使用is运算符。is运算符根据条件是否满足，对象是否使用指定的类型，返回true或false。

# 4. 托管与非托管的资源

● 运行期间在栈和堆上分配空间 
● 垃圾回收 
● 使用析构函数和System.IDisposable接口来释放非托管的资源 
● C#中使用指针的语法 
● 使用指针实现基于栈的高性能数组 
● 平台调用，访问本机API

   　 **<u>*注意： 本节不详细介绍许多主题的相关内容。应把这一节看作是一般过程的简化向导，而不是实现的确切说明。*</u>**



## 4.1 资源

[浅入 .NET Core 中的内存和GC知识 - 痴者工良 - 博客园 (cnblogs.com)](https://www.cnblogs.com/whuanle/p/14259311.html)

[垃圾回收的基本知识 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/standard/garbage-collection/fundamentals)

较为详细的内存管理总结，参考以上两个链接。以下摘录一些基础的.NET内存管理知识。

## 4.2 .NET 内存组成



**<u>*.NET 中，内存分为非托管内存、托管内存。*</u>**

.NET Core/.NET5+ 有一个称为 **dotnet** 的驱动程序，此驱动程序用于**执行命令或运行 .NET 程序**。当我们使用 dotnet 命令运行一个 .dll 文件时，操作系统会启动 dotnet 驱动程序，此时会分配操作系统内存资源、dotnet 驱动程序内存资源，这一部分即非托管资源，其中 dotnet 部分的内存包含了 CLR 等部件的内存。即使你并没有使用到 C/C++ 等非托管代码或者使用非托管资源，也会使用到非托管内存。

接下来 CLR 将初始化新进程，CLR 将为其分配托管内存(**托管堆**)，这段托管内存是一个连续的地址空间区域。.NET 安全代码只能使用托管内存，不能直接使用物理内存，垃圾收集器会为安全代码在托管堆上分配和释放虚拟内存。



C#托管堆，本机堆的区别？

本机堆(Native Heap):.NET 的内存有非托管内存和托管内存。CLR 运行的进程，存在本机堆和托管堆两种内存堆，**<u>*本机内存堆通过 Windows API 的 [VirtualAlloc](https://docs.microsoft.com/zh-cn/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 函数分配，提供给 操作系统和 CLR 使用，用于非托管代码所需的内存。*</u>**

**<u>*使用托管和非托管的资源——存储在托管或本机堆中的对象。尽管垃圾收集器释放存储在托管堆中的托管对象，但不释放本机堆中的对象。必须由开发人员自己释放它们。*</u>**

## 4.3 栈内存的管理

由系统管理。下面简述其工作方式。

在处理器的虚拟内存中，有一个区域称为栈。**<u>*栈存储不是对象成员的值数据类型。*</u>**另外，**<u>*在调用一个方法时，也使用栈存储传递给方法的所有参数的副本。*</u>**为了理解栈的工作原理，需要注意在**<u>*C#中的变量作用域。*</u>**

核心在于：

**<u>*栈指针（操作系统维护的一个变量）表示栈中下一个空闲存储单元的地址。程序第一次开始运行时，栈指针指向为栈保留的内存块末尾。栈实际上是向下填充的，即从高内存地址向低内存地址填充。当数据入栈后，栈指针就会随之调整，以始终指向下一个空闲存储单元。*</u>**



## 4.4 托管堆的垃圾回收机制

**<u>*尽管栈有非常高的性能，但它还没有灵活到可以用于所有的变量。变量的生存期必须嵌套，在许多情况下，这种要求都过于苛刻。通常我们希望使用一个方法分配内存，来存储一些数据，并在方法退出后的很长一段时间内数据仍是可用的。只要是用new运算符来请求分配存储空间，就存在这种可能性——例如，对于所有的引用类型。此时就要使用托管堆。*</u>**

堆存在的原因。

### .net的托管堆的内存申请参考

托管堆（简称为堆）是处理器的可用内存中的另一个内存区域。要了解堆的工作原理和如何为引用数据类型分配内存，看看下面的代码： 

```C#
void DoWork() { 
    Customer arabel; //在栈上给这个引用分配存储空间,但这仅是一个引用，而不是实际的Customer对象
    arabel = new Customer(); 
    Customer otherCustomer2 = new EnhancedCustomer(); 
} 
```

在这段代码中，假定存在两个类Customer和EnhancedCustomer。EnhancedCustomer类扩展了Customer类。 首先，声明一个Customer引用arabel，在栈上给这个引用分配存储空间，但这仅是一个引用，而不是实际的Customer对象。arabel引用占用4个字节的空间，足够包含Customer对象的存储地址（需要4个字节把0～4GB之间的内存地址表示为一个整数值）。

 然后看下一行代码： arabel = new Customer(); 这行代码完成了以下操作：**<u>*首先，它分配堆上的内存，以存储Customer对象（一个真正的对象，不只是一个地址）。*</u>*****然后把变量arabel的值设置为分配给新Customer对象的内存地址（它还调用合适的Customer（）构造函数初始化类实例中的字段，但此处我们不必担心这部分）。***

 Customer实例没有放在栈中，而是放在堆中。在这个例子中，现在还不知道一个Customer对象占用多少字节，但为了讨论方便，假定是32个字节。这32个字节包含了Customer的实例字段，和.NET用于识别和管理其类实例的一些信息。

为了在堆上找到存储新Customer对象的一个存储位置，.NET运行库在堆中搜索，选取第一个未使用的且包含32个字节的连续块。

从这个例子可以看出，建立引用变量的过程要比建立值变量的过程更复杂，且不能避免性能的系统开销。**<u>*实际上，我们对这个过程进行了过分的简化，因为.NET运行库需要保存堆的状态信息，在堆中添加新数据时，这些信息也需要更新。尽管有这些性能开销，但仍有一种机制，在给变量分配内存时，不会受到栈的限制*</u>**。把一个引用变量的值赋予另一个相同类型的变量，就有两个变量引用内存中的同一对象了。**当一个引用变量超出作用域时，它会从栈中删除，如上一节所述，但引用对象的数据仍保留在堆中，一直到程序终止，或垃圾回收器删除它为止，而只有在该数据不再被任何变量引用时，它才会被删除。**



### .net GC

垃圾回收器具有以下优点：

- 开发人员不必手动释放内存。
- 有效分配**<u>*托管堆*</u>**上的对象。
- 回收不再使用的对象，清除它们的内存，并保留内存以用于将来分配。 托管对象会自动获取干净的内容来开始，因此，它们的构造函数不必对每个数据字段进行初始化。
- **<u>*通过确保对象不能使用另一个对象的内容来提供内存安全。*</u>**



托管堆的工作方式非常类似于栈，对象会在内存中一个挨一个地放置，这样就很容易使用指向下一个空闲存储单元的堆指针来确定下一个对象的位置。在堆上添加更多的对象时，也容易调整。但这比较复杂，因为基于堆的对象的生存期与引用它们的基于栈的变量的作用域不匹配。
***在垃圾回收器运行时，它会从堆中删除不再引用的所有对象。垃圾回收器在引用的根表中找到所有引用的对象，接着在引用的对象树中查找。在完成删除操作后，堆会立即把对象分散开来，与已经释放的内存混合在一起。***

**<u>*如果托管的堆也是这样，在其上给新对象分配内存就成为一个很难处理的过程，运行库必须搜索整个堆，才能找到足够大的内存块来存储每个新对象。*</u>**但是，垃圾回收器不会让堆处于这种状态。**<u>*只要它释放了能释放的所有对象，就会把其他对象移动回堆的端部，再次形成一个连续的内存块。*</u>**因此，<u>*堆可以继续像栈那样确定在什么地方存储新对象*</u>。当然，**<u>*在移动对象时，这些对象的所有引用都需要用正确的新地址来更新，但垃圾回收器也会处理更新问题。.*</u>**

**<u>*垃圾回收器的这个压缩操作是托管的堆与非托管的堆的区别所在。使用托管的堆，就只需要读取堆指针的值即可，而不需要遍历地址的链表，来查找一个地方放置新数据。*</u>**

一般情况下，垃圾回收器在.NET运行库确定需要进行垃圾回收时运行。可以调用System.GC.Collect（）方法，强迫垃圾回收器在代码的某个地方运行。System.GC类是一个表示垃圾回收器的.NET类，Collect（）方法启动一个垃圾回收过程。但是，GC类适用的场合很少，例如，代码中有大量的对象刚刚取消引用，就适合调用垃圾回收器。**<u>*但是，垃圾回收器的逻辑不能保证在一次垃圾收集过程中，所有未引用的对象都从堆中删除。*</u>**



GC的条件：

当满足以下条件之一时将发生垃圾回收：

- 系统具有低的物理内存。 这是通过 OS 的内存不足通知或主机指示的内存不足检测出来。
- 由托管堆上已分配的对象使用的内存超出了可接受的阈值。 随着进程的运行，此阈值会不断地进行调整。
- 调用 [GC.Collect](https://docs.microsoft.com/zh-cn/dotnet/api/system.gc.collect) 方法。 几乎在所有情况下，你都不必调用此方法，因为垃圾回收器会持续运行。 此方法主要用于特殊情况和测试。

### GC代数

垃圾回收主要在回收短生存期对象时发生。 为优化垃圾回收器的性能，将托管堆分为三代：第 0 代、第 1 代和第 2 代，因此它可以单独处理长生存期和短生存期对象。 垃圾回收器将新对象存储在第 0 代中。 在应用程序生存期的早期创建的对象如果未被回收，则被升级并存储在第 1 级和第 2 级中。 因为压缩托管堆的一部分要比压缩整个托管堆速度快，所以此方案允许垃圾回收器在每次执行回收时释放特定级别的内存，而不是整个托管堆的内存。

**第 0 代**。 这是最年轻的代，其中包含短生存期对象。 短生存期对象的一个示例是临时变量。 垃圾回收最常发生在此代中。

**第 1 代**。 这一代包含短生存期对象并用作短生存期对象和长生存期对象之间的缓冲区。

**第 2 代**。 这一代包含长生存期对象。 长生存期对象的一个示例是服务器应用程序中的一个包含在进程期间处于活动状态的静态数据的对象

垃圾回收中未回收的对象也称为幸存者，并会被提升到下一代：

- 第 0 代垃圾回收中未被回收的对象将会升级至第 1 代。
- 第 1 代垃圾回收中未被回收的对象将会升级至第 2 代。
- 第 2 代垃圾回收中未被回收的对象将仍保留在第 2 代。

### 垃圾回收过程中发生的情况

垃圾回收分为以下几个阶段：

- 标记阶段，找到并创建所有活动对象的列表。

- 重定位阶段，用于更新对将要压缩的对象的引用。

- 压缩阶段，用于回收由死对象占用的空间，并压缩幸存的对象。 压缩阶段将垃圾回收中幸存下来的对象移至段中时间较早的一端。

  因为第 2 代回收可以占用多个段，所以可以将已提升到第 2 代中的对象移动到时间较早的段中。 可以将第 1 代幸存者和第 2 代幸存者都移动到不同的段，因为它们已被提升到第 2 代。

  通常，由于复制大型对象会造成性能代偿，因此不会压缩大型对象堆 (LOH)。 但是，在 .NET Core 和 .NET Framework 4.5.1 及更高版本中，可以根据需要使用 [GCSettings.LargeObjectHeapCompactionMode](https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.gcsettings.largeobjectheapcompactionmode) 属性按需压缩大型对象堆。 此外，当通过指定以下任一项设置硬限制时，将自动压缩 LOH：

  - 针对容器的内存限制。
  - [GCHeapHardLimit](https://docs.microsoft.com/zh-cn/dotnet/core/run-time-config/garbage-collector#heap-limit) 或 [GCHeapHardLimitPercent](https://docs.microsoft.com/zh-cn/dotnet/core/run-time-config/garbage-collector#heap-limit-percent) 运行时配置选项。

垃圾回收器使用以下信息来确定对象是否为活动对象：

- **堆栈根**。 由实时 (JIT) 编译器和堆栈查看器提供的堆栈变量。 JIT 优化可以延长或缩短报告给垃圾回收器的堆栈变量内的代码的区域。
- **垃圾回收句柄**。 指向托管对象且可由用户代码或公共语言运行时分配的句柄。
- **静态数据**。 应用程序域中可能引用其他对象的静态对象。 每个应用程序域都会跟踪其静态对象。

**<u>*在垃圾回收启动之前，除了触发垃圾回收的线程以外的所有托管线程均会挂起。*</u>**

### 强引用与弱引用

如果应用程序的代码可以访问一个正由该程序使用的对象，垃圾回收器就不能回收该对象， 那么，就认为应用程序对该对象具有强引用。
<u>弱引用允许应用程序访问对象，同时也允许垃圾回收器收集相应的对象。</u>如果不存在强引用，则弱引用的有限期只限于收集对象前的一个不确定的时间段。 使用弱引用时，应用程序仍可对该对象进行强引用，这样做可防止该对象被收集。 **<u>*但始终存在这样的风险：垃圾回收器在重新建立强引用之前先处理该对象。*</u>**

占用大量内存，**<u>*但通过垃圾回收功能回收以后很容易重新创建的对象*</u>**特别适合使用弱引用。



弱引用是使用WeakReference类创建的。使用构造函数，可以传递强引用。示例代码创建了一个DataObject，并传递构造函数返回的引用。在使用WeakReference时，可以检查IsAlive属性。再次使用该对象时，WeakReference的Target属性就返回一个强引用。如果属性返回的值不是null，就可以使用强引用。因为对象可能在任意时刻被回收，所以在引用该对象前必须确认它存在。成功检索强引用后，可以通过正常方式使用它，现在它不能被垃圾回收，因为它有一个强引用：

```C#
// Instantiate a weak reference to MathTest object 
var myWeakReference = new WeakReference(new DataObject()); 
if (myWeakReference.IsAlive) { 
    DataObject strongReference = myWeakReference.Target as DataObject; 
    if (strongReference ! = null) { 
        // use the strongReference 
    } 
} 
else { 
    // reference not available 
}
```

## 4.4 处理非托管堆的资源



垃圾回收器的出现意味着，通常不需要担心不再需要的对象，只要让这些对象的所有引用都超出作用域，并允许垃圾回收器在需要时释放内存即可。但是，垃圾回收器不知道如何释放非托管的资源（例如，文件句柄、网络连接和数据库连接）。托管类在封装对非托管资源的直接或间接引用时，需要制定专门的规则，确保非托管的资源在回收类的一个实例时释放。

在定义一个类时，可以使用两种机制来自动释放非托管的资源。这些机制常常放在一起实现，因为每种机制都为问题提供了略为不同的解决方法。这两种机制是： 

**<u>*● 声明一个析构函数（或终结器），作为类的一个成员*</u>** 

**<u>*● 在类中实现System.IDisposable接口*</u>**

### 析构函数

C#编译器在编译析构函数时，它会隐式地把析构函数的代码编译为等价于重写Finalize（）方法的代码，从而确保执行父类的Finalize（）方法。下面列出的C#代码等价于编译器为～MyClass（）析构函数生成的IL：

```C#
protected override void Finalize() { 
    try { 
    	// Finalizer implementation
	} finally { base.Finalize(); } 
}
```



有经验的C++开发人员大量使用了析构函数，有时不仅用于清理资源，还提供调试信息或执行其他任务。C#析构函数要比C++析构函数的使用少得多。与C++析构函数相比，**<u>*C#析构函数的问题是它们的不确定性*</u>**。在销毁C++对象时，其析构函数会立即运行。**<u>*但由于使用C#时垃圾回收器的工作方式，无法确定C#对象的析构函数何时执行*</u>**。所以，**<u>*不能在析构函数中放置需要在某一时刻运行的代码，也不应寄望于析构函数会以特定顺序对不同类的实例调用*</u>**。<u>***如果对象占用了宝贵而重要的资源，应尽快释放这些资源，此时就不能等待垃圾回收器来释放了。***</u>

**<u>*因为垃圾回收器启动需要条件，要满足这些条件才能开始垃圾回收。*</u>** 

另一个问题是C**<u>*#析构函数的实现会延迟对象最终从内存中删除的时间*</u>**。**<u>*没有析构函数的对象会在垃圾回收器的一次处理中从内存中删除，但有析构函数的对象需要两次处理才能销毁*</u>**：第一次调用析构函数时，没有删除对象，第二次调用才真正删除对象。

**<u>*另外，运行库使用一个线程来执行所有对象的Finalize（）方法。如果频繁使用析构函数，而且使用它们执行长时间的清理任务，对性能的影响就会非常显著。*</u>**

### IDisposable接口

在C#中，推荐使用System.IDisposable接口替代析构函数。IDisposable接口定义了一种模式（具有语言级的支持），该模式为释放非托管的资源提供了确定的机制，并避免产生析构函数固有的与垃圾回收器相关的问题。

IDisposable接口声明了一个Dispose（）方法，它不带参数，返回void。MyClass类的Dispose（）方法的实现代码如下： 

```C#
class MyClass: IDisposable { 
    public void Dispose() { 
        // implementation 
    } 
}
```

Dispose（）方法的实现代码显式地释放由对象直接使用的所有非托管资源，并在所有也实现IDisposable接口的封装对象上调用Dispose（）方法。这样，Dispose（）方法为何时释放非托管资源提供了精确的控制。

可能会出现异常，更好的写法：

```C#
ResourceGobbler theInstance = null; 
try { 
    theInstance = new ResourceGobbler(); 
    // do your processing 
} 
finally { theInstance? .Dispose(); }
```

**<u>*在 try/finally 形式中没有单独对出现异常时处理的代码，finally 语句是无论 try 中的语句是否正确执行都会执行的语句。*</u>**

使用try/finally，即使在处理过程中出现了异常，也可以确保总是在theInstance上调用Dispose（）方法，总是释放theInstance使用的任意资源。但是，如果总是要重复这样的结构，代码就很容易被混淆。C#提供了一种语法，可以确保在实现IDisposable接口的对象的引用超出作用域时，在该对象上自动调用Dispose（）方法。该语法使用了using关键字来完成此工作——该关键字在完全不同的环境下，它与名称空间没有关系。下面的代码生成与try块等价的IL代码：

```C#
using (var theInstance = new ResourceGobbler()) { 
    // do your processing 
}
```

*<u>using语句的后面是一对圆括号，其中是引用变量的声明和实例化，该语句使变量的作用域限定在随后的语句块中。**另外，在变量超出作用域时，即使出现异常，也会自动调用其Dispose（）方法。**</u>*



● 利用运行库强制执行的析构函数，但析构函数的执行是不确定的，而且，由于垃圾回收器的工作方式，它会给运行库增加不可接受的系统开销。 

● IDisposable接口提供了一种机制，该机制允许类的用户控制释放资源的时间，但需要确保调用Dispose（）方法。
如果创建了终结器，就应该实现IDisposable接口。假定大多数程序员都能正确调用Dispose（）方法，同时把实现析构函数作为一种安全机制，以防没有调用Dispose（）方法。下面是一个双重实现的例子：

```C#
using System; 
public class ResourceHolder: IDisposable { 
    private bool _isDisposed = false; 
    public void Dispose() { 
        Dispose(true); 
        GC.SuppressFinalize(this); 
   	} 
    protected virtual void Dispose(bool disposing) {
        if (! _isDisposed) { 
            if (disposing) { 
                // Cleanup managed objects by calling their Dispose() methods. 
            } 
            // Cleanup unmanaged objects 
        } 
        _isDisposed = true; 
    } 
    ～ResourceHolder() { 
        Dispose (false); 
    } 
    public void SomeMethod() { 
        // Ensure object not already disposed before execution of any method 
        if(_isDisposed) { 
            throw new ObjectDisposedException("ResourceHolder"); 
        } 
        // method implementation… 
    } 
}
```

传递给Dispose（bool）方法的参数表示Dispose（bool）方法是由析构函数调用，还是由IDisposable.Dispose（）方法调用——Dispose（bool）方法不应从代码的其他地方调用，其原因是： 

● 如果使用者调用IDisposable.Dispose（）方法，该使用者就指定应清理所有与该对象相关的资源，包括托管和非托管的资源。 
● 如果调用了析构函数，原则上所有的资源仍需要清理。**<u>*但是在这种情况下，析构函数必须由垃圾回收器调用，而且用户不应试图访问其他托管的对象，因为我们不再能确定它们的状态了*</u>**。**<u>*在这种情况下，最好清理已知的非托管资源，希望任何引用的托管对象还有析构函数，这些析构函数执行自己的清理过程。*</u>**

最后，IDisposable.Dispose（）方法包含一个对System.GC.SuppressFinalize（）方法的调用。GC类表示垃圾回收器，SuppressFinalize（）方法则告诉垃圾回收器有一个类不再需要调用其析构函数了。**<u>*因为Dispose（）方法已经完成了所有需要的清理工作，所以析构函数不需要做任何工作。调用SuppressFinalize（）方法就意味着垃圾回收器认为这个对象根本没有析构函数。*</u>**

## 4.5 IDisposable和终结器的规则

学习了终结器和IDisposable接口后，就已经了解了Dispose模式和使用这些构造的规则。因为释放资源是托管代码的一个重要方面，下面总结如下规则：

● 如果类定义了实现IDisposable的成员，该类也应该实现IDisposable。 
● 实现IDisposable并不意味着也应该实现一个终结器。终结器会带来额外的开销，因为它需要创建一个对象，释放该对象的内存，需要GC的额外处理。只在需要时才应该实现终结器，例如，发布本机资源。要释放本机资源，就需要终结器。
● 如果实现了终结器，也应该实现IDisposable接口。这样，本机资源可以早些释放，而不仅是在GC找出被占用的资源时，才释放资源。 
● 在终结器的实现代码中，不能访问已终结的对象了。终结器的执行顺序是没有保证的。 
● 如果所使用的一个对象实现了IDisposable接口，就在不再需要对象时调用Dispose方法。如果在方法中使用这个对象，using语句比较方便。如果对象是类的一个成员，就让类也实现IDisposable。

## 4.6 不安全代码

用unsafe关键字编写不安全的代码，里面可以使用指针自己来管理内存，详略。

## 4.7 平台调用

并不是Windows API调用的所有特性都可用于.NET Framework。旧的Windows API调用是这样，Windows 10或Windows Server 2016中的新功能也是这样。

也许开发人员会编写一些DLL，导出非托管的方法，在C#中使用它们。 要重用一个非托管库，其中不包含COM对象，只包含导出的功能，就可以使用平台调用（P /Invoke）。有了P / Invoke, CLR会加载DLL，其中包含应调用的函数，并编组参数。

使用方法：

要使用非托管函数，首先必须确定导出的函数名。为此，可以使用dumpbin工具和/exports选项。例如，命令：

```
dumpbin /exports c:\windows\system32\kernel32.dll | more
```

这个命令列出kernel32.dll中所有导出的函数。这个示例使用Windows API函数CreateHardLink来创建到现有文件的硬链接。使用此API调用，可以用几个文件名引用相同的文件，只要文件名在一个硬盘上即可。这个API调用不能用于.NET Framework 4.5.1，因此必须使用平台调用。

为了调用本机函数，必须定义一个参数数量相同的C#外部方法，用非托管方法定义的参数类型必须用托管代码映射类型。

**<u>*这个定义必须映射到.NET数据类型上。非托管代码的返回类型是BOOL；它仅映射到bool数据类型。LPCTSTR定义了一个指向const字符串的long指针。Windows API给数据类型使用Hungarian命名约定。LP是一个long指针，C是一个常量，STR是以null结尾的字符串。T把类型标志为泛型类型，根据编译器设置为32还是64位，该类型解析为LPCSTR（ANSI字符串）或LPWSTR（宽Unicode字符串）。C字符串映射到.NET类型为String。LPSECURITY_ATTRIBUTES是一个long指针，指向SECURITY_ATTRIBUTES类型的结构。因为可以把NULL传递给这个参数，所以把这种类型映射到IntPtr是可行的。*</u>**该方法的

**<u>*C#声明必须用extern修饰符标记，因为在C#代码中，这个方法没有实现代码。相反，该方法的实现代码在DLL kernel32.dll中，它用属性[DllImport]引用。*</u>**

**<u>*.NET声明CreateHardLink的返回类型是bool，本机方法CreateHardLink返回一个布尔值，所以需要一些额外的澄清。因为C++有不同的Boolean数据类型（例如，本机bool和Windows定义的BOOL有不同的值），所以特性[MarshalAs]指定.NET类型bool应该映射为哪个本机类型*</u>**：

eg:

```C#
[DllImport("kernel32.dll", SetLastError="true", EntryPoint="CreateHardLink", CharSet=CharSet.Unicode)] [return: MarshalAs(UnmanagedType.Bool)] 
public static extern bool CreateHardLink(string newFileName, string existingFilename, IntPtr securityAttributes);
```

| DLLIMPORT属性或字段 | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| EntryPoint          | 可以给函数的C#声明指定与非托管库不同的名称。非托管库中方法的名称在EntryPoint字段中定义 |
| CallingConvention   | 根据编译器或用来编译非托管函数的编译器设置，可以使用不同的调用约定。调用约定定义了如何处理参数，把它们放在堆栈的什么地方。可以设置一个可枚举的值，来定义调用约定。Windows API在Windows操作系统上通常使用StdCall调用约定，在Windows CE上使用Cdecl调用约定。把值设置为CallingConvention.Winapi，可让Windows API用于Windows和Windows CE环境 |
| CharSet             | 字符串参数可以是ANSI或Unicode。通过CharSet设置，可以定义字符串的管理方式。用CharSet枚举定义的值有Ansi、Unicode和Auto.CharSet。Auto在Windows NT平台上使用Unicode，在微软的旧操作系统上使用ANSI |
| SetLastError        | 如果非托管函数使用Windows API SetLastError设置一个错误，就可以把SetLastError字段设置为true。这样，就可以使用Marshal. GetLastWin32Error读取后面的错误号 |
|                     |                                                              |

# 5. 泛型

## 5.1 泛型及其相关概念

### 5.1.1 泛型概念及其优缺点

Language，中间语言）代码紧密地集成。有了泛型（Generic），就可以创建独立于被包含类型的类和方法。我们不必给不同的类型编写功能相同的许多方法或类，只创建一个方法或类即可。

另一个减少代码的选项是使用Object类，但使用派生自Object类的类型进行传递不是**<u>*类型安全*</u>**的。泛型类使用泛型类型，并可以根据需要用特定的类型替换泛型类型。这就保证了类型安全性：如果某个类型不支持泛型类，编译器就会出现错误。

**<u>*泛型不仅限于类，还可以用于接口和方法，委托。*</u>**



泛型不仅存在于C#中，其他语言中有类似的概念。**<u>*例如，C++模板就与泛型相似。但是，C++模板和.NET泛型之间有一个很大的区别。对于C++模板，在用特定的类型实例化模板时，需要模板的源代码。相反，泛型不仅是C#语言的一种结构，而且是CLR（Common Language Runtime）定义的。所以，即使泛型类是在C#中定义的，也可以在Visual Basic中用一个特定的类型实例化该泛型。*</u>**

泛型的优缺点：
● 性能 
● 类型安全性 
● 二进制代码重用 
● 代码的扩展 
● 命名约定

### 5.1.2 装箱与拆箱

泛型的一个主要优点是性能。第11章介绍了System.Collections和System.Collections.Generic名称空间的泛型和非泛型集合类。对值类型使用非泛型集合类，在把值类型转换为引用类型，和把引用类型转换为值类型时，需要进行装箱和拆箱操作。

装箱：
值类型存储在栈上，引用类型存储在堆上。C#类是引用类型，结构是值类型。.NET很容易把值类型转换为引用类型，所以可以在需要对象（对象是引用类型）的任意地方使用值类型。例如，int可以赋予一个对象。**<u>*从值类型转换为引用类型称为装箱。*</u>**<u>如果方法需要把一个对象作为参数，同时传递一个值类型，装箱操作就会自动进行</u>。另一方面，装箱的值类型可以使用拆箱操作转换为值类型。在拆箱时，需要使用类型强制转换运算符。

装箱：将值类型（如 int ，或自定义的值类型等）转换成 object 或者接口类型的一个过程。当 CLR 对值类型进行装箱时，会将该值包装为 System.Object 类型，再将包装后的对象存储在堆上。 拆箱就是从对象中提取对应的值类型的一个过程。

装箱是隐式的；拆箱必定是显式的。

[[C#\] C# 知识回顾 - 装箱与拆箱 - 反骨仔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/liqingwen/p/6486332.html#:~:text=C%23 的装箱与拆箱 装箱：将值类型（如 int ，或自定义的值类型等）转换成 object,或者接口类型的一个过程。 当 CLR 对值类型进行装箱时，会将该值包装为 System.Object 类型，再将包装后的对象存储在堆上。)

## 5.2 泛型类的创建

模板如下：

```C#
public class LinkedListNode<T> { 
    public LinkedListNode(T value) { Value = value; } 
    public T Value { get; private set; } 
    public LinkedListNode<T> Next { get; internal set; } 
    public LinkedListNode<T> Prev { get; internal set; } 
}
public class LinkedList<T>: IEnumerable<T> { 
    public LinkedListNode<T> First { get; private set; } 
    public LinkedListNode<T> Last { get; private set; } 
    public LinkedListNode<T> AddLast(T node) { 
        var newNode = new LinkedListNode<T>(node); 
        if (First == null) { First = newNode; Last = First; } 
        else { LinkedListNode<T> previous = Last; 
              Last.Next = newNode; Last = newNode; 
              Last.Prev = previous; } return newNode; 
    } 
    public IEnumerator<T> GetEnumerator() { 
        LinkedListNode<T> current = First; 
        while (current != null) { 
            yield return current.Value; 
            current = current.Next; 
        } 
    } 
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator(); 
}
```

创建泛型类其他的一些关键字。

● 默认值 
● 约束 
● 继承 
● 静态成员

### 5.2.1 默认值 

default关键字根据上下文可以有多种含义。switch语句使用default定义默认情况。在泛型中，取决于泛型类型是引用类型还是值类型，泛型default将泛型类型初始化为null或0。
eg：

```C#
public T GetDocument() { 
    T doc = default(T); 
    lock (this) { 
        doc = documentQueue.Dequeue(); 
    } 
    return doc; 
}
```

### 5.2.2 约束

限制泛型类的设置。

```C#
public class MyClass<T> where T: IFoo, new() { 
    //...
}
```

   

| 约束              | 说明                                                  |
| ----------------- | ----------------------------------------------------- |
| where T : struct  | 对于结构约束，类型T必须是值类型                       |
| where T : class   | 类约束指定类型T必须是引用类型                         |
| where T : IFoo    | 指定类型T必须实现接口IFoo                             |
| where T : Foo     | 指定类型T必须派生自基类Foo                            |
| where T : new（） | 这是一个构造函数约束，指定类型T必须有一个默认构造函数 |
| where T1 : T2     | 这个约束也可以指定，类型T1派生自泛型类型T2            |
|                   |                                                       |

   **<u>*注意： 只能为默认构造函数定义构造函数约束，不能为其他构造函数定义构造函数约束。*</u>**

**<u>*注意： 在C#中，where子句的一个重要限制是，不能定义必须由泛型类型实现的运算符。运算符不能在接口中定义。在where子句中，只能定义基类、接口和默认构造函数。*</u>**

### 5.2.3 继承

前面创建的LinkedList<T>类实现了IEnumerable<T> 接口： 

```C#
public class LinkedList<T>: IEnumerable<T> { //... 泛型类型可以实现泛型接口，也可以派生自一个类。泛型类可以派生自泛型
}
```

泛型类型可以实现泛型接口，也可以派生自一个类。泛型类可以派生自泛型基类：

```C#
public class Base<T> { } 
public class Derived<T>: Base<T> { } 
```

**<u>*其要求是必须重复接口的泛型类型，或者必须指定基类的类型，如下例所示：*</u>**

```C#
public class Base<T> { } 
public class Derived<T>: Base<string> { }
```
 于是，派生类可以是泛型类或非泛型类。例如，可以定义一个抽象的泛型基类，它在派生类中用一个具体的类实现。这允许对特定类型执行特殊的操作：
```C#
public abstract class Calc<T> { 
	public abstract T Add(T x, T y); 
    public abstract T Sub(T x, T y); 
} 
public class IntCalc: Calc<int> { 
    public override int Add(int x, int y) => x + y; 
    public override int Sub(int x, int y) => x - y; 
}
```
 还可以创建一个部分的特殊操作，如从Query中派生StringQuery类，只定义一个泛型参数，如字符串TResult。要实例化StringQuery，只需要提供TRequest的类型： 

```C#
public class Query<TRequest, TResult> { } 
public StringQuery<TRequest> : Query<TRequest, string> { }
```

### 5.2.4 静态成员

泛型类的静态成员需要特别关注。**<u>*泛型类的静态成员只能在类的一个实例中共享。*</u>**

## 5.3 泛型接口

接口可以泛型。

例如：

```C#
public interface IComparable<in T> { int CompareTo(T other); }
```

### 5.3.1 协变和抗变

协变和抗变指对参数和返回值的类型进行转换。例如，可以给一个需要Shape参数的方法传送Rectangle参数吗？下面用示例说明这些扩展的优点。

**<u>*在.NET中，参数类型是协变的。假定有Shape和Rectangle类，Rectangle派生自Shape基类。声明Display（）方法是为了接受Shape类型的对象作为其参数：*</u>**

```C#
public void Display(Shape o) { }
```

**<u>*现在可以传递派生自Shape基类的任意对象。因为Rectangle派生自Shape，所以Rectangle满足Shape的所有要求，编译器接受这个方法调用。*</u>**

**<u>*方法的返回类型是抗变的。当方法返回一个Shape时，不能把它赋予Rectangle，因为Shape不一定总是Rectangle。*</u>**



**<u>*如果泛型类型用out关键字标注，泛型接口就是协变的。这也意味着返回类型只能是T。*</u>**

**<u>*如果泛型类型用in关键字标注，泛型接口就是抗变的。这样，接口只能把泛型类型T用作其方法的输入。*</u>**





## 5.4 泛型结构



**<u>*与类相似，结构也可以是泛型的。它们非常类似于泛型类，只是没有继承特性。*</u>**

实例：

```C#
public struct Nullable<T> where T: struct { 
        public Nullable(T value) { _hasValue = true; _value = value; } 
        private bool _hasValue; 
        public bool HasValue => _hasValue; 
        private T _value; 
        public T Value { get { if (! _hasValue) { throw new InvalidOperationException("no value"); } return _value; } } 
        //用户定义的强制类型转换操作符
        public static explicit operator T(Nullable<T> value) {
            System.Console.WriteLine("强制类型转换");
            return value.Value;
        }
        public static implicit operator Nullable<T>(T value){
            System.Console.WriteLine("隐式类型转换");
            return new Nullable<T>(value);
        } 
        public override string ToString() => ! HasValue ? string.Empty : _value.ToString(); 
    
    }
```

## 5.5 泛型方法

除了定义泛型类之外，还可以定义泛型方法。在泛型方法中，泛型类型用方法声明来定义。泛型方法可以在非泛型类中定义。

但是，因为C#编译器会通过调用Swap（）方法来获取参数的类型，所以不需要把泛型类型赋予方法调用。泛型方法可以像非泛型方法那样调用。

见例代码，泛型方法，可以省挺多事，还可以带约束，传递委托。

泛型方法重载：

**<u>*需要注意的是，所调用的方法是在编译期间而不是运行期间定义的。*</u>**

# 6 数组与元组

同一个类型的对个对象，就可以使用集合和数组。**<u>*C#用特殊的记号声明、初始化和使用数组，Array类在后台发挥作用，它为数组中的元素的排序和过滤提供了几个方法。使用枚举器，可以迭代数组中的所有元素。*</u>**
如果需要使用不同类型的多个对象，可以使用Tuple（元组）类型。

## 6.1 简单数组

C#中的数组。同类型的多个对象。数组可以存储指定的任何元素类型。

### 数组的声明

```C#
int[] myArray;
```

### 初始化

1.指定长度的默认初始化（值默认为0）

```C#
myArray = new int[4]
```

2.可以在声明数组时初始化数组的元素。 不需要长度说明符，因为可以根据初始化列表中的元素数量推断得出。

```C#
int[] array1 = new int[] { 1, 3, 5, 7, 9 };
```

3.在声明时初始化数组时，可以避免使用 `new` 表达式和数组类型，如以下代码所示。 这称为[隐式类型化数组](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays)：

```C#
int[] array2 = { 1, 3, 5, 7, 9 };
string[] weekDays2 = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
```
***注意： 在指定了数组的大小后，如果不复制数组中的所有元素，就不能重新设置数组的大小。如果事先不知道数组中应包含多少个元素，就可以使用集合。集合请参见第11章。（？）***

### 访问数组元素

数组只支持有整形参数的索引器。通过索引器传递元素编号，就可以访问数组。索引器总是以0开头，表示第一个元素。可以传递给索引器的最大值是元素个数减1，因为索引从0开始。

***注意： 如果使用错误的索引器值（大于数组的长度），就会抛出IndexOutOfRangeException类型的异常。***

### 使用引用类型

声明一个包含两个Person元素的数组与声明一个int数组类似： 

```C#
Person[] myPersons = new Person[2]; 
```

**<u>*但是必须注意，如果数组中的元素是引用类型，就必须为每个数组元素分配内存。若使用了数组中未分配内存的元素，就会抛出NullReferenceException类型的异常。*</u>**

与int类型一样，也可以对自定义类型使用数组初始化器：

```C#
Person[] myPersons2 = { 
    new Person { FirstName="Ayrton", LastName="Senna"}, 
    new Person { FirstName="Michael", LastName="Schumacher"} };
```

##  6.2 多维数组

一般数组（也称为一维数组）用一个整数来索引。多维数组用两个或多个整数来索引。

在C#中声明这个二维数组，需要在方括号中加上一个逗号。数组在初始化时应指定每一维的大小（也称为阶）。接着，就可以使用两个整数作为索引器来访问数组中的元素：

```C#
int[, ] twodim = new int[3, 3]; 
twodim[0, 0] = 1; twodim[0, 1] = 2; twodim[0, 2] = 3; twodim[1, 0] = 4; twodim[1, 1] = 5; twodim[1, 2] = 6; twodim[2, 0] = 7; twodim[2, 1] = 8; twodim[2, 2] = 9;
```

### 声明

形如：

```C#
int[, ] twodim = new int[3, 3];
```

### 初始化

形如：

```C#
int[, ] twodim = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
int[, , ] threedim = { { { 1, 2 }, { 3, 4 } }, { { 5, 6 }, { 7, 8 } }, { { 9, 10 }, { 11, 12 } } }; 
```

　 *<u>**注意（多维数组）： 使用数组初始化器时，必须初始化数组的每个元素，不能遗漏任何元素。**</u>*

## 6.3 锯齿数组

二维数组的大小对应于一个矩形，如对应的元素个数为3×3。而锯齿数组的大小设置比较灵活，在锯齿数组中，每一行都可以有不同的大小。

### 声明

形如：

```C#
int[][] twodim = new int[3][];
```

### 初始化

形如：

```C#
int[][] jagged = new int[3][]; 
jagged[0] = new int[2] { 1, 2 }; 
jagged[1] = new int[6] { 3, 4, 5, 6, 7, 8 }; 
jagged[2] = new int[3] { 9, 10, 11 };
```

## 6.4 Array类

***用方括号声明数组是C#中使用Array类的表示法。在后台使用C#语法，会创建一个派生自抽象基类Array的新类。***这样，就可以使用Array类为每个C#数组定义的方法和属性了。例如，前面就使用了Length属性，或者使用foreach语句迭代数组-其实这是使用了Array类中的GetEnumerator（）方法。

### 6.4.1 ArraySegment< T >

结构ArraySegment< T>表示数组的一段。如果需要使用不同的方法处理某个大型数组的不同部分，那么可以把相应的数组部分复制到各个方法中。此时，与创建多个数组相比，更有效的方法是使用一个数组，将整个数组传递给不同的方法。这些方法只使用数组的某个部分。方法的参数除了数组以外，还应包括数组内的偏移量以及该方法应该使用的元素数。这样一来，方法就需要至少3个参数。当使用数组段时，只需要一个参数就可以了。ArraySegment< T>结构包含了关于数组段的信息（偏移量和元素个数）。

注意： 数组段不复制原数组的元素，但原数组可以通过ArraySegment< T>访问。如果数组段中的元素改变了，这些变化就会反映到原数组中。

### 6.4.2 数组迭代器

在foreach语句中使用枚举，可以迭代集合中的元素，且无须知道集合中的元素个数。foreach语句使用了一个枚举器。图7-7显示了调用foreach方法的客户端和集合之间的关系。数组或集合实现带GetEumerator（）方法的IEumerable接口。GetEumerator（）方法返回一个实现IEumerator接口的枚举。接着，foreach语句就可以使用IEumerable接口迭代集合了。



foreach语句会解析为下面的代码段。首先，调用GetEnumerator（）方法，获得数组的一个枚举器。在while循环中——只要MoveNext（）返回true——就用Current属性访问数组中的元素： 

```C#

foreach (var p in persons) { WriteLine(p); }
//等价于
IEnumerator<Person> enumerator = persons.GetEnumerator(); 
while (enumerator.MoveNext()) { 
    Person p = enumerator.Current; 
    WriteLine(p); 
}
```

### 6.4.3　yield语句

yield return语句返回集合的一个元素，并移动到下一个元素上。yield break可停止迭代。

示例：

```C#
using System; 
using System.Collections; 
namespace Wrox.ProCSharp.Arrays { 
    public class HelloCollection { 
        public IEnumerator<string> GetEnumerator() { 
            yield return "Hello"; 
            yield return "World"; 
        } 
    }
}
```





public class HelloCollection { public IEnumerator GetEnumerator() => new Enumerator(0); public class Enumerator:IEnumerator<string>, IEnumerator, IDisposable { private int _state; private string _current; public Enumerator(int state) { _state = state; } bool System.Collections.IEnumerator.MoveNext() { switch (state) { case 0: _current = "Hello"; _state = 1; return true; case 1: _current = "World"; _state = 2; return true; case 2: break; } return false; } void System.Collections.IEnumerator.Reset() { throw new NotSupportedException(); } string System.Collections.Generic.IEnumerator<string>.Current => current; object System.Collections.IEnumerator.Current => current; void IDisposable.Dispose() { } } }
### 6.4.1 Array的创建

Array是个抽象类，不能使用构造函数来创建。可以使用CreateInstance来创建数组。如果事先不知道元素的类型，该方法就有用了。

```C#
Array intArray1 = Array.CreateInstance(typeof(int), 5); 
for (int i = 0; i < 5; i++) { 
    intArray1.SetValue(33, i); 
} 
for (int i = 0; i < 5; i++) { 
    WriteLine(intArray1.GetValue(i)); 
}
```

CreateInstance（）方法有许多重载版本，可以创建多维数组和不基于0的数组。例子略。

### 6.4.2 Array的复制

因为数组是引用类型，所以将一个数组变量赋予另一个数组变量，就会得到两个引用同一数组的变量。而复制数组，会使数组实现ICloneable接口。**<u>*这个接口定义的Clone（）方法会创建数组的浅表副本。*</u>**



*<u>**如果数组的元素是值类型，就会开辟新空间存储值。**</u>*

*<u>**如果数组的元素是引用类型，就会开辟新空间存储引用。**</u>*

*<u>**注意： 如果需要包含引用类型的数组的深层副本，就必须迭代数组并创建新对象。**</u>*

除了使用Clone（）方法之外，还可以使用Array.Copy（）方法创建浅表副本。但Clone（）方法和Copy（）方法有一个重要区别：Clone（）方法会创建一个新数组，而Copy（）方法必须传递阶数相同且有足够元素的已有数组。

### 6.4.3 Array的排序

Array类使用Quicksort算法对数组中的元素进行排序。Sort（）方法需要数组中的元素实现IComparable接口。因为简单类型（如System.String和System.Int32）实现IComparable接口，所以可以对包含这些类型的元素排序。

注意： Array类还提供了Sort方法，它需要将一个委托作为参数。这个参数可以传递给方法，从而比较两个对象，而不需要依赖IComparable或IComparer接口。第9章将介绍如何使用委托。

## 6.5 数组作为参数

数组可以作为参数传递给方法，也可以从方法返回。要返回一个数组，只需要把数组声明为返回类型。

```C#
static void DisplayPersons(Person[] persons) { //...
}
static Person[] GetPersons(){ //...
}
```

### 6.5.1 数组协变

数组支持协变。这表示数组可以声明为基类，其派生类型的元素可以赋予数组元素。

例如，可以声明一个object[]类型的参数，给它传递一个Person[]： 

```C#
static void DisplayArray(object[] data) { //… 
}
```

　 **<u>*注意： 数组协变只能用于引用类型，不能用于值类型。另外，数组协变有一个问题，它只能通过运行时异常来解决。如果把Person数组赋予object数组，object数组就可以使用派生自object的任何元素。例如，编译器允许把字符串传递给数组元素。但因为object数组引用Person数组，所以会出现一个运行时异常ArrayTypeMismatchException。*</u>**

**<u>*？？？？？？？？查查英文原书，这段翻译感觉问题很大*</u>**

### 6.5.2 ArraySegment<T>

