# C#运行环境

## 什么是.net(dotnet)?

全称应该为.net framework。.NET框架是一个多语言组件开发和执行环境，它提供了一个跨语言的统一编程环境。.NET框架又包括三个主要组成部分：公共语言运行库（CLR：Common Language Runtime）、[服务框架](https://baike.baidu.com/item/服务框架)（Services Framework）和上层的两类应用模板——传统的Windows应用程序模板（Win Forms）和基于ASP.NET的面向Web的网络应用程序模板（Web Forms和Web Services）。

.NET FrameWork的核心是其运行库执行环境，称为公共语言运行库(CLR，Common Language Runtime)。

.Net 编程语言的编译器会将代码编译成中间语言（Intermediate Language,IL）代码。IL代码看起来像面向对象的机器码，使用工具ildasm.exe可以打开包含.net代码的dll或exe文件来检查il代码。CLR包含了一个及时（just-in-time,jit)编译器，当程序开始运行时，jit编译器会从il代码生成本地代码。

## .net编程语言的编译过程以及CLR作用？

**在.net中，**
**(1)将源代码编译成mircrosoft中间语言（Intermediate Language,IL）代码。**
**(2)CLR把IL编译为平台专用的本地代码。**
**IL代码在.net程序集中可用。在运行时，jit编译器编译IL代码，创建特定于平台的本地代码。**

**CLR还包括一个带有类型加载器的类型系统，类型加载器负责从程序集中加载类型。CLR的另一个功能是垃圾回收器，垃圾回收器从托管堆中清除不再引用的内存。CLR还负责线程的处理。在C#中创建托管的线程不一定来自底层操作系统。线程的虚拟化和管理由CLR负责。**

# C#语言基础

# 1. 变量

变量声明

```C#
int i;
```

该语句声明int变量i。**实际上编译器不允许在表达式中使用这个变量，除非用一个值初始化了该变量。**
如果在一条语句中声明和初始化了多个变量，那么所有的变量都具有相同的数据类型： 

```C#
int x = 10, y =20; // x and y are both ints 
```

要声明不同类型的变量，需要使用单独的语句。在一条多变量的声明中，不能指定不同的数据类型：

```C#
int x = 10; bool y = true; // Creates a variable that stores true or false int x = 10, bool y = true; // This won't compile!
```

##  1.1 变量的初始化

变量的初始化是C#强调安全性的另一个例子。简单地说，C#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用该变量。**大多数现代编译器把没有初始化标记为警告**，**但C#编译器把它当成错误来看待**。这就可以防止我们无意中从其他程序遗留下来的内存中检索垃圾值。 C#有两个方法可确保变量在使用前进行了初始化：
 ● 变量是类或结构中的字段，如果没有显式初始化，则创建这些变量时，其默认值就是0（类和结构在后面讨论）。
 ● 方法的局部变量必须在代码中显式初始化，之后才能在语句中使用它们的值。此时，初始化不是在声明该变量时进行的，但编译器会通过方法检查所有可能的路径，如果检测到局部变量在初始化之前就使用了其值，就会标记为错误。

## 1.2 类型推断

**类型推断使用var关键字。声明变量的语法有些变化：使用var关键字替代实际的类型。编译器可以根据变量的初始化值“推断”变量的类型。**

 类型推断需要遵从一些规则：
● 变量必须初始化。否则，编译器就没有推断变量类型的依据。
● 初始化器不能为空。 
● 初始化器必须放在表达式中。 
● 不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象。

## 1.3 变量的作用域

变量的作用域是可以访问该变量的代码区域。一般情况下，确定作用域遵循以下规则： 
● 只要类在某个作用域内，其字段（也称为成员变量）也在该作用域内。 
● 局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内。 
● 在for、while或类似语句中声明的局部变量存在于该循环体内。

有两种冲突情况

1.局部作用域内的冲突
大型程序在不同部分为不同的变量使用相同的变量名很常见。只要变量的作用域是程序的不同部分，就不会有问题，也不会产生多义性。但要注意，同名的局部变量不能在同一作用域内声明两次。声明两次会无法通过编译。
2.局部变量与类字段的冲突
某些情况下，可以区分名称相同（尽管其完全限定名不同）、作用域相同的两个标识符。此时编译器允许声明第二个变量。原因是C#在变量之间有一个基本的区分，它把在类型级别声明的变量看成字段，而把在方法中声明的变量看成局部变量。
**<u>但是，如果要引用类级别变量，该怎么办？可以使用语法object.fieldname，在对象的外部引用类或结构的字段。</u>**

## 1.4 常量

顾名思义，常量是其值在使用过程（生命周期）中不会发生变化的变量。在声明和初始化变量时，在变量的前面加上关键字const，就可以把该变量指定为一个常量。
常量具有如下特点：
● 常量必须在声明时初始化。指定了其值后，就不能再改写了。 
● 常量的值必须能在编译时用于计算。因此，不能用从变量中提取的值来初始化常量。如果需要这么做，应使用只读字段（详见第3章）。 
● **常量总是隐式静态的。但注意，不必（实际上，是不允许）在常量声明中包含修饰符static。** 

在程序中使用常量至少有3个好处： 
● 由于使用易于读取的名称（名称的值易于理解）替代了较难读取的数字和字符串，常量使程序变得更易于阅读。 
● 常量使程序更易于修改。例如，在C#程序中有一个SalesTax常量，该常量的值为6%。如果以后销售税率发生变化，把新值赋给这个常量，就可以修改所有的税款计算结果，而不必查找整个程序去修改税率为0.06的每个项。
● 常量更容易避免程序出现错误。如果在声明常量的位置以外的某个地方将另一个值赋给常量，编译器就会标记错误。

## 1.5 预定义数据类型(变量的类型)

两中大的分类：

1.值类型
2.引用类型

从概念上看，其区别是值类型直接存储其值，而引用类型存储对值的引用。
这两种类型存储在内存的不同地方：值类型存储在堆栈（stack）中，而引用类型存储在托管堆（managed heap）上。注意区分某个类型是值类型还是引用类型，因为这会有不同的影响。例如，int是值类型，这表示下面的语句会在内存的两个地方存储值20：

C#把基本类型（如int和bool）规定为值类型，而把包含许多字段的较大类型（通常在有类的情况下）规定为引用类型，C#设计这种方式是为了得到最佳性能。如果要把自己的类型定义为值类型，**就应把它声明为一个结构。**

**大多数更复杂的C#数据类型，包括我们自己声明的类，都是引用类型。它们分配在堆中，其生存期可以跨多个函数调用，可以通过一个或几个别名来访问。CLR实现一种精细的算法，来跟踪哪些引用变量仍是可以访问的，哪些引用变量已经不能访问了。CLR会定期删除不能访问的对象，把它们占用的内存返回给操作系统。这是通过垃圾回收器实现的。**

### 1.5.1 .net类型

数据类型的C#关键字（如int、short和string）从编译器映射到.NET数据类型。例如，在C#中声明一个int类型的数据时，声明的实际上是.NET结构System.Int32的一个实例。这听起来似乎很深奥，但其意义深远：这表示在语法上，可以把所有的基本数据类型看成支持某些方法的类。例如，要把int i转换为string类型，可以编写下面的代码： string s = i.ToString(); **<u>应强调的是，在这种便利语法的背后，类型实际上仍存储为基本类型。</u>**基本类型在概念上用.NET结构表示，所以肯定没有性能损失。 

下面看看C#中定义的内置类型。我们将列出每个类型，以及它们的定义和对应.NET类型的名称。C#有15个预定义类型，其中13个是值类型，两个是引用类型（string和object）。

### 1.5.2 C#类型

具体的定义略，可以参考，**[美] Christian Nagel. C#高级编程(第10版) C# 6 & .NET Core 1.0 (2.4.3). 清华大学出版社.**

**有些C#类型的名称与C++和Java类型一致，但定义不同。例如，在C#中，int总是32位有符号的整数。而在C++中，int是有符号的整数，但其位数取决于平台（在Windows上是32位）。在C#中，所有的数据类型都以与平台无关的方式定义，以备将来从C#和.NET迁移到其他平台上。**

**如果对一个int、uint、long还是ulong类型的整数没有任何显式的声明，则该变量默认为int类型。为了把输入的值指定为其他整数类型，可以在数字后面加上如下字符：**

```C#
uint ui = 1234U; long l = 1234L; ulong ul = 1234UL;
```

**bool值和整数值不能相互隐式转换。如果变量（或函数的返回类型）声明为bool类型，就只能使用值true或false。如果试图使用0表示false，非0值表示true，就会出错。**

**char类型的字面量是用单引号括起来的，如’A'。如果把字符放在双引号中，编译器会把它看成字符串，从而产生错误。**

**<u>*C#有string关键字，转换为.NET类System.String。有了它，像字符串连接和字符串复制这样的操作就很简单了。尽管它为引用类型，string类已实现，其语义遵循一般的、直观的字符串规则。*</u>**

**名称空间的别名**,如下

```C#
using alias = NamespaceName;
```



## 1.6  XML文档

如前所述，除了C风格的注释外，C#还有一个非常出色的功能（本章将讨论这一功能）：根据特定的注释自动创建XML格式的文档说明。这些注释都是单行注释，但都以3条斜杠（///）开头，而不是通常的两条斜杠。在这些注释中，可以把包含类型和类型成员的文档说明的XML标记放在代码中。

编译器可以识别一些格式的注释文档。

## 1.7  C#预处理器指令

**注意： C++开发人员应该知道，在C和C++中预处理器指令非常重要。但是，在C#中，并没有那么多的预处理器指令，它们的使用也不太频繁。C#提供了其他机制来实现许多C++指令的功能，如定制特性。还要注意，C#并没有一个像C++那样的独立预处理器，所谓的预处理器指令实际上是由编译器处理的。尽管如此，C#仍保留了一些预处理器指令名称，因为这些命令会让人觉得就是预处理器。**

# 2. 对象与类型

结构不同于类，因为它们不需要在堆上分配空间（类是引用类型，总是存储在堆（heap）上），而结构是值类型，通常存储在栈（stack）上，另外，结构不支持继承。对于类和结构，都使用关键字new来声明实例：这个关键字创建对象并对其进行初始化。

**类和结构的一个重要区别是，类类型的对象通过引用传递，结构类型的对象按值传递。**

类中的成员说明：

| 成员     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 字段     | 字段是类的数据成员，它是类型的一个变量，该类型是类的一个成员 |
| 方法     | 方法是与特定类相关联的函数                                   |
| 常量     | 常量与类相关（尽管它们没有static修饰符）。编译器使用真实值代替常量 |
| 属性     | 属性是可以从客户端访问的函数组，其访问方式与访问类的公共字段类似。C#为读写类中的属性提供了专用语法，所以不必使用那些名称中嵌有Get或Set的方法。因为属性的这种语法不同于一般函数的语法，所有在客户端代码中，虚拟的对象被当作实际的东西 |
| 构造函数 | 构造函数是在实例化对象时自动调用的特殊函数。它们必须与所属的类同名，且不能有返回类型。构造函数用于初始化字段的值 |
| 索引器   | 索引器允许对象用访问数组的方式访问。索引器参见第8章          |
| 运算符   | 运算符执行的最简单的操作就是加法和减法。在两个整数相加时，严格地说，就是对整数使用“+”运算符。C#还允许指定把已有的运算符应用于自己的类（运算符重载）。第8章将详细论述运算符 |
| 事件     | 事件是类的成员，在发生某些行为（如修改类的字段或属性，或者进行了某种形式的用户交互操作）时，它可以让对象通知调用方。客户可以包含所谓“事件处理程序”的代码来响应该事件。第9章将详细介绍事件 |
| 析构函数 | 析构函数或终结器的语法类似于构造函数的语法，但是在CLR检测到不再需要某个对象时调用它。它们的名称与类相同，但前面有一个“～”符号。不可能预测什么时候调用终结器。终结器详见第5章 |
| 类型     | 类可以包含内部类。如果内部类型只和外部类型结合使用，就很有趣 |

## 2.1 属性

属性（property）的概念是：它是一个方法或一对方法，在客户端代码看来，它（们）是一个字段。

1．自动实现的属性 如果属性的set和get访问器中没有任何逻辑，就可以使用自动实现的属性。这种属性会自动实现后备成员变量。

示例的代码如下： 

```C#
public int Age { get; set; }
```

这种方法后备成员变量就不知道是啥名。

自动实现的属性可以使用属性初始化器来初始化：示例代码如下：

```C#
public int Age { get; set; } = 42;
```

2．属性的访问修饰符 C#允许给属性的get和set访问器设置不同的访问修饰符，所以属性可以有公有的get访问器和私有或受保护的set访问器。

```C#
public string Name { get { return _name; } private set { _name = value; } } 
```

通过自动实现的属性，也可以设置不同的访问级别： 

```C#
public int Age { get; private set; }
```

**Note:属性默认的访问属性就是public，因此不能用public修饰，并且两个不能同时不为public访问属性，否则会编译报错**

## 2.2 方法

注意，正式的C#术语区分函数和方法。在C#术语中，“函数成员”不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数和析构函数等，甚至还有属性。这些都不是数据成员，字段、常量和事件才是数据成员。
2．表达式体方法

方法声明：

```C#
[modifiers] return_type MethodName([parameters]) { // Method body }
```

2．表达式体方法

如果方法的实现只有一个语句，C# 6为方法定义提供了一个简化的语法：表达式体方法。使用新的语法，不需要编写花括号和return关键字，而使用运算符= >（lambda操作符）区分操作符左边的声明和操作符右边的实现代码。

```C#
public bool IsSquare(Rectangle rect) => rect.Height == rect.Width;
```

4．方法的重载 C#支持方法的重载——方法的几个版本有不同的签名（即，方法名相同，但参数的个数和/或数据类型不同）。为了重载方法，只需要声明同名但参数个数或类型不同的方法即可。

6．可选参数，参数也可以是可选的。必须为可选参数提供默认值。可选参数还必须是方法定义的最后的参数。

```C#
public void TestMethod(int notOptionalNumber, int optionalNumber = 42) { WriteLine(optionalNumber + notOptionalNumber); }
```

通过多个可选参数，命名参数的特性就会发挥作用。使用命名参数，可以传递任何可选参数，例如，下面的例子仅传递最后一个参数： 

```C#
public void TestMethod(int n, int opt1 = 11 , int opt2 = 22 , int opt3 = 33 ) { WriteLine(n + opt1 + opt2 + opt3); }
TestMethod(1, opt3: 4);
```

7．个数可变的参数 使用可选参数，可以定义数量可变的参数。然而，还有另一种语法允许传递数量可变的参数——这个语法没有版本控制问题。 声明数组类型的参数（示例代码使用一个int数组），添加params关键字，就可以使用任意数量的int参数调用该方法。 

```C#
public void AnyNumberOfArguments(params int[] data) { foreach (var x in data) { WriteLine(x); } }
```

**如果params关键字与方法签名定义的多个参数一起使用，则params只能使用一次，而且它必须是最后一个参数**



## 2.3 构造函数

没有必要给类提供构造函数，到目前为止本书的例子中没有提供这样的构造函数。一般情况下，如果没有提供任何构造函数，编译器会在后台生成一个默认的构造函数。**<u>*这是一个非常基本的构造函数，它只能把所有的成员字段初始化为标准的默认值（例如，引用类型为空引用，数值数据类型为0, bool为false）。这通常就足够了，否则就需要编写自己的构造函数。*</u>** 

**<u>*但是，如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数。只有在没有定义任何构造函数时，编译器才会自动提供默认的构造函数。*</u>**

构造函数的重载遵循与其他方法相同的规则。换言之，可以为构造函数提供任意多的重载，只要它们的签名有明显的区别即可。

● 类仅用作某些静态成员或属性的容器，因此永远不会实例化它。在这种情况下，可以用static修饰符声明类。使用这个修饰符，类只能包含静态成员，不能实例化。 
● 希望类仅通过调用某个静态成员函数来实例化（这就是所谓对象实例化的类工厂方法）。单例模式的实现如下面的代码片段所示：

```C#
public class Singleton { 
    private static Singleton s_instance; 
    private int _state; private Singleton(int state) { _state = state; } 
    public static Singleton Instance { get { return s_instance ? ? (s_instance = new MySingleton(42); } } 
}
```

**<u>*类中的数据成员即便不在定义的构造函数里初始化，也会变初始化标准的默认值（例如，引用类型为空引用，数值数据类型为0, bool为false）*</u>**

### 2.3.1 从构造函数中调用其他构造函数

省事

```C#
class Car { 
    private string _description; 
    private uint _nWheels; 
    public Car(string description, uint nWheels) { 
        _description = description;
        _nWheels = nWheels; 
    } 
    public Car(string description) { 
        _description = description; 
        _nWheels = 4; 
    } // etc.
}
//优化如下
class Car { 
    private string _description; 
    private uint _nWheels; 
    public Car(string description, uint nWheels) { 
        _description = description; 
        _nWheels = nWheels; 
    } 
    public Car(string description): this (description, 4) { } // etc
}
```

### 2.3.2 静态构造函数

**<u>*C#的一个新特征是也可以给类编写无参数的静态构造函数。这种构造函数只执行一次，而前面的构造函数是实例构造函数，只要创建类的对象，就会执行它。*</u>**

编写静态构造函数的一个原因是，类有一些静态字段或属性，需要在第一次使用类之前，从外部源中初始化这些静态字段和属性。

<u>*.NET运行库没有确保什么时候执行静态构造函数，所以不应把要求在某个特定时刻（例如，加载程序集时）执行的代码放在静态构造函数中。也不能预计不同类的静态构造函数按照什么顺序执行。但是，可以确保静态构造函数至多运行一次，即在代码引用类之前调用它。**在C#中，通常在第一次调用类的任何成员之前执行静态构造函数**。*</u>



<u>***注意，静态构造函数没有访问修饰符，其他C#代码从来不显式调用它，但在加载类时，总是由.NET运行库调用它，所以像public或private这样的访问修饰符就没有任何意义。出于同样原因，静态构造函数不能带任何参数，一个类也只能有一个静态构造函数。很显然，静态构造函数只能访问类的静态成员，不能访问类的实例成员。***</u>

### 2.3.3 只读成员

如果不希望在初始化后修改数据成员，就可以使用readonly关键字。下面详细描述只读字段和只读属性。

#### 只读字段

为了保证对象的字段不能改变，字段可以用readonly修饰符声明。**<u>*带有readonly修饰符的字段只能在构造函数中分配值。*</u>**
**<u>*它与const修饰符不同。编译器通过const修饰符，用其值取代了使用它的变量。编译器知道常量的值。只读字段在运行期间通过构造函数指定。*</u>*****<u>与常量字段相反，只读字段可以是实例成员。使用只读字段作为类成员时，需要把static修饰符分配给该字段。</u>***

NOTE:还要注意，在构造函数中不必给只读字段赋值。如果没有赋值，它的值就是其特定数据类型的默认值，或者在声明时给它初始化的值。这适用于只读的静态字段和实例字段。即便是正常的字段，在.net 6.0的环境下也会被初始化（没有在构造函数中进行初始化）。

#### 只读属性

只读属性:在属性定义中省略set访问器，就可以创建只读属性。因此，如下代码把Name变成只读属性：

```C#
private readonly string _name; public string Name { get { return _name; } } 
```

 用readonly修饰符声明字段，只允许在构造函数中初始化属性的值。 同样，在属性定义中省略get访问器，就可以创建只写属性。**<u>*但是，这是不好的编程方式，因为这可能会使客户端代码的作者感到迷惑。一般情况下，如果要这么做，最好使用一个方法替代。*</u>**

C# 6提供了一个简单的语法，使用自动实现的属性创建只读属性，访问只读字段。这些属性可以使用属性初始化器来初始化。 当然，只读属性也可以在构造函数中初始化。

```C#
public string Id { get; } = Guid.NewGuid().ToString();
```

#### 表达式属性

C# 6中与属性相关的另一个扩展是表达式体属性。类似于表达式体方法，表达式体属性不需要花括号和返回语句。表达式体属性是带有get访问器的属性，但不需要编写get关键字。只是get访问器的实现后跟lambda操作符。对于Person类，FullName属性使用表达式体属性实现，通过该属性返回FirstName和LastName属性值的组合：

```C#
public class Person { 
    public Person(string firstName, string lastName) { 
        FirstName = firstName; 
        LastName = lastName; 
    } 
    public string FirstName { get; } 
    public string LastName { get; } 
    public string FullName => $"{FirstName} {LastName}"; 
}
```

#### 不可变的类型

**<u>*如果类型包含可以改变的成员，它就是一个可变的类型。使用readonly修饰符，编译器会在状态改变时报错。状态只能在构造函数中初始化。如果对象没有任何可以改变的成员，只有只读成员，它就是一个不可变类型。其内容只能在初始化时设置。这对于多线程是非常有用的，因为多个线程可以访问信息永远不会改变的同一个对象。因为内容不能改变，所以不需要同步。*</u>**



## 2.4 匿名类型

var关键字，它用于表示隐式类型化的变量。var与new关键字一起使用时，可以创建匿名类型。匿名类型只是一个继承自Object且没有名称的类。**<u>该类的定义从初始化器中推断，类似于隐式类型化的变量。</u>**

如果所设置的值来自于另一个对象，就可以简化初始化器。如果已经有一个包含FirstName、MiddleName和LastName属性的类，且有该类的一个实例（person）, captain对象就可以初始化为： 

```C#
var captain = new { person.FirstName, person.MiddleName, person.LastName }; 
```

person对象的属性名应投射到新对象名captain，所以captain对象应有FirstName、MiddleName和LastName属性。

**<u>*这些新对象的类型名未知。编译器为类型“伪造”了一个名称，但只有编译器才能使用它。我们不能也不应使用新对象上的任何类型反射，因为这不会得到一致的结果。*</u>**

## 2.5 结构



结构是值类型，不是引用类型。**<u>*它们存储在栈中或存储为内联（如果它们是存储在堆中的另一个对象的一部分）*</u>**，其生存期的限制与简单的数据类型一样。 

● 结构不支持继承。 
● 对于结构，构造函数的工作方式有一些区别。如果没有提供默认的构造函数，编译器会自动提供一个，把成员初始化为其默认值。 
● 使用结构，可以指定字段如何在内存中布局



因为结构实际上是把数据项组合在一起，所以有时大多数或者全部字段都声明为public。**<u>*严格来说，这与编写.NET代码的规则相反——根据Microsoft，字段（除了const字段之外）应总是私有的，并由公有属性封装。*</u>**但是，对于简单的结构，许多开发人员都认为公有字段是可接受的编程方式。


### 2.5.1 结构是值类型

注意，因为结构是值类型，所以new运算符与类和其他引用类型的工作方式不同。**<u>*new运算符并不分配堆中的内存，而是只调用相应的构造函数，根据传送给它的参数，初始化所有的字段*</u>**。对于结构，可以编写下述完全合法的代码：

```C#
Dimensions point; 
point.Length = 3; 
point.Width = 6; 
```

**<u>*结构遵循其他数据类型都遵循的规则：在使用前所有的元素都必须进行初始化。*</u>**在结构上调用new运算符，或者给所有的字段分别赋值，结构就完全初始化了。当然，如果结构定义为类的成员字段，在初始化包含的对象时，该结构会自动初始化为0。

<u>***NOTE:在net6.0环境下，这种代码无法通过编译，最好还是先初始化对象再进行使用。***</u>

结构不是为继承设计的。这意味着：**<u>*它不能从一个结构中继承。唯一的例外是对应的结构（和C#中的其他类型一样）最终派生于类System.Object。因此，结构也可以访问System.Object的方法。在结构中，甚至可以重写System.Object中的方法——如重写ToString（）方法。结构的继承链是：每个结构派生自System.ValueType类，System.ValueType类又派生自System.Object。ValueType并没有给Object添加任何新成员，但提供了一些更适合结构的实现方式。注意，不能为结构提供其他基类：每个结构都派生自ValueType。*</u>** 

为结构定义构造函数的方式与为类定义构造函数的方式相同。 前面说过，默认构造函数把数值字段都初始化为0，且总是隐式地给出，即使提供了其他带参数的构造函数，也是如此。

## 2.6 按值和引用传递参数

结构按值传递，通过按值传递。类按引用传递。

```C#
public struct Dimensions { 
    public double Length { get; set; }
    public double Width { get; set; } 
    public Dimensions(double length, double width) { Length = length; Width = width; } 
    //表达式属性,返回了Math.Sqrt(Length * Length + Width * Width)
    public double Diagonal => Math.Sqrt(Length * Length + Width * Width); 
}
public class Dimensions1 { 
    public double Length { get; set; }
    public double Width { get; set; } 
    public Dimensions1(double length, double width) { Length = length; Width = width; } 
    //表达式属性,返回了Math.Sqrt(Length * Length + Width * Width)
    public double Diagonal => Math.Sqrt(Length * Length + Width * Width); 
}
public static void ChangeValue(Dimensions a){
    a.Length = 100;
}
public static void ChangeValue(Dimensions1 a){
    a.Length = 100;
}
Dimensions d1 = new Dimensions(10,10);
Dimensions1 d2 = new Dimensions1(0,0);
//d1为结构体，d2为类，d1为值传递，d2为引用传递
ChangeValue(d1);
ChangeValue(d2);
Console.WriteLine($"d1.Length:{d1.Length}");
Console.WriteLine($"d2.Length:{d2.Length}");
//输出
//d1.Length:10
//d2.Length:100
```

### 2.6.1 ref参数

也可以通过引用传递结构。如果A是结构类型，就添加ref修饰符，方法的声明，通过引用传递变量。在调用方法时需要添加它。

对于引用类型，如果要在函数中创建新对象并更改原先的引用，需要添加ref修饰符。

```C#
 public static void ChangeValue(Dimensions1 a){
     a.Length = 100;
     a = new Dimensions1(1001,1001);
 }
public static void ChangeValue(ref Dimensions1 a){
    a.Length = 1000;
    a = new Dimensions1(10000,10000);
}
```

### 2.6.2　out参数

如果方法返回一个值，该方法通常声明返回类型，并返回结果。<u>如果方法返回多个值，可能类型还不同，该怎么办？</u>这有不同的选项。**<u>*一个选项是声明类和结构，把应该返回的所有信息都定义为该类型的成员。另一个选项是使用元组类型。第三个选项是使用out关键字。*</u>**

使用out参数，变量不需要预先初始化，变量在方法中初始化。类似于ref关键字，out关键字也需要在调用方法时提供，而不仅仅在声明方法时提供。

使用示例：

```C#
string input2 = Console.ReadLine(); 
int result; 
if (int.TryParse(input2, out result) ) 
{ 
    Console.WriteLine($"n: {result}"); 
} 
else 
{ 
    Console.WriteLine("not a number"); 
}
```

## 2.7 可空类型

可空类型是可以为空的值类型。可空类型只需要在类型的后面添加“？”（它必须是结构）。与基本结构相比，值类型唯一的开销是一个可以确定它是否为空的布尔成员。（勘误，应该是可空类型的唯一开销）。

**对于可空类型，可以使用能用于基本类型的所有可用操作符，例如，可用于int？的+、-、*、/等。每个结构类型都可以使用可空类型，而不仅是预定义的C#类型。**

## 2.8 枚举类型

枚举是一个值类型，包含一组命名的常量，如这里的Color类型。枚举类型用enum关键字定义

```C#
 public enum Color { Red, Green, Blue }
```

默认情况下，enum的类型是int。这个基本类型可以改为其他整数类型（byte、short、int、带符号的long和无符号变量）。命名常量的值从0开始递增，但它们可以改为其他值：

```C#
public enum Color : short { Red = 1, Green = 2, Blue = 3 }
```

使用强制类型转换可以把数字改为枚举值，把枚举值改为数字。(不使用强制类型转换可以转换嘛？无法隐式转换，必须强制类型转换)



**<u>*还可以使用enum类型把多个选项分配给一个变量，而不仅仅是一个枚举常量。为此，分配给常量的值必须是不同的位，Flags属性需要用枚举设置。*</u>**

```C#
[Flags] public enum DaysOfWeek { 
    Monday = 0x1, Tuesday = 0x2, Wednesday = 0x4, Thursday = 0x8, Friday = 0x10, Saturday = 0x20, Sunday = 0x40 
}
```



设置不同的位，也可以结合单个位来包括多个值，如Weekend的值0x60是用逻辑或运算符结合了Saturday和Sunday。Workday则结合了从Monday到Friday的所有日子，AllWeek用逻辑或运算符结合了Workday和Weekend 

Enum.GetNames方法返回一个包含所有枚举名的字符串数组。

为了获得枚举的所有值，可以使用方法Enum.GetValues。Enum.GetValues返回枚举值的一个数组。为了获得整数值，需要把它转换为枚举的底层类型。

## 2.9 部分类

partial关键字允许把类、结构、方法或接口放在多个文件中。一般情况下，某种类型的代码生成器生成了一个类的某部分，所以把类放在多个文件中是有益的。假定要给类添加一些从工具中自动生成的内容。如果重新运行该工具，前面所做的修改就会丢失。partial关键字有助于把类分开放在两个文件中，而对不由代码生成器定义的文件进行修改。

## 2.10 扩展方法

有许多扩展类的方式。继承就是给对象添加功能的好方法。扩展方法是给对象添加功能的另一个选项，在不能使用继承时，也可以使用这个选项（例如类是密封的）。扩展方法是静态方法，它是类的一部分，但实际上没有放在类的源代码中。

示例：

```C#
public static class StringExtension { 
    public static int GetWordCount(this string s) => s.Split().Length; 
}
```

**<u>*使用this关键字和第一个参数来扩展字符串。这个关键字定义了要扩展的类型。*</u>**

使用：

```C#
string fox = "the quick brown fox jumped over the lazy dogs down " + "9876543210 times"; 
int wordCount = fox.GetWordCount(); 
WriteLine($"{wordCount} words");
```

**<u>*编译器如何找到某个类型的扩展方法？this关键字必须匹配类型的扩展方法，而且需要打开定义扩展方法的静态类所在的名称空间。如果把StringExtensions类放在名称空间Wrox. Extensions中，则只有用using指令打开Wrox.Extensions，编译器才能找到GetWordCount方法。如果类型还定义了同名的实例方法，扩展方法就永远不会使用。类中已有的任何实例方法都优先。当多个同名的扩展方法扩展相同的类型，打开所有这些类型的名称空间时，编译器会产生一个错误，指出调用是模棱两可的，它不能决定在多个实现代码中选择哪个。然而，如果调用代码在一个名称空间中，这个名称空间就优先。*</u>**

## 2.11 Object类

**<u>*前面提到，所有的.NET类最终都派生自System.Object。实际上，如果在定义类时没有指定基类，编译器就会自动假定这个类派生自Object。本章没有使用继承，所以前面介绍的每个类都派生自System.Object（如前所述，对于结构，这个派生是间接的：结构总是派生自System.ValueType, System.ValueType又派生自System.Object）。*</u>**

其实际意义在于，除了自己定义的方法和属性等外，还可以访问为Object类定义的许多公有的和受保护的成员方法。这些方法可用于自己定义的所有其他类中。 下面将简要总结每个方法的作用：

● ToString（）方法： 是获取对象的字符串表示的一种便捷方式。当只需要快速获取对象的内容，以进行调试时，就可以使用这个方法。在数据的格式化方面，它几乎没有提供选择：例如，在原则上日期可以表示为许多不同的格式，但DateTime.ToString（）没有在这方面提供任何选择。如果需要更复杂的字符串表示，例如，考虑用户的格式化首选项或区域性，就应实现IFormattable接口。

 ● GetHashCode（）方法： 如果对象放在名为映射（也称为散列表或字典）的数据结构中，就可以使用这个方法。处理这些结构的类使用该方法确定把对象放在结构的什么地方。如果希望把类用作字典的一个键，就需要重写GetHashCode（）方法。实现该方法重载的方式有一些相当严格的限制，这些将在第11章介绍字典时讨论。 

● Equals（）（两个版本）和ReferenceEquals（）方法： 注意有3个用于比较对象相等性的不同方法，这说明.NET Framework在比较相等性方面有相当复杂的模式。这3个方法和比较运算符“==”在使用方式上有微妙的区别。而且，在重写带一个参数的虚Equals（）方法时也有一些限制，因为System.Collections名称空间中的一些基类要调用该方法，并希望它以特定的方式执行。第8章在介绍运算符时将探讨这些方法的使用。 

● Finalize（）方法： 第5章将介绍这个方法，**<u>*它最接近C++风格的析构函数*</u>**，在引用对象作为垃圾被回收以清理资源时调用它。Object中实现的Finalize（）方法实际上什么也没有做，因而被垃圾回收器忽略。如果对象拥有对未托管资源的引用，则在该对象被删除时，就需要删除这些引用，此时一般要重写Finalize（）。垃圾收集器不能直接删除这些对未托管资源的引用，因为它只负责托管的资源，于是它只能依赖用户提供的Finalize（）。 

● GetType（）方法： 这个方法返回从System.Type派生的类的一个实例，因此可以提供对象成员所属类的更多信息，包括基本类型、方法、属性等。System.Type还提供了.NET的反射技术的入口点。这个主题详见第16章。

● MemberwiseClone（）方法： 这是System.Object中唯一没有在本书的其他地方详细论述的方法。不需要讨论这个方法，因为它在概念上相当简单，它只复制对象，并返回对副本的一个引用（对于值类型，就是一个装箱的引用）。**<u>*注意，得到的副本是一个浅表复制，即它复制了类中的所有值类型。如果类包含内嵌的引用，就只复制引用，而不复制引用的对象。这个方法是受保护的，所以不能用于复制外部的对象。该方法不是虚方法，所以不能重写它的实现代码。*</u>**
注：在调用类的静态成员时，便会先调用类的静态构造函数

# 3. 继承

## 3.1 C#支持的面向对象特性

● 单重继承： 表示一个类可以派生自一个基类。C#就采用这种继承。 
● 多重继承： 多重继承允许一个类派生自多个类。**<u>*C#不支持类的多重继承，但允许接口的多重继承。*</u>** 
● 多层继承： **<u>*多层继承允许继承有更大的层次结构*</u>**。类B派生自类A，类C又派生自类B。 其中，类B也称为中间基类，C#支持它，也很常用。 
● 接口继承： 定义了接口的继承。这里允许多重继承。接口和接口继承参见本章后面的“接口”一节。

**<u>*对于实现继承，多重继承会给生成的代码增加复杂性，还会带来一些开销。因此，C#的设计人员决定不支持类的多重继承。*</u>**

使用结构的一个限制是结构不支持继承，但每个结构都自动派生自System.ValueType。不能编码实现结构的类型层次，但结构可以实现接口。换言之，结构并不支持实现继承，但支持接口继承。定义的结构和类可以总结为： 
● 结构总是派生自System.ValueType，它们还可以派生自任意多个接口。 
● 类总是派生自System.Object或用户选择的另一个类，它们还可以派生自任意多个接口。

## 3.2 继承实现

如果要声明派生自另一个类的一个类，就可以使用下面的语法：

```C#
class MyDerivedClass: MyBaseClass { // members }
```

  如果类（或结构）也派生自接口，则用逗号分隔列表中的基类和接口： 

```C#
public class MyDerivedClass: MyBaseClass, IInterface1, IInterface2 { // members }
```

　**<u>*如果类和接口都用于派生，则类总是必须放在接口的前面。*</u>**

### 3.2.1 虚函数



把一个基类方法声明为virtual，就可以在任何派生类中重写该方法：

重写基类的方法时，签名（所有参数类型和方法名）和返回类型必须完全匹配。否则，以后创建的新成员就不覆盖基类成员。

**<u>*C#中虚函数的概念与标准OOP的概念相同：可以在派生类中重写虚函数。在调用方法时，会调用该类对象的合适方法。在C#中，函数在默认情况下不是虚拟的，但（除了构造函数以外）可以显式地声明为virtual。这遵循C++的方式，即从性能的角度来看，除非显式指定，否则函数就不是虚拟的。而在Java中，所有的函数都是虚拟的。但C#的语法与C++的语法不同，因为C#要求在派生类的函数重写另一个函数时，要使用override关键字显式声明。*</u>**

重写方法的语法避免了C++中很容易发生的潜在运行错误：当派生类的方法签名无意中与基类版本略有差别时，该方法就不能重写基类的方法。在C#中，这会出现一个编译错误，因为编译器会认为函数已标记为override，但没有重写其基类的方法。

### 3.2.2 多态性

使用多态性，可以动态地定义调用的方法，而不是在编译期间定义。编译器创建一个虚拟方法表（vtable），其中列出了可以在运行期间调用的方法，它根据运行期间的类型调用方法。(动态绑定)

### 3.2.3 隐藏方法

如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有分别声明为virtual和override，派生类方法就会隐藏基类方法。在**<u>*大多数情况下，是要重写方法，而不是隐藏方法，因为隐藏方法会造成对于给定类的实例调用错误方法的危险。*</u>**但是，如下面的例子所示，C#语法可以确保开发人员在编译时收到这个潜在错误的警告，从而使隐藏方法（如果这确实是用户的本意）更加安全。这也是类库开发人员得到的版本方面的好处。

*<u>**注意： new方法修饰符不应该故意用于隐藏基类的成员。这个修饰符的主要目的是处理版本冲突，在修改派生类后，响应基类的变化。**</u>*

### 3.2.4 访问方法的基类版本

C#有一种特殊的语法用于从派生类中调用方法的基类版本：

```C#
base.<MethodName>()
```

*<u>**注意： 使用base关键字，可以调用基类的任何方法——而不仅仅是已重写的方法。**</u>*

### 3.2.5 抽象类与抽象方法

**<u>*C#允许把类和方法声明为abstract。抽象类不能实例化，而抽象方法不能直接实现，必须在非抽象的派生类中重写。显然，抽象方法本身也是虚拟的（尽管也不需要提供virtual关键字，实际上，如果提供了该关键字，就会产生一个语法错误）。如果类包含抽象方法，则该类也是抽象的，也必须声明为抽象的*</u>**。

**<u>*从抽象基类中派生类型时，需要实现所有抽象成员。否则，编译器会报错*</u>**

抽象类不能实例化，但是其派生类可以实例化赋值给抽象类变量。

### 3.2.6 密封类与密封方法

如果不应创建派生自某个自定义类的类，该自定义类就应密封。给类添加sealed修饰符，就不允许创建该类的子类。密封一个方法，表示不能重写该方法。



**<u>*要在方法或属性上使用sealed关键字，必须先从基类上把它声明为要重写的方法或属性。如果基类上不希望有重写的方法或属性，就不要把它声明为virtual。*</u>**

### 3.2.7 派生类的构造函数

**<u>*构造函数总是按照层次结构的顺序调用：先调用System.Object类的构造函数，再按照层次结构由上向下进行，直到到达编译器要实例化的类为止。为了实例化Ellipse类型，先调用Object构造函数，再调用Shape构造函数，最后调用Ellipse构造函数。这些构造函数都处理它自己类中字段的初始化。*</u>**

**<u>*当删除默认构造函数，重新编译程序时，不能编译Ellipse和Rectangle类，因为编译器不知道应该把什么值传递给基类唯一的非默认值构造函数。这里需要在派生类中创建一个构造函数，用构造函数初始化器初始化基类构造函数。*</u>**

编译给的不够看，写不正确会报错。注意保证每个层都初始化到就行。

## 3.3 修饰符

| 修饰符            |   应用于   |   说明    |
| ---------------------------- | ---- | ---- |
| public | 所有类型或成员 | 任何代码均可以访问该项 |
| protected | 类型和内嵌类型的所有成员 | 只有派生的类型能访问该项 |
| internal | 所有类型或成员 | 只能在包含它的程序集中访问该项 |
| private | 类型和内嵌类型的所有成员 | 只能在它所属的类型中访问该项 |
| protected internal | 类型和内嵌类型的所有成员 | 只能在包含它的程序集和派生类型的任何代码中访问该项 |
|                              |      |      |

<u>***注意： public、protected和private是逻辑访问修饰符。internal是一个物理访问修饰符，其边界是一个程序集。***</u>

不能把类型定义为protected、private或protected internal，因为这些修饰符对于包含在名称空间中的类型没有意义。因此这些修饰符只能应用于成员。但是，可以用这些修饰符定义嵌套的类型（即，包含在其他类型中的类型），因为在这种情况下，类型也具有成员的状态。于是，下面的代码是合法的：

```C#
public class OuterClass { 
    protected class InnerClass { 
        // etc. 
    } 
    // etc. 
}
```

3.3.1 其他修饰符


| 修饰符            |   应用于   |   说明    |
| ---------------------------- | ---- | ---- |
| new  | 函数成员 | 成员用相同的签名隐藏继承的成员 |
| static | 所有成员 | 成员不作用于类的具体实例，也称为类成员，而不是实例成员 |
| virtual | 仅函数成员 | 成员可以由派生类重写 |
| abstract | 仅函数成员 | 成员重写了继承的虚拟或抽象成员 |
| override | 仅函数成员 | 成员重写了继承的虚拟或抽象成员 |
| sealed | 类、方法和属性 |   对于类，不能继承自密封类。对于属性和方法，成员重写已继承的虚拟成员，但任何派生类中的任何成员都不能重写该成员。该修饰符必须与override一起使用   |
| extern |    仅静态[DllImport]方法    |   成员在外部用另一种语言实现。这个关键字的用法参见第5章   |

## 3.4 接口

**<u>*声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的实现方式。一般情况下，接口只能包含方法、属性、索引器和事件的声明。*</u>**

**<u>*类似于抽象类，永远不能实例化接口，它只能包含其成员的签名。此外，可以声明接口类型的变量。*</u>**

**<u>*在接口定义中还不允许声明成员的修饰符。接口成员总是隐式为public，不能声明为virtual。如果需要，就应由实现的类来声明，因此最好实现类来声明访问修饰符。*</u>**

### 3.4.1 定义与实现接口，继承

示例：

```C#
public interface IBankAccount { 
    void PayIn(decimal amount); 
    bool Withdraw(decimal amount); 
    decimal Balance { get; } 
}
```

接口可以彼此继承，其方式与类的继承方式相同。

## 3.5 is和as运算符

as运算符的工作原理类似于类层次结构中的cast运算符——它返回对象的引用。然而，它从不抛出InvalidCastException异常。相反，如果对象不是所要求的类型，这个运算符就返回null。这里，最好在使用引用前验证它是否为空，否则以后使用以下引用，就会抛出NullReferenceException异常。

除了使用as运算符之外，还可以使用is运算符。is运算符根据条件是否满足，对象是否使用指定的类型，返回true或false。

