# C#运行环境

## 什么是.net(dotnet)?

全称应该为.net framework。.NET框架是一个多语言组件开发和执行环境，它提供了一个跨语言的统一编程环境。.NET框架又包括三个主要组成部分：公共语言运行库（CLR：Common Language Runtime）、[服务框架](https://baike.baidu.com/item/服务框架)（Services Framework）和上层的两类应用模板——传统的Windows应用程序模板（Win Forms）和基于ASP.NET的面向Web的网络应用程序模板（Web Forms和Web Services）。

.NET FrameWork的核心是其运行库执行环境，称为公共语言运行库(CLR，Common Language Runtime)。

.Net 编程语言的编译器会将代码编译成中间语言（Intermediate Language,IL）代码。IL代码看起来像面向对象的机器码，使用工具ildasm.exe可以打开包含.net代码的dll或exe文件来检查il代码。CLR包含了一个及时（just-in-time,jit)编译器，当程序开始运行时，jit编译器会从il代码生成本地代码。

## .net编程语言的编译过程以及CLR作用？

**在.net中，**
**(1)将源代码编译成mircrosoft中间语言（Intermediate Language,IL）代码。**
**(2)CLR把IL编译为平台专用的本地代码。**
**IL代码在.net程序集中可用。在运行时，jit编译器编译IL代码，创建特定于平台的本地代码。**

**CLR还包括一个带有类型加载器的类型系统，类型加载器负责从程序集中加载类型。CLR的另一个功能是垃圾回收器，垃圾回收器从托管堆中清除不再引用的内存。CLR还负责线程的处理。在C#中创建托管的线程不一定来自底层操作系统。线程的虚拟化和管理由CLR负责。**

# C#语言基础

# 1. 变量

变量声明

```C#
int i;
```

该语句声明int变量i。**实际上编译器不允许在表达式中使用这个变量，除非用一个值初始化了该变量。**
如果在一条语句中声明和初始化了多个变量，那么所有的变量都具有相同的数据类型： 

```C#
int x = 10, y =20; // x and y are both ints 
```

要声明不同类型的变量，需要使用单独的语句。在一条多变量的声明中，不能指定不同的数据类型：

```C#
int x = 10; bool y = true; // Creates a variable that stores true or false int x = 10, bool y = true; // This won't compile!
```

##  1.1 变量的初始化

变量的初始化是C#强调安全性的另一个例子。简单地说，C#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用该变量。**大多数现代编译器把没有初始化标记为警告**，**但C#编译器把它当成错误来看待**。这就可以防止我们无意中从其他程序遗留下来的内存中检索垃圾值。 C#有两个方法可确保变量在使用前进行了初始化：
 ● 变量是类或结构中的字段，如果没有显式初始化，则创建这些变量时，其默认值就是0（类和结构在后面讨论）。
 ● 方法的局部变量必须在代码中显式初始化，之后才能在语句中使用它们的值。此时，初始化不是在声明该变量时进行的，但编译器会通过方法检查所有可能的路径，如果检测到局部变量在初始化之前就使用了其值，就会标记为错误。

## 1.2 类型推断

**类型推断使用var关键字。声明变量的语法有些变化：使用var关键字替代实际的类型。编译器可以根据变量的初始化值“推断”变量的类型。**

 类型推断需要遵从一些规则：
● 变量必须初始化。否则，编译器就没有推断变量类型的依据。
● 初始化器不能为空。 
● 初始化器必须放在表达式中。 
● 不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象。

## 1.3 变量的作用域

变量的作用域是可以访问该变量的代码区域。一般情况下，确定作用域遵循以下规则： 
● 只要类在某个作用域内，其字段（也称为成员变量）也在该作用域内。 
● 局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内。 
● 在for、while或类似语句中声明的局部变量存在于该循环体内。

有两种冲突情况

1.局部作用域内的冲突
大型程序在不同部分为不同的变量使用相同的变量名很常见。只要变量的作用域是程序的不同部分，就不会有问题，也不会产生多义性。但要注意，同名的局部变量不能在同一作用域内声明两次。声明两次会无法通过编译。
2.局部变量与类字段的冲突
某些情况下，可以区分名称相同（尽管其完全限定名不同）、作用域相同的两个标识符。此时编译器允许声明第二个变量。原因是C#在变量之间有一个基本的区分，它把在类型级别声明的变量看成字段，而把在方法中声明的变量看成局部变量。
**<u>但是，如果要引用类级别变量，该怎么办？可以使用语法object.fieldname，在对象的外部引用类或结构的字段。</u>**

## 1.4 常量

顾名思义，常量是其值在使用过程（生命周期）中不会发生变化的变量。在声明和初始化变量时，在变量的前面加上关键字const，就可以把该变量指定为一个常量。
常量具有如下特点：
● 常量必须在声明时初始化。指定了其值后，就不能再改写了。 
● 常量的值必须能在编译时用于计算。因此，不能用从变量中提取的值来初始化常量。如果需要这么做，应使用只读字段（详见第3章）。 
● **常量总是隐式静态的。但注意，不必（实际上，是不允许）在常量声明中包含修饰符static。** 

在程序中使用常量至少有3个好处： 
● 由于使用易于读取的名称（名称的值易于理解）替代了较难读取的数字和字符串，常量使程序变得更易于阅读。 
● 常量使程序更易于修改。例如，在C#程序中有一个SalesTax常量，该常量的值为6%。如果以后销售税率发生变化，把新值赋给这个常量，就可以修改所有的税款计算结果，而不必查找整个程序去修改税率为0.06的每个项。
● 常量更容易避免程序出现错误。如果在声明常量的位置以外的某个地方将另一个值赋给常量，编译器就会标记错误。

## 1.5 预定义数据类型(变量的类型)

两中大的分类：

1.值类型
2.引用类型

从概念上看，其区别是值类型直接存储其值，而引用类型存储对值的引用。
这两种类型存储在内存的不同地方：值类型存储在堆栈（stack）中，而引用类型存储在托管堆（managed heap）上。注意区分某个类型是值类型还是引用类型，因为这会有不同的影响。例如，int是值类型，这表示下面的语句会在内存的两个地方存储值20：

C#把基本类型（如int和bool）规定为值类型，而把包含许多字段的较大类型（通常在有类的情况下）规定为引用类型，C#设计这种方式是为了得到最佳性能。如果要把自己的类型定义为值类型，**就应把它声明为一个结构。**

**大多数更复杂的C#数据类型，包括我们自己声明的类，都是引用类型。它们分配在堆中，其生存期可以跨多个函数调用，可以通过一个或几个别名来访问。CLR实现一种精细的算法，来跟踪哪些引用变量仍是可以访问的，哪些引用变量已经不能访问了。CLR会定期删除不能访问的对象，把它们占用的内存返回给操作系统。这是通过垃圾回收器实现的。**

### 1.5.1 .net类型

数据类型的C#关键字（如int、short和string）从编译器映射到.NET数据类型。例如，在C#中声明一个int类型的数据时，声明的实际上是.NET结构System.Int32的一个实例。这听起来似乎很深奥，但其意义深远：这表示在语法上，可以把所有的基本数据类型看成支持某些方法的类。例如，要把int i转换为string类型，可以编写下面的代码： string s = i.ToString(); **<u>应强调的是，在这种便利语法的背后，类型实际上仍存储为基本类型。</u>**基本类型在概念上用.NET结构表示，所以肯定没有性能损失。 

下面看看C#中定义的内置类型。我们将列出每个类型，以及它们的定义和对应.NET类型的名称。C#有15个预定义类型，其中13个是值类型，两个是引用类型（string和object）。

### 1.5.2 C#类型

具体的定义略，可以参考，**[美] Christian Nagel. C#高级编程(第10版) C# 6 & .NET Core 1.0 (2.4.3). 清华大学出版社.**

**有些C#类型的名称与C++和Java类型一致，但定义不同。例如，在C#中，int总是32位有符号的整数。而在C++中，int是有符号的整数，但其位数取决于平台（在Windows上是32位）。在C#中，所有的数据类型都以与平台无关的方式定义，以备将来从C#和.NET迁移到其他平台上。**

**如果对一个int、uint、long还是ulong类型的整数没有任何显式的声明，则该变量默认为int类型。为了把输入的值指定为其他整数类型，可以在数字后面加上如下字符：**

```C#
uint ui = 1234U; long l = 1234L; ulong ul = 1234UL;
```

**bool值和整数值不能相互隐式转换。如果变量（或函数的返回类型）声明为bool类型，就只能使用值true或false。如果试图使用0表示false，非0值表示true，就会出错。**

**char类型的字面量是用单引号括起来的，如’A'。如果把字符放在双引号中，编译器会把它看成字符串，从而产生错误。**

**<u>*C#有string关键字，转换为.NET类System.String。有了它，像字符串连接和字符串复制这样的操作就很简单了。尽管它为引用类型，string类已实现，其语义遵循一般的、直观的字符串规则。*</u>**

**名称空间的别名**,如下

```C#
using alias = NamespaceName;
```



## 1.6  XML文档

如前所述，除了C风格的注释外，C#还有一个非常出色的功能（本章将讨论这一功能）：根据特定的注释自动创建XML格式的文档说明。这些注释都是单行注释，但都以3条斜杠（///）开头，而不是通常的两条斜杠。在这些注释中，可以把包含类型和类型成员的文档说明的XML标记放在代码中。

编译器可以识别一些格式的注释文档。

## 1.7  C#预处理器指令

**注意： C++开发人员应该知道，在C和C++中预处理器指令非常重要。但是，在C#中，并没有那么多的预处理器指令，它们的使用也不太频繁。C#提供了其他机制来实现许多C++指令的功能，如定制特性。还要注意，C#并没有一个像C++那样的独立预处理器，所谓的预处理器指令实际上是由编译器处理的。尽管如此，C#仍保留了一些预处理器指令名称，因为这些命令会让人觉得就是预处理器。**

# 2. 对象与类型

结构不同于类，因为它们不需要在堆上分配空间（类是引用类型，总是存储在堆（heap）上），而结构是值类型，通常存储在栈（stack）上，另外，结构不支持继承。对于类和结构，都使用关键字new来声明实例：这个关键字创建对象并对其进行初始化。

**类和结构的一个重要区别是，类类型的对象通过引用传递，结构类型的对象按值传递。**

类中的成员说明：

| 成员     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 字段     | 字段是类的数据成员，它是类型的一个变量，该类型是类的一个成员 |
| 方法     | 方法是与特定类相关联的函数                                   |
| 常量     | 常量与类相关（尽管它们没有static修饰符）。编译器使用真实值代替常量 |
| 属性     | 属性是可以从客户端访问的函数组，其访问方式与访问类的公共字段类似。C#为读写类中的属性提供了专用语法，所以不必使用那些名称中嵌有Get或Set的方法。因为属性的这种语法不同于一般函数的语法，所有在客户端代码中，虚拟的对象被当作实际的东西 |
| 构造函数 | 构造函数是在实例化对象时自动调用的特殊函数。它们必须与所属的类同名，且不能有返回类型。构造函数用于初始化字段的值 |
| 索引器   | 索引器允许对象用访问数组的方式访问。索引器参见第8章          |
| 运算符   | 运算符执行的最简单的操作就是加法和减法。在两个整数相加时，严格地说，就是对整数使用“+”运算符。C#还允许指定把已有的运算符应用于自己的类（运算符重载）。第8章将详细论述运算符 |
| 事件     | 事件是类的成员，在发生某些行为（如修改类的字段或属性，或者进行了某种形式的用户交互操作）时，它可以让对象通知调用方。客户可以包含所谓“事件处理程序”的代码来响应该事件。第9章将详细介绍事件 |
| 析构函数 | 析构函数或终结器的语法类似于构造函数的语法，但是在CLR检测到不再需要某个对象时调用它。它们的名称与类相同，但前面有一个“～”符号。不可能预测什么时候调用终结器。终结器详见第5章 |
| 类型     | 类可以包含内部类。如果内部类型只和外部类型结合使用，就很有趣 |

## 2.1 属性

属性（property）的概念是：它是一个方法或一对方法，在客户端代码看来，它（们）是一个字段。

1．自动实现的属性 如果属性的set和get访问器中没有任何逻辑，就可以使用自动实现的属性。这种属性会自动实现后备成员变量。

示例的代码如下： 

```C#
public int Age { get; set; }
```

这种方法后备成员变量就不知道是啥名。

自动实现的属性可以使用属性初始化器来初始化：示例代码如下：

```C#
public int Age { get; set; } = 42;
```

2．属性的访问修饰符 C#允许给属性的get和set访问器设置不同的访问修饰符，所以属性可以有公有的get访问器和私有或受保护的set访问器。

```C#
public string Name { get { return _name; } private set { _name = value; } } 
```

通过自动实现的属性，也可以设置不同的访问级别： 

```C#
public int Age { get; private set; }
```

**Note:属性默认的访问属性就是public，因此不能用public修饰，并且两个不能同时不为public访问属性，否则会编译报错**

## 2.2 方法

注意，正式的C#术语区分函数和方法。在C#术语中，“函数成员”不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数和析构函数等，甚至还有属性。这些都不是数据成员，字段、常量和事件才是数据成员。
2．表达式体方法

方法声明：

```C#
[modifiers] return_type MethodName([parameters]) { // Method body }
```

2．表达式体方法

如果方法的实现只有一个语句，C# 6为方法定义提供了一个简化的语法：表达式体方法。使用新的语法，不需要编写花括号和return关键字，而使用运算符= >（lambda操作符）区分操作符左边的声明和操作符右边的实现代码。

```C#
public bool IsSquare(Rectangle rect) => rect.Height == rect.Width;
```

4．方法的重载 C#支持方法的重载——方法的几个版本有不同的签名（即，方法名相同，但参数的个数和/或数据类型不同）。为了重载方法，只需要声明同名但参数个数或类型不同的方法即可。

6．可选参数，参数也可以是可选的。必须为可选参数提供默认值。可选参数还必须是方法定义的最后的参数。

```C#
public void TestMethod(int notOptionalNumber, int optionalNumber = 42) { WriteLine(optionalNumber + notOptionalNumber); }
```

通过多个可选参数，命名参数的特性就会发挥作用。使用命名参数，可以传递任何可选参数，例如，下面的例子仅传递最后一个参数： 

```C#
public void TestMethod(int n, int opt1 = 11 , int opt2 = 22 , int opt3 = 33 ) { WriteLine(n + opt1 + opt2 + opt3); }
TestMethod(1, opt3: 4);
```

7．个数可变的参数 使用可选参数，可以定义数量可变的参数。然而，还有另一种语法允许传递数量可变的参数——这个语法没有版本控制问题。 声明数组类型的参数（示例代码使用一个int数组），添加params关键字，就可以使用任意数量的int参数调用该方法。 

```C#
public void AnyNumberOfArguments(params int[] data) { foreach (var x in data) { WriteLine(x); } }
```

**如果params关键字与方法签名定义的多个参数一起使用，则params只能使用一次，而且它必须是最后一个参数**



## 2.3 构造函数

没有必要给类提供构造函数，到目前为止本书的例子中没有提供这样的构造函数。一般情况下，如果没有提供任何构造函数，编译器会在后台生成一个默认的构造函数。**<u>*这是一个非常基本的构造函数，它只能把所有的成员字段初始化为标准的默认值（例如，引用类型为空引用，数值数据类型为0, bool为false）。这通常就足够了，否则就需要编写自己的构造函数。*</u>** 

**<u>*但是，如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数。只有在没有定义任何构造函数时，编译器才会自动提供默认的构造函数。*</u>**

构造函数的重载遵循与其他方法相同的规则。换言之，可以为构造函数提供任意多的重载，只要它们的签名有明显的区别即可。

● 类仅用作某些静态成员或属性的容器，因此永远不会实例化它。在这种情况下，可以用static修饰符声明类。使用这个修饰符，类只能包含静态成员，不能实例化。 
● 希望类仅通过调用某个静态成员函数来实例化（这就是所谓对象实例化的类工厂方法）。单例模式的实现如下面的代码片段所示：

```C#
public class Singleton { 
    private static Singleton s_instance; 
    private int _state; private Singleton(int state) { _state = state; } 
    public static Singleton Instance { get { return s_instance ? ? (s_instance = new MySingleton(42); } } 
}
```

**<u>*类中的数据成员即便不在定义的构造函数里初始化，也会变初始化标准的默认值（例如，引用类型为空引用，数值数据类型为0, bool为false）*</u>**

### 2.3.1 从构造函数中调用其他构造函数

省事

```C#
class Car { 
    private string _description; 
    private uint _nWheels; 
    public Car(string description, uint nWheels) { 
        _description = description;
        _nWheels = nWheels; 
    } 
    public Car(string description) { 
        _description = description; 
        _nWheels = 4; 
    } // etc.
}
//优化如下
class Car { 
    private string _description; 
    private uint _nWheels; 
    public Car(string description, uint nWheels) { 
        _description = description; 
        _nWheels = nWheels; 
    } 
    public Car(string description): this (description, 4) { } // etc
}
```

### 2.3.2 静态构造函数

**<u>*C#的一个新特征是也可以给类编写无参数的静态构造函数。这种构造函数只执行一次，而前面的构造函数是实例构造函数，只要创建类的对象，就会执行它。*</u>**

编写静态构造函数的一个原因是，类有一些静态字段或属性，需要在第一次使用类之前，从外部源中初始化这些静态字段和属性。

**<u>*.NET运行库没有确保什么时候执行静态构造函数，所以不应把要求在某个特定时刻（例如，加载程序集时）执行的代码放在静态构造函数中。也不能预计不同类的静态构造函数按照什么顺序执行。但是，可以确保静态构造函数至多运行一次，即在代码引用类之前调用它。在C#中，通常在第一次调用类的任何成员之前执行静态构造函数。*</u>**



<u>***注意，静态构造函数没有访问修饰符，其他C#代码从来不显式调用它，但在加载类时，总是由.NET运行库调用它，所以像public或private这样的访问修饰符就没有任何意义。出于同样原因，静态构造函数不能带任何参数，一个类也只能有一个静态构造函数。很显然，静态构造函数只能访问类的静态成员，不能访问类的实例成员。***</u>

