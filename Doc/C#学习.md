# C#运行环境

## 什么是.net(dotnet)?

全称应该为.net framework。.NET框架是一个多语言组件开发和执行环境，它提供了一个跨语言的统一编程环境。.NET框架又包括三个主要组成部分：公共语言运行库（CLR：Common Language Runtime）、[服务框架](https://baike.baidu.com/item/服务框架)（Services Framework）和上层的两类应用模板——传统的Windows应用程序模板（Win Forms）和基于ASP.NET的面向Web的网络应用程序模板（Web Forms和Web Services）。

.NET FrameWork的核心是其运行库执行环境，称为公共语言运行库(CLR，Common Language Runtime)。

.Net 编程语言的编译器会将代码编译成中间语言（Intermediate Language,IL）代码。IL代码看起来像面向对象的机器码，使用工具ildasm.exe可以打开包含.net代码的dll或exe文件来检查il代码。CLR包含了一个及时（just-in-time,jit)编译器，当程序开始运行时，jit编译器会从il代码生成本地代码。

## .net编程语言的编译过程以及CLR作用？

**在.net中，**
**(1)将源代码编译成mircrosoft中间语言（Intermediate Language,IL）代码。**
**(2)CLR把IL编译为平台专用的本地代码。**
**IL代码在.net程序集中可用。在运行时，jit编译器编译IL代码，创建特定于平台的本地代码。**

**CLR还包括一个带有类型加载器的类型系统，类型加载器负责从程序集中加载类型。CLR的另一个功能是垃圾回收器，垃圾回收器从托管堆中清除不再引用的内存。CLR还负责线程的处理。在C#中创建托管的线程不一定来自底层操作系统。线程的虚拟化和管理由CLR负责。**

# C#语言基础

# 1. 变量

变量声明

```C#
int i;
```

该语句声明int变量i。**实际上编译器不允许在表达式中使用这个变量，除非用一个值初始化了该变量。**
如果在一条语句中声明和初始化了多个变量，那么所有的变量都具有相同的数据类型： 

```C#
int x = 10, y =20; // x and y are both ints 
```

要声明不同类型的变量，需要使用单独的语句。在一条多变量的声明中，不能指定不同的数据类型：

```C#
int x = 10; bool y = true; // Creates a variable that stores true or false int x = 10, bool y = true; // This won't compile!
```

##  1.1 变量的初始化

变量的初始化是C#强调安全性的另一个例子。简单地说，C#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用该变量。**大多数现代编译器把没有初始化标记为警告**，**但C#编译器把它当成错误来看待**。这就可以防止我们无意中从其他程序遗留下来的内存中检索垃圾值。 C#有两个方法可确保变量在使用前进行了初始化：
 ● 变量是类或结构中的字段，如果没有显式初始化，则创建这些变量时，其默认值就是0（类和结构在后面讨论）。
 ● 方法的局部变量必须在代码中显式初始化，之后才能在语句中使用它们的值。此时，初始化不是在声明该变量时进行的，但编译器会通过方法检查所有可能的路径，如果检测到局部变量在初始化之前就使用了其值，就会标记为错误。

## 1.2 类型推断

**类型推断使用var关键字。声明变量的语法有些变化：使用var关键字替代实际的类型。编译器可以根据变量的初始化值“推断”变量的类型。**

 类型推断需要遵从一些规则：
● 变量必须初始化。否则，编译器就没有推断变量类型的依据。
● 初始化器不能为空。 
● 初始化器必须放在表达式中。 
● 不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象。

## 1.3 变量的作用域

变量的作用域是可以访问该变量的代码区域。一般情况下，确定作用域遵循以下规则： 
● 只要类在某个作用域内，其字段（也称为成员变量）也在该作用域内。 
● 局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内。 
● 在for、while或类似语句中声明的局部变量存在于该循环体内。

有两种冲突情况

1.局部作用域内的冲突
大型程序在不同部分为不同的变量使用相同的变量名很常见。只要变量的作用域是程序的不同部分，就不会有问题，也不会产生多义性。但要注意，同名的局部变量不能在同一作用域内声明两次。声明两次会无法通过编译。
2.局部变量与类字段的冲突
某些情况下，可以区分名称相同（尽管其完全限定名不同）、作用域相同的两个标识符。此时编译器允许声明第二个变量。原因是C#在变量之间有一个基本的区分，它把在类型级别声明的变量看成字段，而把在方法中声明的变量看成局部变量。
**<u>但是，如果要引用类级别变量，该怎么办？可以使用语法object.fieldname，在对象的外部引用类或结构的字段。</u>**

## 1.4 常量

顾名思义，常量是其值在使用过程（生命周期）中不会发生变化的变量。在声明和初始化变量时，在变量的前面加上关键字const，就可以把该变量指定为一个常量。
常量具有如下特点：
● 常量必须在声明时初始化。指定了其值后，就不能再改写了。 
● 常量的值必须能在编译时用于计算。因此，不能用从变量中提取的值来初始化常量。如果需要这么做，应使用只读字段（详见第3章）。 
● **常量总是隐式静态的。但注意，不必（实际上，是不允许）在常量声明中包含修饰符static。** 

在程序中使用常量至少有3个好处： 
● 由于使用易于读取的名称（名称的值易于理解）替代了较难读取的数字和字符串，常量使程序变得更易于阅读。 
● 常量使程序更易于修改。例如，在C#程序中有一个SalesTax常量，该常量的值为6%。如果以后销售税率发生变化，把新值赋给这个常量，就可以修改所有的税款计算结果，而不必查找整个程序去修改税率为0.06的每个项。
● 常量更容易避免程序出现错误。如果在声明常量的位置以外的某个地方将另一个值赋给常量，编译器就会标记错误。

## 1.5 预定义数据类型(变量的类型)

两中大的分类：

1.值类型
2.引用类型

从概念上看，其区别是值类型直接存储其值，而引用类型存储对值的引用。
这两种类型存储在内存的不同地方：值类型存储在堆栈（stack）中，而引用类型存储在托管堆（managed heap）上。注意区分某个类型是值类型还是引用类型，因为这会有不同的影响。例如，int是值类型，这表示下面的语句会在内存的两个地方存储值20：

C#把基本类型（如int和bool）规定为值类型，而把包含许多字段的较大类型（通常在有类的情况下）规定为引用类型，C#设计这种方式是为了得到最佳性能。如果要把自己的类型定义为值类型，**就应把它声明为一个结构。**

**大多数更复杂的C#数据类型，包括我们自己声明的类，都是引用类型。它们分配在堆中，其生存期可以跨多个函数调用，可以通过一个或几个别名来访问。CLR实现一种精细的算法，来跟踪哪些引用变量仍是可以访问的，哪些引用变量已经不能访问了。CLR会定期删除不能访问的对象，把它们占用的内存返回给操作系统。这是通过垃圾回收器实现的。**

### 1.5.1 .net类型

数据类型的C#关键字（如int、short和string）从编译器映射到.NET数据类型。例如，在C#中声明一个int类型的数据时，声明的实际上是.NET结构System.Int32的一个实例。这听起来似乎很深奥，但其意义深远：这表示在语法上，可以把所有的基本数据类型看成支持某些方法的类。例如，要把int i转换为string类型，可以编写下面的代码： string s = i.ToString(); **<u>应强调的是，在这种便利语法的背后，类型实际上仍存储为基本类型。</u>**基本类型在概念上用.NET结构表示，所以肯定没有性能损失。 

下面看看C#中定义的内置类型。我们将列出每个类型，以及它们的定义和对应.NET类型的名称。C#有15个预定义类型，其中13个是值类型，两个是引用类型（string和object）。

### 1.5.2 C#类型

具体的定义略，可以参考，**[美] Christian Nagel. C#高级编程(第10版) C# 6 & .NET Core 1.0 (2.4.3). 清华大学出版社.**

**有些C#类型的名称与C++和Java类型一致，但定义不同。例如，在C#中，int总是32位有符号的整数。而在C++中，int是有符号的整数，但其位数取决于平台（在Windows上是32位）。在C#中，所有的数据类型都以与平台无关的方式定义，以备将来从C#和.NET迁移到其他平台上。**

**如果对一个int、uint、long还是ulong类型的整数没有任何显式的声明，则该变量默认为int类型。为了把输入的值指定为其他整数类型，可以在数字后面加上如下字符：**

```C#
uint ui = 1234U; long l = 1234L; ulong ul = 1234UL;
```

**bool值和整数值不能相互隐式转换。如果变量（或函数的返回类型）声明为bool类型，就只能使用值true或false。如果试图使用0表示false，非0值表示true，就会出错。**

**char类型的字面量是用单引号括起来的，如’A'。如果把字符放在双引号中，编译器会把它看成字符串，从而产生错误。**

**<u>*C#有string关键字，转换为.NET类System.String。有了它，像字符串连接和字符串复制这样的操作就很简单了。尽管它为引用类型，string类已实现，其语义遵循一般的、直观的字符串规则。*</u>**

**名称空间的别名**,如下

```C#
using alias = NamespaceName;
```



## 1.6  XML文档

如前所述，除了C风格的注释外，C#还有一个非常出色的功能（本章将讨论这一功能）：根据特定的注释自动创建XML格式的文档说明。这些注释都是单行注释，但都以3条斜杠（///）开头，而不是通常的两条斜杠。在这些注释中，可以把包含类型和类型成员的文档说明的XML标记放在代码中。

编译器可以识别一些格式的注释文档。

## 1.7  C#预处理器指令

**注意： C++开发人员应该知道，在C和C++中预处理器指令非常重要。但是，在C#中，并没有那么多的预处理器指令，它们的使用也不太频繁。C#提供了其他机制来实现许多C++指令的功能，如定制特性。还要注意，C#并没有一个像C++那样的独立预处理器，所谓的预处理器指令实际上是由编译器处理的。尽管如此，C#仍保留了一些预处理器指令名称，因为这些命令会让人觉得就是预处理器。**

# 2. 对象与类型

结构不同于类，因为它们不需要在堆上分配空间（类是引用类型，总是存储在堆（heap）上），而结构是值类型，通常存储在栈（stack）上，另外，结构不支持继承。对于类和结构，都使用关键字new来声明实例：这个关键字创建对象并对其进行初始化。

**类和结构的一个重要区别是，类类型的对象通过引用传递，结构类型的对象按值传递。**

类中的成员说明：

| 成员     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 字段     | 字段是类的数据成员，它是类型的一个变量，该类型是类的一个成员 |
| 方法     | 方法是与特定类相关联的函数                                   |
| 常量     | 常量与类相关（尽管它们没有static修饰符）。编译器使用真实值代替常量 |
| 属性     | 属性是可以从客户端访问的函数组，其访问方式与访问类的公共字段类似。C#为读写类中的属性提供了专用语法，所以不必使用那些名称中嵌有Get或Set的方法。因为属性的这种语法不同于一般函数的语法，所有在客户端代码中，虚拟的对象被当作实际的东西 |
| 构造函数 | 构造函数是在实例化对象时自动调用的特殊函数。它们必须与所属的类同名，且不能有返回类型。构造函数用于初始化字段的值 |
| 索引器   | 索引器允许对象用访问数组的方式访问。索引器参见第8章          |
| 运算符   | 运算符执行的最简单的操作就是加法和减法。在两个整数相加时，严格地说，就是对整数使用“+”运算符。C#还允许指定把已有的运算符应用于自己的类（运算符重载）。第8章将详细论述运算符 |
| 事件     | 事件是类的成员，在发生某些行为（如修改类的字段或属性，或者进行了某种形式的用户交互操作）时，它可以让对象通知调用方。客户可以包含所谓“事件处理程序”的代码来响应该事件。第9章将详细介绍事件 |
| 析构函数 | 析构函数或终结器的语法类似于构造函数的语法，但是在CLR检测到不再需要某个对象时调用它。它们的名称与类相同，但前面有一个“～”符号。不可能预测什么时候调用终结器。终结器详见第5章 |
| 类型     | 类可以包含内部类。如果内部类型只和外部类型结合使用，就很有趣 |

## 2.1 属性

属性（property）的概念是：它是一个方法或一对方法，在客户端代码看来，它（们）是一个字段。

1．自动实现的属性 如果属性的set和get访问器中没有任何逻辑，就可以使用自动实现的属性。这种属性会自动实现后备成员变量。

示例的代码如下： 

```C#
public int Age { get; set; }
```

这种方法后备成员变量就不知道是啥名。

自动实现的属性可以使用属性初始化器来初始化：示例代码如下：

```C#
public int Age { get; set; } = 42;
```

2．属性的访问修饰符 C#允许给属性的get和set访问器设置不同的访问修饰符，所以属性可以有公有的get访问器和私有或受保护的set访问器。

```C#
public string Name { get { return _name; } private set { _name = value; } } 
```

通过自动实现的属性，也可以设置不同的访问级别： 

```C#
public int Age { get; private set; }
```

**Note:属性默认的访问属性就是public，因此不能用public修饰，并且两个不能同时不为public访问属性，否则会编译报错**

## 2.2 方法

注意，正式的C#术语区分函数和方法。在C#术语中，“函数成员”不仅包含方法，也包含类或结构的一些非数据成员，如索引器、运算符、构造函数和析构函数等，甚至还有属性。这些都不是数据成员，字段、常量和事件才是数据成员。
2．表达式体方法

方法声明：

```C#
[modifiers] return_type MethodName([parameters]) { // Method body }
```

2．表达式体方法

如果方法的实现只有一个语句，C# 6为方法定义提供了一个简化的语法：表达式体方法。使用新的语法，不需要编写花括号和return关键字，而使用运算符= >（lambda操作符）区分操作符左边的声明和操作符右边的实现代码。

```C#
public bool IsSquare(Rectangle rect) => rect.Height == rect.Width;
```

4．方法的重载 C#支持方法的重载——方法的几个版本有不同的签名（即，方法名相同，但参数的个数和/或数据类型不同）。为了重载方法，只需要声明同名但参数个数或类型不同的方法即可。

6．可选参数，参数也可以是可选的。必须为可选参数提供默认值。可选参数还必须是方法定义的最后的参数。

```C#
public void TestMethod(int notOptionalNumber, int optionalNumber = 42) { WriteLine(optionalNumber + notOptionalNumber); }
```

通过多个可选参数，命名参数的特性就会发挥作用。使用命名参数，可以传递任何可选参数，例如，下面的例子仅传递最后一个参数： 

```C#
public void TestMethod(int n, int opt1 = 11 , int opt2 = 22 , int opt3 = 33 ) { WriteLine(n + opt1 + opt2 + opt3); }
TestMethod(1, opt3: 4);
```

7．个数可变的参数 使用可选参数，可以定义数量可变的参数。然而，还有另一种语法允许传递数量可变的参数——这个语法没有版本控制问题。 声明数组类型的参数（示例代码使用一个int数组），添加params关键字，就可以使用任意数量的int参数调用该方法。 

```C#
public void AnyNumberOfArguments(params int[] data) { foreach (var x in data) { WriteLine(x); } }
```

**如果params关键字与方法签名定义的多个参数一起使用，则params只能使用一次，而且它必须是最后一个参数**



## 2.3 构造函数

没有必要给类提供构造函数，到目前为止本书的例子中没有提供这样的构造函数。一般情况下，如果没有提供任何构造函数，编译器会在后台生成一个默认的构造函数。**<u>*这是一个非常基本的构造函数，它只能把所有的成员字段初始化为标准的默认值（例如，引用类型为空引用，数值数据类型为0, bool为false）。这通常就足够了，否则就需要编写自己的构造函数。*</u>** 

**<u>*但是，如果提供了带参数的构造函数，编译器就不会自动提供默认的构造函数。只有在没有定义任何构造函数时，编译器才会自动提供默认的构造函数。*</u>**

构造函数的重载遵循与其他方法相同的规则。换言之，可以为构造函数提供任意多的重载，只要它们的签名有明显的区别即可。

● 类仅用作某些静态成员或属性的容器，因此永远不会实例化它。在这种情况下，可以用static修饰符声明类。使用这个修饰符，类只能包含静态成员，不能实例化。 
● 希望类仅通过调用某个静态成员函数来实例化（这就是所谓对象实例化的类工厂方法）。单例模式的实现如下面的代码片段所示：

```C#
public class Singleton { 
    private static Singleton s_instance; 
    private int _state; private Singleton(int state) { _state = state; } 
    public static Singleton Instance { get { return s_instance ? ? (s_instance = new MySingleton(42); } } 
}
```

**<u>*类中的数据成员即便不在定义的构造函数里初始化，也会变初始化标准的默认值（例如，引用类型为空引用，数值数据类型为0, bool为false）*</u>**

### 2.3.1 从构造函数中调用其他构造函数

省事

```C#
class Car { 
    private string _description; 
    private uint _nWheels; 
    public Car(string description, uint nWheels) { 
        _description = description;
        _nWheels = nWheels; 
    } 
    public Car(string description) { 
        _description = description; 
        _nWheels = 4; 
    } // etc.
}
//优化如下
class Car { 
    private string _description; 
    private uint _nWheels; 
    public Car(string description, uint nWheels) { 
        _description = description; 
        _nWheels = nWheels; 
    } 
    public Car(string description): this (description, 4) { } // etc
}
```

### 2.3.2 静态构造函数

**<u>*C#的一个新特征是也可以给类编写无参数的静态构造函数。这种构造函数只执行一次，而前面的构造函数是实例构造函数，只要创建类的对象，就会执行它。*</u>**

编写静态构造函数的一个原因是，类有一些静态字段或属性，需要在第一次使用类之前，从外部源中初始化这些静态字段和属性。

<u>*.NET运行库没有确保什么时候执行静态构造函数，所以不应把要求在某个特定时刻（例如，加载程序集时）执行的代码放在静态构造函数中。也不能预计不同类的静态构造函数按照什么顺序执行。但是，可以确保静态构造函数至多运行一次，即在代码引用类之前调用它。**在C#中，通常在第一次调用类的任何成员之前执行静态构造函数**。*</u>



<u>***注意，静态构造函数没有访问修饰符，其他C#代码从来不显式调用它，但在加载类时，总是由.NET运行库调用它，所以像public或private这样的访问修饰符就没有任何意义。出于同样原因，静态构造函数不能带任何参数，一个类也只能有一个静态构造函数。很显然，静态构造函数只能访问类的静态成员，不能访问类的实例成员。***</u>

### 2.3.3 只读成员

如果不希望在初始化后修改数据成员，就可以使用readonly关键字。下面详细描述只读字段和只读属性。

#### 只读字段

为了保证对象的字段不能改变，字段可以用readonly修饰符声明。**<u>*带有readonly修饰符的字段只能在构造函数中分配值。*</u>**
**<u>*它与const修饰符不同。编译器通过const修饰符，用其值取代了使用它的变量。编译器知道常量的值。只读字段在运行期间通过构造函数指定。*</u>*****<u>与常量字段相反，只读字段可以是实例成员。使用只读字段作为类成员时，需要把static修饰符分配给该字段。</u>***

NOTE:还要注意，在构造函数中不必给只读字段赋值。如果没有赋值，它的值就是其特定数据类型的默认值，或者在声明时给它初始化的值。这适用于只读的静态字段和实例字段。即便是正常的字段，在.net 6.0的环境下也会被初始化（没有在构造函数中进行初始化）。

#### 只读属性

只读属性:在属性定义中省略set访问器，就可以创建只读属性。因此，如下代码把Name变成只读属性：

```C#
private readonly string _name; public string Name { get { return _name; } } 
```

 用readonly修饰符声明字段，只允许在构造函数中初始化属性的值。 同样，在属性定义中省略get访问器，就可以创建只写属性。**<u>*但是，这是不好的编程方式，因为这可能会使客户端代码的作者感到迷惑。一般情况下，如果要这么做，最好使用一个方法替代。*</u>**

C# 6提供了一个简单的语法，使用自动实现的属性创建只读属性，访问只读字段。这些属性可以使用属性初始化器来初始化。 当然，只读属性也可以在构造函数中初始化。

```C#
public string Id { get; } = Guid.NewGuid().ToString();
```

#### 表达式属性

C# 6中与属性相关的另一个扩展是表达式体属性。类似于表达式体方法，表达式体属性不需要花括号和返回语句。表达式体属性是带有get访问器的属性，但不需要编写get关键字。只是get访问器的实现后跟lambda操作符。对于Person类，FullName属性使用表达式体属性实现，通过该属性返回FirstName和LastName属性值的组合：

```C#
public class Person { 
    public Person(string firstName, string lastName) { 
        FirstName = firstName; 
        LastName = lastName; 
    } 
    public string FirstName { get; } 
    public string LastName { get; } 
    public string FullName => $"{FirstName} {LastName}"; 
}
```

#### 不可变的类型

**<u>*如果类型包含可以改变的成员，它就是一个可变的类型。使用readonly修饰符，编译器会在状态改变时报错。状态只能在构造函数中初始化。如果对象没有任何可以改变的成员，只有只读成员，它就是一个不可变类型。其内容只能在初始化时设置。这对于多线程是非常有用的，因为多个线程可以访问信息永远不会改变的同一个对象。因为内容不能改变，所以不需要同步。*</u>**



## 2.4 匿名类型

var关键字，它用于表示隐式类型化的变量。var与new关键字一起使用时，可以创建匿名类型。匿名类型只是一个继承自Object且没有名称的类。**<u>该类的定义从初始化器中推断，类似于隐式类型化的变量。</u>**

如果所设置的值来自于另一个对象，就可以简化初始化器。如果已经有一个包含FirstName、MiddleName和LastName属性的类，且有该类的一个实例（person）, captain对象就可以初始化为： 

```C#
var captain = new { person.FirstName, person.MiddleName, person.LastName }; 
```

person对象的属性名应投射到新对象名captain，所以captain对象应有FirstName、MiddleName和LastName属性。

**<u>*这些新对象的类型名未知。编译器为类型“伪造”了一个名称，但只有编译器才能使用它。我们不能也不应使用新对象上的任何类型反射，因为这不会得到一致的结果。*</u>**

## 2.5 结构



结构是值类型，不是引用类型。**<u>*它们存储在栈中或存储为内联（如果它们是存储在堆中的另一个对象的一部分）*</u>**，其生存期的限制与简单的数据类型一样。 

● 结构不支持继承。 
● 对于结构，构造函数的工作方式有一些区别。如果没有提供默认的构造函数，编译器会自动提供一个，把成员初始化为其默认值。 
● 使用结构，可以指定字段如何在内存中布局



因为结构实际上是把数据项组合在一起，所以有时大多数或者全部字段都声明为public。**<u>*严格来说，这与编写.NET代码的规则相反——根据Microsoft，字段（除了const字段之外）应总是私有的，并由公有属性封装。*</u>**但是，对于简单的结构，许多开发人员都认为公有字段是可接受的编程方式。


### 2.5.1 结构是值类型

注意，因为结构是值类型，所以new运算符与类和其他引用类型的工作方式不同。**<u>*new运算符并不分配堆中的内存，而是只调用相应的构造函数，根据传送给它的参数，初始化所有的字段*</u>**。对于结构，可以编写下述完全合法的代码：

```C#
Dimensions point; 
point.Length = 3; 
point.Width = 6; 
```

**<u>*结构遵循其他数据类型都遵循的规则：在使用前所有的元素都必须进行初始化。*</u>**在结构上调用new运算符，或者给所有的字段分别赋值，结构就完全初始化了。当然，如果结构定义为类的成员字段，在初始化包含的对象时，该结构会自动初始化为0。

<u>***NOTE:在net6.0环境下，这种代码无法通过编译，最好还是先初始化对象再进行使用。***</u>

结构不是为继承设计的。这意味着：**<u>*它不能从一个结构中继承。唯一的例外是对应的结构（和C#中的其他类型一样）最终派生于类System.Object。因此，结构也可以访问System.Object的方法。在结构中，甚至可以重写System.Object中的方法——如重写ToString（）方法。结构的继承链是：每个结构派生自System.ValueType类，System.ValueType类又派生自System.Object。ValueType并没有给Object添加任何新成员，但提供了一些更适合结构的实现方式。注意，不能为结构提供其他基类：每个结构都派生自ValueType。*</u>** 

为结构定义构造函数的方式与为类定义构造函数的方式相同。 前面说过，默认构造函数把数值字段都初始化为0，且总是隐式地给出，即使提供了其他带参数的构造函数，也是如此。

## 2.6 按值和引用传递参数

结构按值传递，通过按值传递。类按引用传递。

```C#
public struct Dimensions { 
    public double Length { get; set; }
    public double Width { get; set; } 
    public Dimensions(double length, double width) { Length = length; Width = width; } 
    //表达式属性,返回了Math.Sqrt(Length * Length + Width * Width)
    public double Diagonal => Math.Sqrt(Length * Length + Width * Width); 
}
public class Dimensions1 { 
    public double Length { get; set; }
    public double Width { get; set; } 
    public Dimensions1(double length, double width) { Length = length; Width = width; } 
    //表达式属性,返回了Math.Sqrt(Length * Length + Width * Width)
    public double Diagonal => Math.Sqrt(Length * Length + Width * Width); 
}
public static void ChangeValue(Dimensions a){
    a.Length = 100;
}
public static void ChangeValue(Dimensions1 a){
    a.Length = 100;
}
Dimensions d1 = new Dimensions(10,10);
Dimensions1 d2 = new Dimensions1(0,0);
//d1为结构体，d2为类，d1为值传递，d2为引用传递
ChangeValue(d1);
ChangeValue(d2);
Console.WriteLine($"d1.Length:{d1.Length}");
Console.WriteLine($"d2.Length:{d2.Length}");
//输出
//d1.Length:10
//d2.Length:100
```

### 2.6.1 ref参数

也可以通过引用传递结构。如果A是结构类型，就添加ref修饰符，方法的声明，通过引用传递变量。在调用方法时需要添加它。

对于引用类型，如果要在函数中创建新对象并更改原先的引用，需要添加ref修饰符。

```C#
 public static void ChangeValue(Dimensions1 a){
     a.Length = 100;
     a = new Dimensions1(1001,1001);
 }
public static void ChangeValue(ref Dimensions1 a){
    a.Length = 1000;
    a = new Dimensions1(10000,10000);
}
```

### 2.6.2　out参数

如果方法返回一个值，该方法通常声明返回类型，并返回结果。<u>如果方法返回多个值，可能类型还不同，该怎么办？</u>这有不同的选项。**<u>*一个选项是声明类和结构，把应该返回的所有信息都定义为该类型的成员。另一个选项是使用元组类型。第三个选项是使用out关键字。*</u>**

使用out参数，变量不需要预先初始化，变量在方法中初始化。类似于ref关键字，out关键字也需要在调用方法时提供，而不仅仅在声明方法时提供。

使用示例：

```C#
string input2 = Console.ReadLine(); 
int result; 
if (int.TryParse(input2, out result) ) 
{ 
    Console.WriteLine($"n: {result}"); 
} 
else 
{ 
    Console.WriteLine("not a number"); 
}
```

## 2.7 可空类型

可空类型是可以为空的值类型。可空类型只需要在类型的后面添加“？”（它必须是结构）。与基本结构相比，值类型唯一的开销是一个可以确定它是否为空的布尔成员。（勘误，应该是可空类型的唯一开销）。

**对于可空类型，可以使用能用于基本类型的所有可用操作符，例如，可用于int？的+、-、*、/等。每个结构类型都可以使用可空类型，而不仅是预定义的C#类型。**

## 2.8 枚举类型

枚举是一个值类型，包含一组命名的常量，如这里的Color类型。枚举类型用enum关键字定义

```C#
 public enum Color { Red, Green, Blue }
```

默认情况下，enum的类型是int。这个基本类型可以改为其他整数类型（byte、short、int、带符号的long和无符号变量）。命名常量的值从0开始递增，但它们可以改为其他值：

```C#
public enum Color : short { Red = 1, Green = 2, Blue = 3 }
```

使用强制类型转换可以把数字改为枚举值，把枚举值改为数字。(不使用强制类型转换可以转换嘛？无法隐式转换，必须强制类型转换)



**<u>*还可以使用enum类型把多个选项分配给一个变量，而不仅仅是一个枚举常量。为此，分配给常量的值必须是不同的位，Flags属性需要用枚举设置。*</u>**

```C#
[Flags] public enum DaysOfWeek { 
    Monday = 0x1, Tuesday = 0x2, Wednesday = 0x4, Thursday = 0x8, Friday = 0x10, Saturday = 0x20, Sunday = 0x40 
}
```



设置不同的位，也可以结合单个位来包括多个值，如Weekend的值0x60是用逻辑或运算符结合了Saturday和Sunday。Workday则结合了从Monday到Friday的所有日子，AllWeek用逻辑或运算符结合了Workday和Weekend 

Enum.GetNames方法返回一个包含所有枚举名的字符串数组。

为了获得枚举的所有值，可以使用方法Enum.GetValues。Enum.GetValues返回枚举值的一个数组。为了获得整数值，需要把它转换为枚举的底层类型。

## 2.9 部分类

partial关键字允许把类、结构、方法或接口放在多个文件中。一般情况下，某种类型的代码生成器生成了一个类的某部分，所以把类放在多个文件中是有益的。假定要给类添加一些从工具中自动生成的内容。如果重新运行该工具，前面所做的修改就会丢失。partial关键字有助于把类分开放在两个文件中，而对不由代码生成器定义的文件进行修改。

## 2.10 扩展方法

有许多扩展类的方式。继承就是给对象添加功能的好方法。扩展方法是给对象添加功能的另一个选项，在不能使用继承时，也可以使用这个选项（例如类是密封的）。扩展方法是静态方法，它是类的一部分，但实际上没有放在类的源代码中。

示例：

```C#
public static class StringExtension { 
    public static int GetWordCount(this string s) => s.Split().Length; 
}
```

**<u>*使用this关键字和第一个参数来扩展字符串。这个关键字定义了要扩展的类型。*</u>**

使用：

```C#
string fox = "the quick brown fox jumped over the lazy dogs down " + "9876543210 times"; 
int wordCount = fox.GetWordCount(); 
WriteLine($"{wordCount} words");
```

**<u>*编译器如何找到某个类型的扩展方法？this关键字必须匹配类型的扩展方法，而且需要打开定义扩展方法的静态类所在的名称空间。如果把StringExtensions类放在名称空间Wrox. Extensions中，则只有用using指令打开Wrox.Extensions，编译器才能找到GetWordCount方法。如果类型还定义了同名的实例方法，扩展方法就永远不会使用。类中已有的任何实例方法都优先。当多个同名的扩展方法扩展相同的类型，打开所有这些类型的名称空间时，编译器会产生一个错误，指出调用是模棱两可的，它不能决定在多个实现代码中选择哪个。然而，如果调用代码在一个名称空间中，这个名称空间就优先。*</u>**

## 2.11 Object类

**<u>*前面提到，所有的.NET类最终都派生自System.Object。实际上，如果在定义类时没有指定基类，编译器就会自动假定这个类派生自Object。本章没有使用继承，所以前面介绍的每个类都派生自System.Object（如前所述，对于结构，这个派生是间接的：结构总是派生自System.ValueType, System.ValueType又派生自System.Object）。*</u>**

其实际意义在于，除了自己定义的方法和属性等外，还可以访问为Object类定义的许多公有的和受保护的成员方法。这些方法可用于自己定义的所有其他类中。 下面将简要总结每个方法的作用：

● ToString（）方法： 是获取对象的字符串表示的一种便捷方式。当只需要快速获取对象的内容，以进行调试时，就可以使用这个方法。在数据的格式化方面，它几乎没有提供选择：例如，在原则上日期可以表示为许多不同的格式，但DateTime.ToString（）没有在这方面提供任何选择。如果需要更复杂的字符串表示，例如，考虑用户的格式化首选项或区域性，就应实现IFormattable接口。

 ● GetHashCode（）方法： 如果对象放在名为映射（也称为散列表或字典）的数据结构中，就可以使用这个方法。处理这些结构的类使用该方法确定把对象放在结构的什么地方。如果希望把类用作字典的一个键，就需要重写GetHashCode（）方法。实现该方法重载的方式有一些相当严格的限制，这些将在第11章介绍字典时讨论。 

● Equals（）（两个版本）和ReferenceEquals（）方法： 注意有3个用于比较对象相等性的不同方法，这说明.NET Framework在比较相等性方面有相当复杂的模式。这3个方法和比较运算符“==”在使用方式上有微妙的区别。而且，在重写带一个参数的虚Equals（）方法时也有一些限制，因为System.Collections名称空间中的一些基类要调用该方法，并希望它以特定的方式执行。第8章在介绍运算符时将探讨这些方法的使用。 

● Finalize（）方法： 第5章将介绍这个方法，**<u>*它最接近C++风格的析构函数*</u>**，在引用对象作为垃圾被回收以清理资源时调用它。Object中实现的Finalize（）方法实际上什么也没有做，因而被垃圾回收器忽略。如果对象拥有对未托管资源的引用，则在该对象被删除时，就需要删除这些引用，此时一般要重写Finalize（）。垃圾收集器不能直接删除这些对未托管资源的引用，因为它只负责托管的资源，于是它只能依赖用户提供的Finalize（）。 

● GetType（）方法： 这个方法返回从System.Type派生的类的一个实例，因此可以提供对象成员所属类的更多信息，包括基本类型、方法、属性等。System.Type还提供了.NET的反射技术的入口点。这个主题详见第16章。

● MemberwiseClone（）方法： 这是System.Object中唯一没有在本书的其他地方详细论述的方法。不需要讨论这个方法，因为它在概念上相当简单，它只复制对象，并返回对副本的一个引用（对于值类型，就是一个装箱的引用）。**<u>*注意，得到的副本是一个浅表复制，即它复制了类中的所有值类型。如果类包含内嵌的引用，就只复制引用，而不复制引用的对象。这个方法是受保护的，所以不能用于复制外部的对象。该方法不是虚方法，所以不能重写它的实现代码。*</u>**
注：在调用类的静态成员时，便会先调用类的静态构造函数

# 3. 继承

## 3.1 C#支持的面向对象特性

● 单重继承： 表示一个类可以派生自一个基类。C#就采用这种继承。 
● 多重继承： 多重继承允许一个类派生自多个类。**<u>*C#不支持类的多重继承，但允许接口的多重继承。*</u>** 
● 多层继承： **<u>*多层继承允许继承有更大的层次结构*</u>**。类B派生自类A，类C又派生自类B。 其中，类B也称为中间基类，C#支持它，也很常用。 
● 接口继承： 定义了接口的继承。这里允许多重继承。接口和接口继承参见本章后面的“接口”一节。

**<u>*对于实现继承，多重继承会给生成的代码增加复杂性，还会带来一些开销。因此，C#的设计人员决定不支持类的多重继承。*</u>**

使用结构的一个限制是结构不支持继承，但每个结构都自动派生自System.ValueType。不能编码实现结构的类型层次，但结构可以实现接口。换言之，结构并不支持实现继承，但支持接口继承。定义的结构和类可以总结为： 
● 结构总是派生自System.ValueType，它们还可以派生自任意多个接口。 
● 类总是派生自System.Object或用户选择的另一个类，它们还可以派生自任意多个接口。

## 3.2 继承实现

如果要声明派生自另一个类的一个类，就可以使用下面的语法：

```C#
class MyDerivedClass: MyBaseClass { // members }
```

  如果类（或结构）也派生自接口，则用逗号分隔列表中的基类和接口： 

```C#
public class MyDerivedClass: MyBaseClass, IInterface1, IInterface2 { // members }
```

　**<u>*如果类和接口都用于派生，则类总是必须放在接口的前面。*</u>**

### 3.2.1 虚函数



把一个基类方法声明为virtual，就可以在任何派生类中重写该方法：

重写基类的方法时，签名（所有参数类型和方法名）和返回类型必须完全匹配。否则，以后创建的新成员就不覆盖基类成员。

**<u>*C#中虚函数的概念与标准OOP的概念相同：可以在派生类中重写虚函数。在调用方法时，会调用该类对象的合适方法。在C#中，函数在默认情况下不是虚拟的，但（除了构造函数以外）可以显式地声明为virtual。这遵循C++的方式，即从性能的角度来看，除非显式指定，否则函数就不是虚拟的。而在Java中，所有的函数都是虚拟的。但C#的语法与C++的语法不同，因为C#要求在派生类的函数重写另一个函数时，要使用override关键字显式声明。*</u>**

重写方法的语法避免了C++中很容易发生的潜在运行错误：当派生类的方法签名无意中与基类版本略有差别时，该方法就不能重写基类的方法。在C#中，这会出现一个编译错误，因为编译器会认为函数已标记为override，但没有重写其基类的方法。

### 3.2.2 多态性

使用多态性，可以动态地定义调用的方法，而不是在编译期间定义。编译器创建一个虚拟方法表（vtable），其中列出了可以在运行期间调用的方法，它根据运行期间的类型调用方法。(动态绑定)

### 3.2.3 隐藏方法

如果签名相同的方法在基类和派生类中都进行了声明，但该方法没有分别声明为virtual和override，派生类方法就会隐藏基类方法。在**<u>*大多数情况下，是要重写方法，而不是隐藏方法，因为隐藏方法会造成对于给定类的实例调用错误方法的危险。*</u>**但是，如下面的例子所示，C#语法可以确保开发人员在编译时收到这个潜在错误的警告，从而使隐藏方法（如果这确实是用户的本意）更加安全。这也是类库开发人员得到的版本方面的好处。

*<u>**注意： new方法修饰符不应该故意用于隐藏基类的成员。这个修饰符的主要目的是处理版本冲突，在修改派生类后，响应基类的变化。**</u>*

### 3.2.4 访问方法的基类版本

C#有一种特殊的语法用于从派生类中调用方法的基类版本：

```C#
base.<MethodName>()
```

*<u>**注意： 使用base关键字，可以调用基类的任何方法——而不仅仅是已重写的方法。**</u>*

### 3.2.5 抽象类与抽象方法

**<u>*C#允许把类和方法声明为abstract。抽象类不能实例化，而抽象方法不能直接实现，必须在非抽象的派生类中重写。显然，抽象方法本身也是虚拟的（尽管也不需要提供virtual关键字，实际上，如果提供了该关键字，就会产生一个语法错误）。如果类包含抽象方法，则该类也是抽象的，也必须声明为抽象的*</u>**。

**<u>*从抽象基类中派生类型时，需要实现所有抽象成员。否则，编译器会报错*</u>**

抽象类不能实例化，但是其派生类可以实例化赋值给抽象类变量。

### 3.2.6 密封类与密封方法

如果不应创建派生自某个自定义类的类，该自定义类就应密封。给类添加sealed修饰符，就不允许创建该类的子类。密封一个方法，表示不能重写该方法。



**<u>*要在方法或属性上使用sealed关键字，必须先从基类上把它声明为要重写的方法或属性。如果基类上不希望有重写的方法或属性，就不要把它声明为virtual。*</u>**

### 3.2.7 派生类的构造函数

**<u>*构造函数总是按照层次结构的顺序调用：先调用System.Object类的构造函数，再按照层次结构由上向下进行，直到到达编译器要实例化的类为止。为了实例化Ellipse类型，先调用Object构造函数，再调用Shape构造函数，最后调用Ellipse构造函数。这些构造函数都处理它自己类中字段的初始化。*</u>**

**<u>*当删除默认构造函数，重新编译程序时，不能编译Ellipse和Rectangle类，因为编译器不知道应该把什么值传递给基类唯一的非默认值构造函数。这里需要在派生类中创建一个构造函数，用构造函数初始化器初始化基类构造函数。*</u>**

编译给的不够看，写不正确会报错。注意保证每个层都初始化到就行。

## 3.3 修饰符

| 修饰符            |   应用于   |   说明    |
| ---------------------------- | ---- | ---- |
| public | 所有类型或成员 | 任何代码均可以访问该项 |
| protected | 类型和内嵌类型的所有成员 | 只有派生的类型能访问该项 |
| internal | 所有类型或成员 | 只能在包含它的程序集中访问该项 |
| private | 类型和内嵌类型的所有成员 | 只能在它所属的类型中访问该项 |
| protected internal | 类型和内嵌类型的所有成员 | 只能在包含它的程序集和派生类型的任何代码中访问该项 |
|                              |      |      |

<u>***注意： public、protected和private是逻辑访问修饰符。internal是一个物理访问修饰符，其边界是一个程序集。***</u>

不能把类型定义为protected、private或protected internal，因为这些修饰符对于包含在名称空间中的类型没有意义。因此这些修饰符只能应用于成员。但是，可以用这些修饰符定义嵌套的类型（即，包含在其他类型中的类型），因为在这种情况下，类型也具有成员的状态。于是，下面的代码是合法的：

```C#
public class OuterClass { 
    protected class InnerClass { 
        // etc. 
    } 
    // etc. 
}
```

3.3.1 其他修饰符


| 修饰符            |   应用于   |   说明    |
| ---------------------------- | ---- | ---- |
| new  | 函数成员 | 成员用相同的签名隐藏继承的成员 |
| static | 所有成员 | 成员不作用于类的具体实例，也称为类成员，而不是实例成员 |
| virtual | 仅函数成员 | 成员可以由派生类重写 |
| abstract | 仅函数成员 | 成员重写了继承的虚拟或抽象成员 |
| override | 仅函数成员 | 成员重写了继承的虚拟或抽象成员 |
| sealed | 类、方法和属性 |   对于类，不能继承自密封类。对于属性和方法，成员重写已继承的虚拟成员，但任何派生类中的任何成员都不能重写该成员。该修饰符必须与override一起使用   |
| extern |    仅静态[DllImport]方法    |   成员在外部用另一种语言实现。这个关键字的用法参见第5章   |

## 3.4 接口

**<u>*声明接口在语法上与声明抽象类完全相同，但不允许提供接口中任何成员的实现方式。一般情况下，接口只能包含方法、属性、索引器和事件的声明。*</u>**

**<u>*类似于抽象类，永远不能实例化接口，它只能包含其成员的签名。此外，可以声明接口类型的变量。*</u>**

**<u>*在接口定义中还不允许声明成员的修饰符。接口成员总是隐式为public，不能声明为virtual。如果需要，就应由实现的类来声明，因此最好实现类来声明访问修饰符。*</u>**

### 3.4.1 定义与实现接口，继承

示例：

```C#
public interface IBankAccount { 
    void PayIn(decimal amount); 
    bool Withdraw(decimal amount); 
    decimal Balance { get; } 
}
```

接口可以彼此继承，其方式与类的继承方式相同。

## 3.5 is和as运算符

as运算符的工作原理类似于类层次结构中的cast运算符——它返回对象的引用。然而，它从不抛出InvalidCastException异常。相反，如果对象不是所要求的类型，这个运算符就返回null。这里，最好在使用引用前验证它是否为空，否则以后使用以下引用，就会抛出NullReferenceException异常。

除了使用as运算符之外，还可以使用is运算符。is运算符根据条件是否满足，对象是否使用指定的类型，返回true或false。

# 4. 托管与非托管的资源

● 运行期间在栈和堆上分配空间 
● 垃圾回收 
● 使用析构函数和System.IDisposable接口来释放非托管的资源 
● C#中使用指针的语法 
● 使用指针实现基于栈的高性能数组 
● 平台调用，访问本机API

   　 **<u>*注意： 本节不详细介绍许多主题的相关内容。应把这一节看作是一般过程的简化向导，而不是实现的确切说明。*</u>**



## 4.1 资源

[浅入 .NET Core 中的内存和GC知识 - 痴者工良 - 博客园 (cnblogs.com)](https://www.cnblogs.com/whuanle/p/14259311.html)

[垃圾回收的基本知识 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/standard/garbage-collection/fundamentals)

较为详细的内存管理总结，参考以上两个链接。以下摘录一些基础的.NET内存管理知识。

## 4.2 .NET 内存组成



**<u>*.NET 中，内存分为非托管内存、托管内存。*</u>**

.NET Core/.NET5+ 有一个称为 **dotnet** 的驱动程序，此驱动程序用于**执行命令或运行 .NET 程序**。当我们使用 dotnet 命令运行一个 .dll 文件时，操作系统会启动 dotnet 驱动程序，此时会分配操作系统内存资源、dotnet 驱动程序内存资源，这一部分即非托管资源，其中 dotnet 部分的内存包含了 CLR 等部件的内存。即使你并没有使用到 C/C++ 等非托管代码或者使用非托管资源，也会使用到非托管内存。

接下来 CLR 将初始化新进程，CLR 将为其分配托管内存(**托管堆**)，这段托管内存是一个连续的地址空间区域。.NET 安全代码只能使用托管内存，不能直接使用物理内存，垃圾收集器会为安全代码在托管堆上分配和释放虚拟内存。



C#托管堆，本机堆的区别？

本机堆(Native Heap):.NET 的内存有非托管内存和托管内存。CLR 运行的进程，存在本机堆和托管堆两种内存堆，**<u>*本机内存堆通过 Windows API 的 [VirtualAlloc](https://docs.microsoft.com/zh-cn/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) 函数分配，提供给 操作系统和 CLR 使用，用于非托管代码所需的内存。*</u>**

**<u>*使用托管和非托管的资源——存储在托管或本机堆中的对象。尽管垃圾收集器释放存储在托管堆中的托管对象，但不释放本机堆中的对象。必须由开发人员自己释放它们。*</u>**

## 4.3 栈内存的管理

由系统管理。下面简述其工作方式。

在处理器的虚拟内存中，有一个区域称为栈。**<u>*栈存储不是对象成员的值数据类型。*</u>**另外，**<u>*在调用一个方法时，也使用栈存储传递给方法的所有参数的副本。*</u>**为了理解栈的工作原理，需要注意在**<u>*C#中的变量作用域。*</u>**

核心在于：

**<u>*栈指针（操作系统维护的一个变量）表示栈中下一个空闲存储单元的地址。程序第一次开始运行时，栈指针指向为栈保留的内存块末尾。栈实际上是向下填充的，即从高内存地址向低内存地址填充。当数据入栈后，栈指针就会随之调整，以始终指向下一个空闲存储单元。*</u>**



## 4.4 托管堆的垃圾回收机制

**<u>*尽管栈有非常高的性能，但它还没有灵活到可以用于所有的变量。变量的生存期必须嵌套，在许多情况下，这种要求都过于苛刻。通常我们希望使用一个方法分配内存，来存储一些数据，并在方法退出后的很长一段时间内数据仍是可用的。只要是用new运算符来请求分配存储空间，就存在这种可能性——例如，对于所有的引用类型。此时就要使用托管堆。*</u>**

堆存在的原因。

### .net的托管堆的内存申请参考

托管堆（简称为堆）是处理器的可用内存中的另一个内存区域。要了解堆的工作原理和如何为引用数据类型分配内存，看看下面的代码： 

```C#
void DoWork() { 
    Customer arabel; //在栈上给这个引用分配存储空间,但这仅是一个引用，而不是实际的Customer对象
    arabel = new Customer(); 
    Customer otherCustomer2 = new EnhancedCustomer(); 
} 
```

在这段代码中，假定存在两个类Customer和EnhancedCustomer。EnhancedCustomer类扩展了Customer类。 首先，声明一个Customer引用arabel，在栈上给这个引用分配存储空间，但这仅是一个引用，而不是实际的Customer对象。arabel引用占用4个字节的空间，足够包含Customer对象的存储地址（需要4个字节把0～4GB之间的内存地址表示为一个整数值）。

 然后看下一行代码： arabel = new Customer(); 这行代码完成了以下操作：**<u>*首先，它分配堆上的内存，以存储Customer对象（一个真正的对象，不只是一个地址）。*</u>*****然后把变量arabel的值设置为分配给新Customer对象的内存地址（它还调用合适的Customer（）构造函数初始化类实例中的字段，但此处我们不必担心这部分）。***

 Customer实例没有放在栈中，而是放在堆中。在这个例子中，现在还不知道一个Customer对象占用多少字节，但为了讨论方便，假定是32个字节。这32个字节包含了Customer的实例字段，和.NET用于识别和管理其类实例的一些信息。

为了在堆上找到存储新Customer对象的一个存储位置，.NET运行库在堆中搜索，选取第一个未使用的且包含32个字节的连续块。

从这个例子可以看出，建立引用变量的过程要比建立值变量的过程更复杂，且不能避免性能的系统开销。**<u>*实际上，我们对这个过程进行了过分的简化，因为.NET运行库需要保存堆的状态信息，在堆中添加新数据时，这些信息也需要更新。尽管有这些性能开销，但仍有一种机制，在给变量分配内存时，不会受到栈的限制*</u>**。把一个引用变量的值赋予另一个相同类型的变量，就有两个变量引用内存中的同一对象了。**当一个引用变量超出作用域时，它会从栈中删除，如上一节所述，但引用对象的数据仍保留在堆中，一直到程序终止，或垃圾回收器删除它为止，而只有在该数据不再被任何变量引用时，它才会被删除。**



### .net GC

垃圾回收器具有以下优点：

- 开发人员不必手动释放内存。
- 有效分配**<u>*托管堆*</u>**上的对象。
- 回收不再使用的对象，清除它们的内存，并保留内存以用于将来分配。 托管对象会自动获取干净的内容来开始，因此，它们的构造函数不必对每个数据字段进行初始化。
- **<u>*通过确保对象不能使用另一个对象的内容来提供内存安全。*</u>**



托管堆的工作方式非常类似于栈，对象会在内存中一个挨一个地放置，这样就很容易使用指向下一个空闲存储单元的堆指针来确定下一个对象的位置。在堆上添加更多的对象时，也容易调整。但这比较复杂，因为基于堆的对象的生存期与引用它们的基于栈的变量的作用域不匹配。
***在垃圾回收器运行时，它会从堆中删除不再引用的所有对象。垃圾回收器在引用的根表中找到所有引用的对象，接着在引用的对象树中查找。在完成删除操作后，堆会立即把对象分散开来，与已经释放的内存混合在一起。***

**<u>*如果托管的堆也是这样，在其上给新对象分配内存就成为一个很难处理的过程，运行库必须搜索整个堆，才能找到足够大的内存块来存储每个新对象。*</u>**但是，垃圾回收器不会让堆处于这种状态。**<u>*只要它释放了能释放的所有对象，就会把其他对象移动回堆的端部，再次形成一个连续的内存块。*</u>**因此，<u>*堆可以继续像栈那样确定在什么地方存储新对象*</u>。当然，**<u>*在移动对象时，这些对象的所有引用都需要用正确的新地址来更新，但垃圾回收器也会处理更新问题。.*</u>**

**<u>*垃圾回收器的这个压缩操作是托管的堆与非托管的堆的区别所在。使用托管的堆，就只需要读取堆指针的值即可，而不需要遍历地址的链表，来查找一个地方放置新数据。*</u>**

一般情况下，垃圾回收器在.NET运行库确定需要进行垃圾回收时运行。可以调用System.GC.Collect（）方法，强迫垃圾回收器在代码的某个地方运行。System.GC类是一个表示垃圾回收器的.NET类，Collect（）方法启动一个垃圾回收过程。但是，GC类适用的场合很少，例如，代码中有大量的对象刚刚取消引用，就适合调用垃圾回收器。**<u>*但是，垃圾回收器的逻辑不能保证在一次垃圾收集过程中，所有未引用的对象都从堆中删除。*</u>**



GC的条件：

当满足以下条件之一时将发生垃圾回收：

- 系统具有低的物理内存。 这是通过 OS 的内存不足通知或主机指示的内存不足检测出来。
- 由托管堆上已分配的对象使用的内存超出了可接受的阈值。 随着进程的运行，此阈值会不断地进行调整。
- 调用 [GC.Collect](https://docs.microsoft.com/zh-cn/dotnet/api/system.gc.collect) 方法。 几乎在所有情况下，你都不必调用此方法，因为垃圾回收器会持续运行。 此方法主要用于特殊情况和测试。

### GC代数

垃圾回收主要在回收短生存期对象时发生。 为优化垃圾回收器的性能，将托管堆分为三代：第 0 代、第 1 代和第 2 代，因此它可以单独处理长生存期和短生存期对象。 垃圾回收器将新对象存储在第 0 代中。 在应用程序生存期的早期创建的对象如果未被回收，则被升级并存储在第 1 级和第 2 级中。 因为压缩托管堆的一部分要比压缩整个托管堆速度快，所以此方案允许垃圾回收器在每次执行回收时释放特定级别的内存，而不是整个托管堆的内存。

**第 0 代**。 这是最年轻的代，其中包含短生存期对象。 短生存期对象的一个示例是临时变量。 垃圾回收最常发生在此代中。

**第 1 代**。 这一代包含短生存期对象并用作短生存期对象和长生存期对象之间的缓冲区。

**第 2 代**。 这一代包含长生存期对象。 长生存期对象的一个示例是服务器应用程序中的一个包含在进程期间处于活动状态的静态数据的对象

垃圾回收中未回收的对象也称为幸存者，并会被提升到下一代：

- 第 0 代垃圾回收中未被回收的对象将会升级至第 1 代。
- 第 1 代垃圾回收中未被回收的对象将会升级至第 2 代。
- 第 2 代垃圾回收中未被回收的对象将仍保留在第 2 代。

### 垃圾回收过程中发生的情况

垃圾回收分为以下几个阶段：

- 标记阶段，找到并创建所有活动对象的列表。

- 重定位阶段，用于更新对将要压缩的对象的引用。

- 压缩阶段，用于回收由死对象占用的空间，并压缩幸存的对象。 压缩阶段将垃圾回收中幸存下来的对象移至段中时间较早的一端。

  因为第 2 代回收可以占用多个段，所以可以将已提升到第 2 代中的对象移动到时间较早的段中。 可以将第 1 代幸存者和第 2 代幸存者都移动到不同的段，因为它们已被提升到第 2 代。

  通常，由于复制大型对象会造成性能代偿，因此不会压缩大型对象堆 (LOH)。 但是，在 .NET Core 和 .NET Framework 4.5.1 及更高版本中，可以根据需要使用 [GCSettings.LargeObjectHeapCompactionMode](https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.gcsettings.largeobjectheapcompactionmode) 属性按需压缩大型对象堆。 此外，当通过指定以下任一项设置硬限制时，将自动压缩 LOH：

  - 针对容器的内存限制。
  - [GCHeapHardLimit](https://docs.microsoft.com/zh-cn/dotnet/core/run-time-config/garbage-collector#heap-limit) 或 [GCHeapHardLimitPercent](https://docs.microsoft.com/zh-cn/dotnet/core/run-time-config/garbage-collector#heap-limit-percent) 运行时配置选项。

垃圾回收器使用以下信息来确定对象是否为活动对象：

- **堆栈根**。 由实时 (JIT) 编译器和堆栈查看器提供的堆栈变量。 JIT 优化可以延长或缩短报告给垃圾回收器的堆栈变量内的代码的区域。
- **垃圾回收句柄**。 指向托管对象且可由用户代码或公共语言运行时分配的句柄。
- **静态数据**。 应用程序域中可能引用其他对象的静态对象。 每个应用程序域都会跟踪其静态对象。

**<u>*在垃圾回收启动之前，除了触发垃圾回收的线程以外的所有托管线程均会挂起。*</u>**

### 强引用与弱引用

如果应用程序的代码可以访问一个正由该程序使用的对象，垃圾回收器就不能回收该对象， 那么，就认为应用程序对该对象具有强引用。
<u>弱引用允许应用程序访问对象，同时也允许垃圾回收器收集相应的对象。</u>如果不存在强引用，则弱引用的有限期只限于收集对象前的一个不确定的时间段。 使用弱引用时，应用程序仍可对该对象进行强引用，这样做可防止该对象被收集。 **<u>*但始终存在这样的风险：垃圾回收器在重新建立强引用之前先处理该对象。*</u>**

占用大量内存，**<u>*但通过垃圾回收功能回收以后很容易重新创建的对象*</u>**特别适合使用弱引用。



弱引用是使用WeakReference类创建的。使用构造函数，可以传递强引用。示例代码创建了一个DataObject，并传递构造函数返回的引用。在使用WeakReference时，可以检查IsAlive属性。再次使用该对象时，WeakReference的Target属性就返回一个强引用。如果属性返回的值不是null，就可以使用强引用。因为对象可能在任意时刻被回收，所以在引用该对象前必须确认它存在。成功检索强引用后，可以通过正常方式使用它，现在它不能被垃圾回收，因为它有一个强引用：

```C#
// Instantiate a weak reference to MathTest object 
var myWeakReference = new WeakReference(new DataObject()); 
if (myWeakReference.IsAlive) { 
    DataObject strongReference = myWeakReference.Target as DataObject; 
    if (strongReference ! = null) { 
        // use the strongReference 
    } 
} 
else { 
    // reference not available 
}
```

## 4.4 处理非托管堆的资源



垃圾回收器的出现意味着，通常不需要担心不再需要的对象，只要让这些对象的所有引用都超出作用域，并允许垃圾回收器在需要时释放内存即可。但是，垃圾回收器不知道如何释放非托管的资源（例如，文件句柄、网络连接和数据库连接）。托管类在封装对非托管资源的直接或间接引用时，需要制定专门的规则，确保非托管的资源在回收类的一个实例时释放。

在定义一个类时，可以使用两种机制来自动释放非托管的资源。这些机制常常放在一起实现，因为每种机制都为问题提供了略为不同的解决方法。这两种机制是： 

**<u>*● 声明一个析构函数（或终结器），作为类的一个成员*</u>** 

**<u>*● 在类中实现System.IDisposable接口*</u>**

### 析构函数

C#编译器在编译析构函数时，它会隐式地把析构函数的代码编译为等价于重写Finalize（）方法的代码，从而确保执行父类的Finalize（）方法。下面列出的C#代码等价于编译器为～MyClass（）析构函数生成的IL：

```C#
protected override void Finalize() { 
    try { 
    	// Finalizer implementation
	} finally { base.Finalize(); } 
}
```



有经验的C++开发人员大量使用了析构函数，有时不仅用于清理资源，还提供调试信息或执行其他任务。C#析构函数要比C++析构函数的使用少得多。与C++析构函数相比，**<u>*C#析构函数的问题是它们的不确定性*</u>**。在销毁C++对象时，其析构函数会立即运行。**<u>*但由于使用C#时垃圾回收器的工作方式，无法确定C#对象的析构函数何时执行*</u>**。所以，**<u>*不能在析构函数中放置需要在某一时刻运行的代码，也不应寄望于析构函数会以特定顺序对不同类的实例调用*</u>**。<u>***如果对象占用了宝贵而重要的资源，应尽快释放这些资源，此时就不能等待垃圾回收器来释放了。***</u>

**<u>*因为垃圾回收器启动需要条件，要满足这些条件才能开始垃圾回收。*</u>** 

另一个问题是C**<u>*#析构函数的实现会延迟对象最终从内存中删除的时间*</u>**。**<u>*没有析构函数的对象会在垃圾回收器的一次处理中从内存中删除，但有析构函数的对象需要两次处理才能销毁*</u>**：第一次调用析构函数时，没有删除对象，第二次调用才真正删除对象。

**<u>*另外，运行库使用一个线程来执行所有对象的Finalize（）方法。如果频繁使用析构函数，而且使用它们执行长时间的清理任务，对性能的影响就会非常显著。*</u>**

### IDisposable接口

在C#中，推荐使用System.IDisposable接口替代析构函数。IDisposable接口定义了一种模式（具有语言级的支持），该模式为释放非托管的资源提供了确定的机制，并避免产生析构函数固有的与垃圾回收器相关的问题。

IDisposable接口声明了一个Dispose（）方法，它不带参数，返回void。MyClass类的Dispose（）方法的实现代码如下： 

```C#
class MyClass: IDisposable { 
    public void Dispose() { 
        // implementation 
    } 
}
```

Dispose（）方法的实现代码显式地释放由对象直接使用的所有非托管资源，并在所有也实现IDisposable接口的封装对象上调用Dispose（）方法。这样，Dispose（）方法为何时释放非托管资源提供了精确的控制。

可能会出现异常，更好的写法：

```C#
ResourceGobbler theInstance = null; 
try { 
    theInstance = new ResourceGobbler(); 
    // do your processing 
} 
finally { theInstance? .Dispose(); }
```

**<u>*在 try/finally 形式中没有单独对出现异常时处理的代码，finally 语句是无论 try 中的语句是否正确执行都会执行的语句。*</u>**

使用try/finally，即使在处理过程中出现了异常，也可以确保总是在theInstance上调用Dispose（）方法，总是释放theInstance使用的任意资源。但是，如果总是要重复这样的结构，代码就很容易被混淆。C#提供了一种语法，可以确保在实现IDisposable接口的对象的引用超出作用域时，在该对象上自动调用Dispose（）方法。该语法使用了using关键字来完成此工作——该关键字在完全不同的环境下，它与名称空间没有关系。下面的代码生成与try块等价的IL代码：

```C#
using (var theInstance = new ResourceGobbler()) { 
    // do your processing 
}
```

*<u>using语句的后面是一对圆括号，其中是引用变量的声明和实例化，该语句使变量的作用域限定在随后的语句块中。**另外，在变量超出作用域时，即使出现异常，也会自动调用其Dispose（）方法。**</u>*



● 利用运行库强制执行的析构函数，但析构函数的执行是不确定的，而且，由于垃圾回收器的工作方式，它会给运行库增加不可接受的系统开销。 

● IDisposable接口提供了一种机制，该机制允许类的用户控制释放资源的时间，但需要确保调用Dispose（）方法。
如果创建了终结器，就应该实现IDisposable接口。假定大多数程序员都能正确调用Dispose（）方法，同时把实现析构函数作为一种安全机制，以防没有调用Dispose（）方法。下面是一个双重实现的例子：

```C#
using System; 
public class ResourceHolder: IDisposable { 
    private bool _isDisposed = false; 
    public void Dispose() { 
        Dispose(true); 
        GC.SuppressFinalize(this); 
   	} 
    protected virtual void Dispose(bool disposing) {
        if (! _isDisposed) { 
            if (disposing) { 
                // Cleanup managed objects by calling their Dispose() methods. 
            } 
            // Cleanup unmanaged objects 
        } 
        _isDisposed = true; 
    } 
    ～ResourceHolder() { 
        Dispose (false); 
    } 
    public void SomeMethod() { 
        // Ensure object not already disposed before execution of any method 
        if(_isDisposed) { 
            throw new ObjectDisposedException("ResourceHolder"); 
        } 
        // method implementation… 
    } 
}
```

传递给Dispose（bool）方法的参数表示Dispose（bool）方法是由析构函数调用，还是由IDisposable.Dispose（）方法调用——Dispose（bool）方法不应从代码的其他地方调用，其原因是： 

● 如果使用者调用IDisposable.Dispose（）方法，该使用者就指定应清理所有与该对象相关的资源，包括托管和非托管的资源。 
● 如果调用了析构函数，原则上所有的资源仍需要清理。**<u>*但是在这种情况下，析构函数必须由垃圾回收器调用，而且用户不应试图访问其他托管的对象，因为我们不再能确定它们的状态了*</u>**。**<u>*在这种情况下，最好清理已知的非托管资源，希望任何引用的托管对象还有析构函数，这些析构函数执行自己的清理过程。*</u>**

最后，IDisposable.Dispose（）方法包含一个对System.GC.SuppressFinalize（）方法的调用。GC类表示垃圾回收器，SuppressFinalize（）方法则告诉垃圾回收器有一个类不再需要调用其析构函数了。**<u>*因为Dispose（）方法已经完成了所有需要的清理工作，所以析构函数不需要做任何工作。调用SuppressFinalize（）方法就意味着垃圾回收器认为这个对象根本没有析构函数。*</u>**

## 4.5 IDisposable和终结器的规则

学习了终结器和IDisposable接口后，就已经了解了Dispose模式和使用这些构造的规则。因为释放资源是托管代码的一个重要方面，下面总结如下规则：

● 如果类定义了实现IDisposable的成员，该类也应该实现IDisposable。 
● 实现IDisposable并不意味着也应该实现一个终结器。终结器会带来额外的开销，因为它需要创建一个对象，释放该对象的内存，需要GC的额外处理。只在需要时才应该实现终结器，例如，发布本机资源。要释放本机资源，就需要终结器。
● 如果实现了终结器，也应该实现IDisposable接口。这样，本机资源可以早些释放，而不仅是在GC找出被占用的资源时，才释放资源。 
● 在终结器的实现代码中，不能访问已终结的对象了。终结器的执行顺序是没有保证的。 
● 如果所使用的一个对象实现了IDisposable接口，就在不再需要对象时调用Dispose方法。如果在方法中使用这个对象，using语句比较方便。如果对象是类的一个成员，就让类也实现IDisposable。

## 4.6 不安全代码

用unsafe关键字编写不安全的代码，里面可以使用指针自己来管理内存，详略。

## 4.7 平台调用

并不是Windows API调用的所有特性都可用于.NET Framework。旧的Windows API调用是这样，Windows 10或Windows Server 2016中的新功能也是这样。

也许开发人员会编写一些DLL，导出非托管的方法，在C#中使用它们。 要重用一个非托管库，其中不包含COM对象，只包含导出的功能，就可以使用平台调用（P /Invoke）。有了P / Invoke, CLR会加载DLL，其中包含应调用的函数，并编组参数。

使用方法：

要使用非托管函数，首先必须确定导出的函数名。为此，可以使用dumpbin工具和/exports选项。例如，命令：

```
dumpbin /exports c:\windows\system32\kernel32.dll | more
```

这个命令列出kernel32.dll中所有导出的函数。这个示例使用Windows API函数CreateHardLink来创建到现有文件的硬链接。使用此API调用，可以用几个文件名引用相同的文件，只要文件名在一个硬盘上即可。这个API调用不能用于.NET Framework 4.5.1，因此必须使用平台调用。

为了调用本机函数，必须定义一个参数数量相同的C#外部方法，用非托管方法定义的参数类型必须用托管代码映射类型。

**<u>*这个定义必须映射到.NET数据类型上。非托管代码的返回类型是BOOL；它仅映射到bool数据类型。LPCTSTR定义了一个指向const字符串的long指针。Windows API给数据类型使用Hungarian命名约定。LP是一个long指针，C是一个常量，STR是以null结尾的字符串。T把类型标志为泛型类型，根据编译器设置为32还是64位，该类型解析为LPCSTR（ANSI字符串）或LPWSTR（宽Unicode字符串）。C字符串映射到.NET类型为String。LPSECURITY_ATTRIBUTES是一个long指针，指向SECURITY_ATTRIBUTES类型的结构。因为可以把NULL传递给这个参数，所以把这种类型映射到IntPtr是可行的。*</u>**该方法的

**<u>*C#声明必须用extern修饰符标记，因为在C#代码中，这个方法没有实现代码。相反，该方法的实现代码在DLL kernel32.dll中，它用属性[DllImport]引用。*</u>**

**<u>*.NET声明CreateHardLink的返回类型是bool，本机方法CreateHardLink返回一个布尔值，所以需要一些额外的澄清。因为C++有不同的Boolean数据类型（例如，本机bool和Windows定义的BOOL有不同的值），所以特性[MarshalAs]指定.NET类型bool应该映射为哪个本机类型*</u>**：

eg:

```C#
[DllImport("kernel32.dll", SetLastError="true", EntryPoint="CreateHardLink", CharSet=CharSet.Unicode)] [return: MarshalAs(UnmanagedType.Bool)] 
public static extern bool CreateHardLink(string newFileName, string existingFilename, IntPtr securityAttributes);
```

| DLLIMPORT属性或字段 | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| EntryPoint          | 可以给函数的C#声明指定与非托管库不同的名称。非托管库中方法的名称在EntryPoint字段中定义 |
| CallingConvention   | 根据编译器或用来编译非托管函数的编译器设置，可以使用不同的调用约定。调用约定定义了如何处理参数，把它们放在堆栈的什么地方。可以设置一个可枚举的值，来定义调用约定。Windows API在Windows操作系统上通常使用StdCall调用约定，在Windows CE上使用Cdecl调用约定。把值设置为CallingConvention.Winapi，可让Windows API用于Windows和Windows CE环境 |
| CharSet             | 字符串参数可以是ANSI或Unicode。通过CharSet设置，可以定义字符串的管理方式。用CharSet枚举定义的值有Ansi、Unicode和Auto.CharSet。Auto在Windows NT平台上使用Unicode，在微软的旧操作系统上使用ANSI |
| SetLastError        | 如果非托管函数使用Windows API SetLastError设置一个错误，就可以把SetLastError字段设置为true。这样，就可以使用Marshal. GetLastWin32Error读取后面的错误号 |
|                     |                                                              |

# 5. 泛型

## 5.1 泛型及其相关概念

### 5.1.1 泛型概念及其优缺点

Language，中间语言）代码紧密地集成。有了泛型（Generic），就可以创建独立于被包含类型的类和方法。我们不必给不同的类型编写功能相同的许多方法或类，只创建一个方法或类即可。

另一个减少代码的选项是使用Object类，但使用派生自Object类的类型进行传递不是**<u>*类型安全*</u>**的。泛型类使用泛型类型，并可以根据需要用特定的类型替换泛型类型。这就保证了类型安全性：如果某个类型不支持泛型类，编译器就会出现错误。

**<u>*泛型不仅限于类，还可以用于接口和方法，委托。*</u>**



泛型不仅存在于C#中，其他语言中有类似的概念。**<u>*例如，C++模板就与泛型相似。但是，C++模板和.NET泛型之间有一个很大的区别。对于C++模板，在用特定的类型实例化模板时，需要模板的源代码。相反，泛型不仅是C#语言的一种结构，而且是CLR（Common Language Runtime）定义的。所以，即使泛型类是在C#中定义的，也可以在Visual Basic中用一个特定的类型实例化该泛型。*</u>**

泛型的优缺点：
● 性能 
● 类型安全性 
● 二进制代码重用 
● 代码的扩展 
● 命名约定

### 5.1.2 装箱与拆箱

泛型的一个主要优点是性能。第11章介绍了System.Collections和System.Collections.Generic名称空间的泛型和非泛型集合类。对值类型使用非泛型集合类，在把值类型转换为引用类型，和把引用类型转换为值类型时，需要进行装箱和拆箱操作。

装箱：
值类型存储在栈上，引用类型存储在堆上。C#类是引用类型，结构是值类型。.NET很容易把值类型转换为引用类型，所以可以在需要对象（对象是引用类型）的任意地方使用值类型。例如，int可以赋予一个对象。**<u>*从值类型转换为引用类型称为装箱。*</u>**<u>如果方法需要把一个对象作为参数，同时传递一个值类型，装箱操作就会自动进行</u>。另一方面，装箱的值类型可以使用拆箱操作转换为值类型。在拆箱时，需要使用类型强制转换运算符。

装箱：将值类型（如 int ，或自定义的值类型等）转换成 object 或者接口类型的一个过程。当 CLR 对值类型进行装箱时，会将该值包装为 System.Object 类型，再将包装后的对象存储在堆上。 拆箱就是从对象中提取对应的值类型的一个过程。

装箱是隐式的；拆箱必定是显式的。

[[C#\] C# 知识回顾 - 装箱与拆箱 - 反骨仔 - 博客园 (cnblogs.com)](https://www.cnblogs.com/liqingwen/p/6486332.html#:~:text=C%23 的装箱与拆箱 装箱：将值类型（如 int ，或自定义的值类型等）转换成 object,或者接口类型的一个过程。 当 CLR 对值类型进行装箱时，会将该值包装为 System.Object 类型，再将包装后的对象存储在堆上。)

## 5.2 泛型类的创建

模板如下：

```C#
public class LinkedListNode<T> { 
    public LinkedListNode(T value) { Value = value; } 
    public T Value { get; private set; } 
    public LinkedListNode<T> Next { get; internal set; } 
    public LinkedListNode<T> Prev { get; internal set; } 
}
public class LinkedList<T>: IEnumerable<T> { 
    public LinkedListNode<T> First { get; private set; } 
    public LinkedListNode<T> Last { get; private set; } 
    public LinkedListNode<T> AddLast(T node) { 
        var newNode = new LinkedListNode<T>(node); 
        if (First == null) { First = newNode; Last = First; } 
        else { LinkedListNode<T> previous = Last; 
              Last.Next = newNode; Last = newNode; 
              Last.Prev = previous; } return newNode; 
    } 
    public IEnumerator<T> GetEnumerator() { 
        LinkedListNode<T> current = First; 
        while (current != null) { 
            yield return current.Value; 
            current = current.Next; 
        } 
    } 
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator(); 
}
```

创建泛型类其他的一些关键字。

● 默认值 
● 约束 
● 继承 
● 静态成员

### 5.2.1 默认值 

default关键字根据上下文可以有多种含义。switch语句使用default定义默认情况。在泛型中，取决于泛型类型是引用类型还是值类型，泛型default将泛型类型初始化为null或0。
eg：

```C#
public T GetDocument() { 
    T doc = default(T); 
    lock (this) { 
        doc = documentQueue.Dequeue(); 
    } 
    return doc; 
}
```

### 5.2.2 约束

限制泛型类的设置。

```C#
public class MyClass<T> where T: IFoo, new() { 
    //...
}
```

   

| 约束              | 说明                                                  |
| ----------------- | ----------------------------------------------------- |
| where T : struct  | 对于结构约束，类型T必须是值类型                       |
| where T : class   | 类约束指定类型T必须是引用类型                         |
| where T : IFoo    | 指定类型T必须实现接口IFoo                             |
| where T : Foo     | 指定类型T必须派生自基类Foo                            |
| where T : new（） | 这是一个构造函数约束，指定类型T必须有一个默认构造函数 |
| where T1 : T2     | 这个约束也可以指定，类型T1派生自泛型类型T2            |
|                   |                                                       |

   **<u>*注意： 只能为默认构造函数定义构造函数约束，不能为其他构造函数定义构造函数约束。*</u>**

**<u>*注意： 在C#中，where子句的一个重要限制是，不能定义必须由泛型类型实现的运算符。运算符不能在接口中定义。在where子句中，只能定义基类、接口和默认构造函数。*</u>**

### 5.2.3 继承

前面创建的LinkedList<T>类实现了IEnumerable<T> 接口： 

```C#
public class LinkedList<T>: IEnumerable<T> { //... 泛型类型可以实现泛型接口，也可以派生自一个类。泛型类可以派生自泛型
}
```

泛型类型可以实现泛型接口，也可以派生自一个类。泛型类可以派生自泛型基类：

```C#
public class Base<T> { } 
public class Derived<T>: Base<T> { } 
```

**<u>*其要求是必须重复接口的泛型类型，或者必须指定基类的类型，如下例所示：*</u>**

```C#
public class Base<T> { } 
public class Derived<T>: Base<string> { }
```
 于是，派生类可以是泛型类或非泛型类。例如，可以定义一个抽象的泛型基类，它在派生类中用一个具体的类实现。这允许对特定类型执行特殊的操作：
```C#
public abstract class Calc<T> { 
	public abstract T Add(T x, T y); 
    public abstract T Sub(T x, T y); 
} 
public class IntCalc: Calc<int> { 
    public override int Add(int x, int y) => x + y; 
    public override int Sub(int x, int y) => x - y; 
}
```
 还可以创建一个部分的特殊操作，如从Query中派生StringQuery类，只定义一个泛型参数，如字符串TResult。要实例化StringQuery，只需要提供TRequest的类型： 

```C#
public class Query<TRequest, TResult> { } 
public StringQuery<TRequest> : Query<TRequest, string> { }
```

### 5.2.4 静态成员

泛型类的静态成员需要特别关注。**<u>*泛型类的静态成员只能在类的一个实例中共享。*</u>**

## 5.3 泛型接口

接口可以泛型。

例如：

```C#
public interface IComparable<in T> { int CompareTo(T other); }
```

### 5.3.1 协变和抗变

协变和抗变指对参数和返回值的类型进行转换。例如，可以给一个需要Shape参数的方法传送Rectangle参数吗？下面用示例说明这些扩展的优点。

**<u>*在.NET中，参数类型是协变的。假定有Shape和Rectangle类，Rectangle派生自Shape基类。声明Display（）方法是为了接受Shape类型的对象作为其参数：*</u>**

```C#
public void Display(Shape o) { }
```

**<u>*现在可以传递派生自Shape基类的任意对象。因为Rectangle派生自Shape，所以Rectangle满足Shape的所有要求，编译器接受这个方法调用。*</u>**

**<u>*方法的返回类型是抗变的。当方法返回一个Shape时，不能把它赋予Rectangle，因为Shape不一定总是Rectangle。*</u>**



**<u>*如果泛型类型用out关键字标注，泛型接口就是协变的。这也意味着返回类型只能是T。*</u>**

**<u>*如果泛型类型用in关键字标注，泛型接口就是抗变的。这样，接口只能把泛型类型T用作其方法的输入。*</u>**





## 5.4 泛型结构



**<u>*与类相似，结构也可以是泛型的。它们非常类似于泛型类，只是没有继承特性。*</u>**

实例：

```C#
public struct Nullable<T> where T: struct { 
        public Nullable(T value) { _hasValue = true; _value = value; } 
        private bool _hasValue; 
        public bool HasValue => _hasValue; 
        private T _value; 
        public T Value { get { if (! _hasValue) { throw new InvalidOperationException("no value"); } return _value; } } 
        //用户定义的强制类型转换操作符
        public static explicit operator T(Nullable<T> value) {
            System.Console.WriteLine("强制类型转换");
            return value.Value;
        }
        public static implicit operator Nullable<T>(T value){
            System.Console.WriteLine("隐式类型转换");
            return new Nullable<T>(value);
        } 
        public override string ToString() => ! HasValue ? string.Empty : _value.ToString(); 
    
    }
```

## 5.5 泛型方法

除了定义泛型类之外，还可以定义泛型方法。在泛型方法中，泛型类型用方法声明来定义。泛型方法可以在非泛型类中定义。

但是，因为C#编译器会通过调用Swap（）方法来获取参数的类型，所以不需要把泛型类型赋予方法调用。泛型方法可以像非泛型方法那样调用。

见例代码，泛型方法，可以省挺多事，还可以带约束，传递委托。

泛型方法重载：

**<u>*需要注意的是，所调用的方法是在编译期间而不是运行期间定义的。*</u>**

# 6 数组与元组

同一个类型的对个对象，就可以使用集合和数组。**<u>*C#用特殊的记号声明、初始化和使用数组，Array类在后台发挥作用，它为数组中的元素的排序和过滤提供了几个方法。使用枚举器，可以迭代数组中的所有元素。*</u>**
如果需要使用不同类型的多个对象，可以使用Tuple（元组）类型。

## 6.1 简单数组

C#中的数组。同类型的多个对象。数组可以存储指定的任何元素类型。

### 数组的声明

```C#
int[] myArray;
```

### 初始化

1.指定长度的默认初始化（值默认为0）

```C#
myArray = new int[4]
```

2.可以在声明数组时初始化数组的元素。 不需要长度说明符，因为可以根据初始化列表中的元素数量推断得出。

```C#
int[] array1 = new int[] { 1, 3, 5, 7, 9 };
```

3.在声明时初始化数组时，可以避免使用 `new` 表达式和数组类型，如以下代码所示。 这称为[隐式类型化数组](https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/arrays/implicitly-typed-arrays)：

```C#
int[] array2 = { 1, 3, 5, 7, 9 };
string[] weekDays2 = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
```
***注意： 在指定了数组的大小后，如果不复制数组中的所有元素，就不能重新设置数组的大小。如果事先不知道数组中应包含多少个元素，就可以使用集合。集合请参见第11章。（？）***

### 访问数组元素

数组只支持有整形参数的索引器。通过索引器传递元素编号，就可以访问数组。索引器总是以0开头，表示第一个元素。可以传递给索引器的最大值是元素个数减1，因为索引从0开始。

***注意： 如果使用错误的索引器值（大于数组的长度），就会抛出IndexOutOfRangeException类型的异常。***

### 使用引用类型

声明一个包含两个Person元素的数组与声明一个int数组类似： 

```C#
Person[] myPersons = new Person[2]; 
```

**<u>*但是必须注意，如果数组中的元素是引用类型，就必须为每个数组元素分配内存。若使用了数组中未分配内存的元素，就会抛出NullReferenceException类型的异常。*</u>**

与int类型一样，也可以对自定义类型使用数组初始化器：

```C#
Person[] myPersons2 = { 
    new Person { FirstName="Ayrton", LastName="Senna"}, 
    new Person { FirstName="Michael", LastName="Schumacher"} };
```

##  6.2 多维数组

一般数组（也称为一维数组）用一个整数来索引。多维数组用两个或多个整数来索引。

在C#中声明这个二维数组，需要在方括号中加上一个逗号。数组在初始化时应指定每一维的大小（也称为阶）。接着，就可以使用两个整数作为索引器来访问数组中的元素：

```C#
int[, ] twodim = new int[3, 3]; 
twodim[0, 0] = 1; twodim[0, 1] = 2; twodim[0, 2] = 3; twodim[1, 0] = 4; twodim[1, 1] = 5; twodim[1, 2] = 6; twodim[2, 0] = 7; twodim[2, 1] = 8; twodim[2, 2] = 9;
```

### 声明

形如：

```C#
int[, ] twodim = new int[3, 3];
```

### 初始化

形如：

```C#
int[, ] twodim = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
int[, , ] threedim = { { { 1, 2 }, { 3, 4 } }, { { 5, 6 }, { 7, 8 } }, { { 9, 10 }, { 11, 12 } } }; 
```

　 *<u>**注意（多维数组）： 使用数组初始化器时，必须初始化数组的每个元素，不能遗漏任何元素。**</u>*

## 6.3 锯齿数组

二维数组的大小对应于一个矩形，如对应的元素个数为3×3。而锯齿数组的大小设置比较灵活，在锯齿数组中，每一行都可以有不同的大小。

### 声明

形如：

```C#
int[][] twodim = new int[3][];
```

### 初始化

形如：

```C#
int[][] jagged = new int[3][]; 
jagged[0] = new int[2] { 1, 2 }; 
jagged[1] = new int[6] { 3, 4, 5, 6, 7, 8 }; 
jagged[2] = new int[3] { 9, 10, 11 };
```

## 6.4 Array类

***用方括号声明数组是C#中使用Array类的表示法。在后台使用C#语法，会创建一个派生自抽象基类Array的新类。***这样，就可以使用Array类为每个C#数组定义的方法和属性了。例如，前面就使用了Length属性，或者使用foreach语句迭代数组-其实这是使用了Array类中的GetEnumerator（）方法。

### 6.4.1 ArraySegment< T >

结构ArraySegment< T>表示数组的一段。如果需要使用不同的方法处理某个大型数组的不同部分，那么可以把相应的数组部分复制到各个方法中。此时，与创建多个数组相比，更有效的方法是使用一个数组，将整个数组传递给不同的方法。这些方法只使用数组的某个部分。方法的参数除了数组以外，还应包括数组内的偏移量以及该方法应该使用的元素数。这样一来，方法就需要至少3个参数。当使用数组段时，只需要一个参数就可以了。ArraySegment< T>结构包含了关于数组段的信息（偏移量和元素个数）。

注意： 数组段不复制原数组的元素，但原数组可以通过ArraySegment< T>访问。如果数组段中的元素改变了，这些变化就会反映到原数组中。

### 6.4.2 数组迭代器

在foreach语句中使用枚举，可以迭代集合中的元素，且无须知道集合中的元素个数。foreach语句使用了一个枚举器。图7-7显示了调用foreach方法的客户端和集合之间的关系。数组或集合实现带GetEumerator（）方法的IEumerable接口。GetEumerator（）方法返回一个实现IEumerator接口的枚举。接着，foreach语句就可以使用IEumerable接口迭代集合了。



foreach语句会解析为下面的代码段。首先，调用GetEnumerator（）方法，获得数组的一个枚举器。在while循环中——只要MoveNext（）返回true——就用Current属性访问数组中的元素： 

```C#

foreach (var p in persons) { WriteLine(p); }
//等价于
IEnumerator<Person> enumerator = persons.GetEnumerator(); 
while (enumerator.MoveNext()) { 
    Person p = enumerator.Current; 
    WriteLine(p); 
}
```

### 6.4.3　yield语句

yield return语句返回集合的一个元素，并移动到下一个元素上。yield break可停止迭代。

示例：

```C#
using System; 
using System.Collections; 
namespace Wrox.ProCSharp.Arrays { 
    public class HelloCollection { 
        public IEnumerator<string> GetEnumerator() { 
            yield return "Hello"; 
            yield return "World"; 
        } 
    }
}
```





public class HelloCollection { public IEnumerator GetEnumerator() => new Enumerator(0); public class Enumerator:IEnumerator<string>, IEnumerator, IDisposable { private int _state; private string _current; public Enumerator(int state) { _state = state; } bool System.Collections.IEnumerator.MoveNext() { switch (state) { case 0: _current = "Hello"; _state = 1; return true; case 1: _current = "World"; _state = 2; return true; case 2: break; } return false; } void System.Collections.IEnumerator.Reset() { throw new NotSupportedException(); } string System.Collections.Generic.IEnumerator<string>.Current => current; object System.Collections.IEnumerator.Current => current; void IDisposable.Dispose() { } } }
### 6.4.1 Array的创建

Array是个抽象类，不能使用构造函数来创建。可以使用CreateInstance来创建数组。如果事先不知道元素的类型，该方法就有用了。

```C#
Array intArray1 = Array.CreateInstance(typeof(int), 5); 
for (int i = 0; i < 5; i++) { 
    intArray1.SetValue(33, i); 
} 
for (int i = 0; i < 5; i++) { 
    WriteLine(intArray1.GetValue(i)); 
}
```

CreateInstance（）方法有许多重载版本，可以创建多维数组和不基于0的数组。例子略。

### 6.4.2 Array的复制

因为数组是引用类型，所以将一个数组变量赋予另一个数组变量，就会得到两个引用同一数组的变量。而复制数组，会使数组实现ICloneable接口。**<u>*这个接口定义的Clone（）方法会创建数组的浅表副本。*</u>**



*<u>**如果数组的元素是值类型，就会开辟新空间存储值。**</u>*

*<u>**如果数组的元素是引用类型，就会开辟新空间存储引用。**</u>*

*<u>**注意： 如果需要包含引用类型的数组的深层副本，就必须迭代数组并创建新对象。**</u>*

除了使用Clone（）方法之外，还可以使用Array.Copy（）方法创建浅表副本。但Clone（）方法和Copy（）方法有一个重要区别：Clone（）方法会创建一个新数组，而Copy（）方法必须传递阶数相同且有足够元素的已有数组。

### 6.4.3 Array的排序

Array类使用Quicksort算法对数组中的元素进行排序。Sort（）方法需要数组中的元素实现IComparable接口。因为简单类型（如System.String和System.Int32）实现IComparable接口，所以可以对包含这些类型的元素排序。

注意： Array类还提供了Sort方法，它需要将一个委托作为参数。这个参数可以传递给方法，从而比较两个对象，而不需要依赖IComparable或IComparer接口。第9章将介绍如何使用委托。

## 6.5 数组作为参数

数组可以作为参数传递给方法，也可以从方法返回。要返回一个数组，只需要把数组声明为返回类型。

```C#
static void DisplayPersons(Person[] persons) { //...
}
static Person[] GetPersons(){ //...
}
```

### 6.5.1 数组协变

数组支持协变。这表示数组可以声明为基类，其派生类型的元素可以赋予数组元素。

例如，可以声明一个object[]类型的参数，给它传递一个Person[]： 

```C#
static void DisplayArray(object[] data) { //… 
}
```

　 **<u>*注意： 数组协变只能用于引用类型，不能用于值类型。另外，数组协变有一个问题，它只能通过运行时异常来解决。如果把Person数组赋予object数组，object数组就可以使用派生自object的任何元素。例如，编译器允许把字符串传递给数组元素。但因为object数组引用Person数组，所以会出现一个运行时异常ArrayTypeMismatchException。*</u>**

**<u>*？？？？？？？？查查英文原书，这段翻译感觉问题很大*</u>**

### 6.5.2 ArraySegment<T>





# 7 运算符



## 7.1 值得注意的两个操作符

nameof是新的C# 6运算符。该运算符接受一个符号、属性或方法，并返回其名称。

typeof运算符返回一个表示特定类型的System.Type对象。例如，typeof（string）返回表示System.String类型的Type对象。在使用反射技术动态地查找对象的相关信息时，这个运算符很有用。第16章将介绍反射。

## 7.2 比较对象的相等性

System.Object定义了3个不同的方法来比较对象的相等性：ReferenceEquals（）和两个版本的Equals（）。再加上比较运算符（==），实际上有4种比较相等性的方法。这些方法有一些细微的区别，下面就介绍它们。

### 7.2.1 ReferenceEquals()

ReferenceEquals（）是一个静态方法，其测试两个引用是否指向类的同一个实例，特别是两个引用是否包含内存中的相同地址。作为静态方法，它不能重写，所以System.Object的实现代码保持不变。如果提供的两个引用指向同一个对象实例，则ReferenceEquals（）总是返回true；否则就返回false。但是，它认为null等于null：

```C#
SomeClass x, y; 
x = new SomeClass(); 
y = new SomeClass(); 
bool B1 = ReferenceEquals(null, null); 
// returns true bool B2 = ReferenceEquals(null, x); 
// returns false bool B3 = ReferenceEquals(x, y); 
// returns false because x and y 
// point to different objects
```

### 7.2.2 Equals（）虚方法

Equals（）虚版本的System.Object实现代码也可以**<u>*比较引用*</u>**。**<u>*但因为这是虚方法，所以可以在自己的类中重写它，从而按值来比较对象。特别是如果希望类的实例用作字典中的键，就需要重写这个方法，以比较相关值。否则，根据重写Object.GetHashCode（）的方式，包含对象的字典类要么不工作，要么工作的效率非常低*</u>**。

在重写Equals（）方法时要注意，重写的代码不应抛出异常。同理，这是因为如果抛出异常，字典类就会出问题，一些在内部调用这个方法的.NET基类也可能出问题。

### 7.2.3 静态的Equals（）方法 

静态的Equals（）方法 Equals（）的静态版本与其虚实例版本的作用相同，其区别是静态版本带有两个参数，并对它们进行相等性比较。这个方法可以处理两个对象中有一个是null的情况；因此，如果一个对象可能是null，这个方法就可以抛出异常，提供额外的保护。<u>***静态重载版本首先要检查传递给它的引用是否为null。如果它们都是null，就返回true（因为null与null相等）。***</u>如果只有一个引用是null，它就返回false。**<u>*如果两个引用实际上引用了某个对象，它就调用Equals（）的虚实例版本。这表示在重写Equals（）的实例版本时，其效果相当于也重写了静态版本。*</u>**

默认的静态equals()是比较引用的。

### 7.2.4  比较运算符（==）

最好将比较运算符看作**<u>*严格的值比较和严格的引用比较之间的中间选项*</u>**。在大多数情况下，下面的代码表示正在比较引用：

```C#
bool b = (x == y); // x, y object references
```

但是，如果把一些类看作值，其含义就会比较直观，这是可以接受的方法。在这些情况下，最好重写比较运算符，以执行值的比较。后面将讨论运算符的重载，但一个明显例子是System.String类，Microsoft重写了这个运算符，以比较字符串的内容，而不是比较它们的引用。

## 7.3 比较值类型的相等性

在比较值类型的相等性时，采用与引用类型相同的规则：ReferenceEquals（）用于比较引用，Equals（）用于比较值，比较运算符可以看作一个中间项。

但最大的区别是值类型需要装箱，才能把它们转换为引用，进而才能对它们执行方法。另外，Microsoft已经在System.ValueType类中重载了实例方法Equals（），以便对值类型进行合适的相等性测试。

如果调用sA.Equals（sB），其中sA和sB是某个结构的实例，则根据sA和sB是否在其所有的字段中包含相同的值而返回true或false。另一方面，在默认情况下，不能对自己的结构重载“==”运算符。在表达式中使用（sA == sB）会导致一个编译错误，除非在代码中为存在问题的结构提供了“==”的重载版本。

另外，ReferenceEquals（）在应用于值类型时总是返回false，因为为了调用这个方法，值类型需要装箱到对象中。即使编写下面的代码： 

```C#
bool b = ReferenceEquals(v, v); // v is a variable of some value type
```

也会返回false，因为在转换每个参数时，v都会被单独装箱，这意味着会得到不同的引用。**<u>*出于上述原因，调用ReferenceEquals（）来比较值类型实际上没有什么意义，所以不能调用它。*</u>** 

**<u>*尽管System.ValueType提供的Equals（）默认重写版本肯定足以应付绝大多数自定义的结构，但仍可以针对自己的结构再次重写它，以提高性能。另外，如果值类型包含作为字段的引用类型，就需要重写Equals（），以便为这些字段提供合适的语义，因为Equals（）的默认重写版本仅比较它们的地址。*</u>**

## 7.4 运算符重载

运算符重载的声明方式与静态方法基本相同，但operator关键字告诉编译器，它实际上是一个自定义的运算符重载，后面是相关运算符的实际符号，返回类型是在使用这个运算符时获得的类型。

**<u>*C#要求所有的运算符重载都声明为public和static，这表示它们与其类或结构相关联，而不是与某个特定实例相关联，所以运算符重载的代码体不能访问非静态类成员，也不能访问this标识符；这是可行的，因为参数提供了运算符执行其任务所需要知道的所有输入数据。*</u>**

**<u>*虽然“+=”一般计为单个运算符，但实际上它对应的操作分为两步：相加和赋值。与C++语言不同，C#不允许重载“=”运算符；但如果重载“+”运算符，编译器就会自动使用“+”运算符的重载来执行“+=”运算符的操作。-=、*=、/=和&=等所有赋值运算符也遵循此原则。*</u>**

### 7.4.1 比较运算符

6个比较运算符

● ==和！=

● > 和 <

 ● >=和<=



C#语言要求成对重载比较运算符。即，如果重载了“==”，也就必须重载“! =”；否则会产生编译器错误。**<u>*另外，比较运算符必须返回布尔类型的值。*</u>**这是它们与算术运算符的根本区别。例如，两个数相加或相减的结果理论上取决于这些数值的类型。前面提到，两个Vector对象的相乘会得到一个标量。另一个例子是.NET基类System.DateTime。两个DateTime实例相减，得到的结果不是一个DateTime，而是一个System.TimeSpan实例。相比之下，如果比较运算得到的不是布尔类型的值，就没有任何意义。

**<u>*浅度比较是比较对象是否指向内存中的同一个位置，而深度比较是比较对象的值和属性是否相等。应根据具体情况进行相等性检查，从而有助于确定要验证的结果。*</u>**

对于内嵌的类，需要特别注意。

**<u>*不要通过调用从System.Object中继承的Equals（）方法的实例版本来重载比较运算符。如果这么做，在objA是null时判断（objA==objB），就会产生一个异常，因为.NET运行库会试图判断null.Equals（objB）。采用其他方法（重写Equals（）方法以调用比较运算符）比较安全。*</u>**



重写Equals和GetHashCode方法这些方法，应该总是在重写==运算符时进行重写，否则编译器会报错。？（这句话无法理解，实验证明，即便不重载也没报错（值类型vector(结构体），倘若时vector类呢，引用类型），对于引用类型而言，需要重载，不然会报黄色警告，并且equals与==的判断会不一致，equals仅仅判断是否引用了同一对象。

### 7.4.2 可以重载的运算符

并不是所有的运算符都可以重载。可以重载的运算符如表所示

| 类别               | 运算符                                  | 限制                                                         |
| ------------------ | --------------------------------------- | ------------------------------------------------------------ |
| 算术二元运算符     | +、*、/、-、%                           | 无                                                           |
| 算术一元运算符     | +、-、++、--                            | 无                                                           |
| 按位二元运算符     | &、^、<< 、 >>                          | 无                                                           |
| 按位一元运算符     | !、～、true、false                      | true和false运算符必须成对重载                                |
| 比较运算符         | ==、! =、>=、< 、 <=、>                 | 比较运算符必须成对重载                                       |
| 赋值运算符         | +=、-=、*=、/=、>>=、<<=、%=、&=、=、^= | 不能显式地重载这些运算符，在重写单个运算符（如+、-、%等）时，它们会被隐式地重写 |
| 索引运算符         | []                                      | 不能直接重载索引运算符。第2章介绍的索引器成员类型允许在类和结构上支持索引运算符 |
| 类型强制转换运算符 | （）                                    | 不能直接重载类型强制转换运算符。用户定义的类型强制转换（本章后面介绍）允许定义定制的类型强制转换行为 |

**<u>*注意： 为什么要重载true和false操作符？有一个很好的原因：根据所使用的技术或框架，哪些整数值代表true或false是不同的。在许多技术中，0是false,1是true；其他技术把非0值定义为true，还有一些技术把-1定义为false。*</u>**

### 7.4.3  实现自定义的索引运算符

自定义索引器不能使用运算符重载语法来实现，但是它们可以用与属性非常相似的语法来实现。

略，形如：

```C#
public class Person { 
    public DateTime Birthday { get; } 
    public string FirstName { get; } 
    public string LastName { get; } 
    public Person(string firstName, string lastName, DateTime birthDay) { 
        FirstName = firstName; 
        LastName = lastName; 
        Birthday = birthDay; 
    } 
    public override string ToString() => $"{FirstName} {LastName}"; 
}

public class PersonCollection { 
    private Person[] _people; 
    public PersonCollection(params Person[] people) { 
        _people =people.ToArray();
    } 

    public Person this[int index] { get { return _people[index]; } set { _people[index] = value; } }
    //不仅仅可以用int作为索引，DataTime也行
    public IEnumerable<Person> this[DateTime birthDay] { get { return _people.Where(p => p.Birthday == birthDay); } }

}
```

**<u>*对于索引器，不能仅定义int类型作为索引类型。任何类型都是有效的。*</u>**

### 7.4.4 实现用户自定义的类型强制转换

本章前面（见8.3.1节中关于显式转换的部分）介绍了如何在预定义的数据类型之间转换数值，这通过类型强制转换过程来完成。**<u>*C#允许进行两种不同类型的强制转换：隐式强制转换和显式强制转换。本节将讨论这两种类型的强制转换。*</u>**

显式强制转换要在代码中显式地标记强制转换，即应该在圆括号中写出目标数据类型：

```C#
int i = 3; long l = i; // implicit 
short s = (short)i; // explicit
```

**<u>*对于预定义的数据类型，当类型强制转换可能失败或丢失某些数据时，需要显式强制转换*</u>**。例如：

● 把int转换为short时，short可能不够大，不能包含对应int的数值。 

● 把有符号的数据类型转换为无符号的数据类型时，如果有符号的变量包含一个负值，就会得到不正确的结果。 

● 把浮点数转换为整数数据类型时，数字的小数部分会丢失。

 ● 把可空类型转换为非可空类型时，null值会导致异常。

C#允许定义自己的数据类型（结构和类），这意味着需要某些工具支持在自定义的数据类型之间进行类型强制转换。**<u>*方法是把类型强制转换运算符定义为相关类的一个成员运算符。*</u>**类型强制转换运算符必须标记为隐式或显式，以说明希望如何使用它。我们应遵循与预定义的类型强制转换相同的指导原则；***如果知道无论在源变量中存储什么值，类型强制转换总是安全的，就可以把它定义为隐式强制转换。然而，如果某些数值可能会出错，如丢失数据或抛出异常，就应把数据类型转换定义为显式强制转换。***(指导原则)

格式：

```C#
public static implicit operator float (Currency value) { // processing }
```

运算符的返回类型定义了类型强制转换操作的目标类型，它有一个参数，即要转换的源对象。这里定义的类型强制转换可以隐式地把Currency型的值转换为float型。**<u>*注意，如果数据类型转换声明为隐式，编译器就可以隐式或显式地使用这个转换。如果数据类型转换声明为显式，编译器就只能显式地使用它。*</u>**与其他运算符重载一样，类型强制转换必须同时声明为public和static。

**<u>*注意： C++开发人员应注意，这种情况与C++中的用法不同，在C++中，类型强制转换用于类的实例成员。*</u>**

# 8 委托

## 8.1 声明委托

在C#中使用一个类时，分两个阶段操作。首先，需要定义这个类，即告诉编译器这个类由什么字段和方法组成。然后（除非只使用静态方法），实例化该类的一个对象。使用委托时，也需要经过这两个步骤。***首先必须定义要使用的委托，对于委托，定义它就是告诉编译器这种类型的委托表示哪种类型的方法。***  <u>然后，必须创建该委托的一个或多个实例。</u><u>编译器在后台将创建表示该委托的一个类。</u>声明委托的语法如下：

```c#
delegate void IntMethodInvoker(int x);
```

在这个示例中，声明了一个委托IntMethodInvoker，并指定该委托的每个实例都可以包含一个方法的引用，该方法带有一个int参数，并返回void。<u>理解委托的一个要点是它们的类型安全性非常高。在定义委托时，必须给出它所表示的方法的签名和返回类型等全部细节。</u>

其语法类似于方法的定义，但没有方法主体，且定义的前面要加上关键字delegate。因为定义委托基本上是定义一个新类，所以可以在定义类的任何相同地方定义委托。也就是说，可以在另一个类的内部定义委托，也可以在任何类的外部定义，还可以在名称空间中把委托定义为顶层对象。根据定义的可见性和委托的作用域，可以在委托的定义上应用任意常见的访问修饰符：public、private、protected等。

注意： **<u>*实际上，“定义一个委托”是指“定义一个新类”。委托实现为派生自基类System. MulticastDelegate的类，System.MulticastDelegate又派生自基类System.Delegate。C#编译器能识别这个类，会使用其委托语法，因此我们不需要了解这个类的具体执行情况。这是C#与基类共同合作以使编程更易完成的另一个范例。*</u>**

## 8.2 使用委托

**<u>*为了减少输入量，在需要委托实例的每个位置可以只传送地址的名称。这称为委托推断。*</u>**只要编译器可以把委托实例解析为特定的类型，这个C#特性就是有效的。

```C#
private delegate string GetAString(); 
public static void testDelegate(){
    int x = 40; 
    int y = 50;
    GetAString firstStringMethod = new GetAString(x.ToString); 
    GetAString firstStringMethod1 = y.ToString;
    // With firstStringMethod initialized to x.ToString(),
    print($"String is {firstStringMethod()}"); 
    x = 50;
    print($"String is {firstStringMethod1()}"); 
    // the above statement is equivalent to saying 
    // Console.WriteLine($"String is {x.ToString()}"); }
}
```

　 **<u>*注意： 调用上述方法名时，输入形式不能为x.ToString（）（不要输入圆括号），也不能把它传送给委托变量。输入圆括号会调用一个方法，而调用x.ToString（）方法会返回一个不能赋予委托变量的字符串对象。只能把方法的地址赋予委托变量。*</u>**

**<u>*委托推断可以在需要委托实例的任何地方使用。委托推断也可以用于事件，因为事件基于委托（参见本章后面的内容）。 委托的一个特征是它们的类型是安全的，可以确保被调用的方法的签名是正确的。但有趣的是，它们不关心在什么类型的对象上调用该方法，甚至不考虑该方法是静态方法还是实例方法。*</u>**　 

注意： 给定委托的实例可以引用任何类型的任何对象上的实例方法或静态方法——只要方法的签名匹配委托的签名即可。

## 8.3 委托的使用示例(传递)

```C#
delegate double DoubleOp(double x);
public static void testDelegate3() { 
    DoubleOp[] operations = { MathOperations.MultiplyByTwo, MathOperations.Square }; 
    for (int i=0; i < operations.Length; i++) { 
        print($"Using operations[{i}]:"); 
        ProcessAndDisplayNumber(operations[i], 2.0); 
        ProcessAndDisplayNumber(operations[i], 7.94); 
        ProcessAndDisplayNumber(operations[i], 1.414);
        print("");
    } 
} 
static void ProcessAndDisplayNumber(DoubleOp action, double value) { 
    double result = action(value); 
    print($"Value is {value}, result of operation is {result}"); 
}
class MathOperations { 
        public static double MultiplyByTwo(double value) => value * 2; 
        public static double Square(double value) => value * value; 
}
```

## 8.4 泛型委托，Action< T > 和Func< T >委托

除了为每个参数和返回类型定义一个新委托类型之外，还可以使用Action<T>和Func<T>委托。**<u>*泛型Action<T>委托表示引用一个void返回类型的方法。*</u>**这个委托类存在不同的变体，可以传递至多16种不同的参数类型。**<u>*没有泛型参数的Action类可调用没有参数的方法。*</u>**    **<u>*Action< in T >调用带一个参数的方法，Action<in T1, in T2>调用带两个参数的方法，Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8>调用带8个参数的方法*</u>**。

Func< T >委托可以以类似的方式使用。**<u>*Func< T >允许调用带返回类型的方法。*</u>** 与Action< T >类似，Func< T >也定义了不同的变体，至多也可以传递16个参数类型和一个返回类型。**<u>*Func< out TResult >委托类型可以调用带返回类型且无参数的方法*</u>**， <u>Func<in T, out TResult>调用带一个参数的方法，Func<in T1, in T2, in T3, in T4, out TResult>调用带4个参数的方法。</u>

## 8.5 BubbleSorter示例

传递比较函数。匹配上函数类型即可。

```C#
static public void Sort<T>(IList<T> sortArray, Func<T, T, bool> comparison){
    bool swapped = true; 
    do { 
        swapped = false; 
        for (int i = 0; i < sortArray.Count - 1; i++) { 
            if (comparison(sortArray[i],sortArray[i+1]))
                // problem with this test 
            { 
                T temp = sortArray[i]; 
                sortArray[i] = sortArray[i + 1]; 
                sortArray[i + 1] = temp; 
                swapped = true; 
            } 
        } 
    } while (swapped);
}
```

## 8.6 多播委托

**<u>*前面使用的每个委托都只包含一个方法调用。调用委托的次数与调用方法的次数相同。如果要调用多个方法，就需要多次显式调用这个委托。但是，委托也可以包含多个方法。这种委托称为多播委托。如果调用多播委托，就可以按顺序连续调用多个方法。为此，委托的签名就必须返回void；否则，就只能得到委托调用的最后一个方法的结果。*</u>**

<u>*如果正在使用多播委托，就应知道对同一个委托，调用其方法链的顺序并未正式定义。因此应避免编写依赖于以特定顺序调用方法的代码。*</u>

**<u>*通过一个委托调用多个方法还可能导致一个更严重的问题。多播委托包含一个逐个调用的委托集合。如果通过委托调用的其中一个方法抛出一个异常，整个迭代就会停止。*</u>**

**<u>*在这种情况下，为了避免这个问题，应自己迭代方法列表。Delegate类定义GetInvocationList（）方法，它返回一个Delegate对象数组。现在可以使用这个委托调用与委托直接相关的方法，捕获异常，并继续下一次迭代：*</u>** 

```C#
static void Main() { 
    Action d1 = One; 
    d1 += Two; 
    Delegate[] delegates = d1.GetInvocationList(); 
    foreach (Action d in delegates) { 
        try { d(); } 
        catch (Exception) { 
            WriteLine("Exception caught"); 
        } 
    } 
}
```

## 8.7 匿名方法

到目前为止，要想使委托工作，方法必须已经存在（即委托通过其将调用方法的相同签名定义）。但还有另外一种使用委托的方式：通过匿名方法。匿名方法是用作委托的参数的一段代码。

用匿名方法定义委托的语法与前面的定义并没有区别。但在实例化委托时，就会出现区别。下面是一个非常简单的控制台应用程序，它说明了如何使用匿名方法：

```C#
static public void AnonymousMethod() { 
    string mid = ", middle part, "; 
    Func<string, string> anonDel = delegate(string param) { 
        param += mid; 
        param += " and this was added to the string."; 
        return param; 
    }; 
    print(anonDel("Start of string")); 
}
```

在使用匿名方法时，必须遵循两条规则。

**<u>*在匿名方法中不能使用跳转语句（break、goto或continue）跳到该匿名方法的外部，反之亦然：匿名方法外部的跳转语句不能跳到该匿名方法的内部。*</u>** 

**<u>*在匿名方法内部不能访问不安全的代码。另外，也不能访问在匿名方法外部使用的ref和out参数。但可以使用在匿名方法外部定义的其他变量。*</u>**

 如果需要用匿名方法多次编写同一个功能，就不要使用匿名方法。此时与复制代码相比，编写一个命名方法比较好，因为该方法只需要编写一次，以后可通过名称引用它。

**<u>注意： 匿名方法的语法在C# 2中引入。在新的程序中，并不需要这个语法，因为lambda表达式提供了相同的功能，还提供了其他功能。但是，在已有的源代码中，许多地方都使用了匿名方法，所以最好了解它。</u>**



## 8.8 lambda 表达式

eg:

```C#
static void AnonymousMethod1() { 
    string mid = ", middle part, "; 
    Func<string, string> lambda = param => { 
        param += mid; param += " and this was added to the string."; 
        return param; 
    }; 
    print(lambda("lambda")); 
}
```

lambda运算符“ => ”的左边列出了需要的参数，而其右边定义了赋予lambda变量的方法的实现代码。

### 8.8.1 lambda表达式参数

左侧定义了参数：单个参数，多个参数。（没有参数呢？）

eg：

```C#
Func<string, string> oneParam = s => $"change uppercase {s.ToUpper()}";
WriteLine(oneParam("test"));
Func<double, double, double> twoParams = (x, y) => x * y; 
WriteLine(twoParams(3, 2));
Func<double, double, double> twoParamsWithTypes = (double x, double y) => x * y; WriteLine(twoParamsWithTypes(4, 2));
//没有参数
Action line = () => Console.WriteLine();
```

**<u>*有时，编译器无法推断输入参数的类型。 可以显式指定类型！*</u>**

### 8.8.2 多行代码

添加花括号

```C#
Func<string, string> lambda = param => { 
    param += mid; 
    param += " and this was added to the string."; 
    return param; 
};
```

### 8.8.3 闭包

通过lambda表达式可以**<u>*访问lambda表达式块外部的变量，这称为闭包*</u>**。闭包是非常好用的功能，但如果使用不当，也会非常危险。

```C#
int someVal = 5; 
Func<int, int> f = x => x + someVal;
someVal = 7; 
WriteLine(f(3));//=>输出10
```

**<u>*同样，在lambda表达式中修改闭包的值时，可以在lambda表达式外部访问已改动的值。*</u>**

现在我们也许会奇怪，如何在lambda表达式的内部访问lambda表达式外部的变量？

为了理解这一点，看看编译器在定义lambda表达式时做了什么。对于lambda表达式x => x + someVal，编**<u>*译器会创建一个匿名类，它有一个构造函数来传递外部变量。该构造函数取决于从外部访问的变量数。*</u>**对于这个简单的例子，构造函数接受一个int值。匿名类包含一个匿名方法，其实现代码、参数和返回类型由lambda表达式定义：

```C#
public class AnonymousClass { 
    private int someVal; 
    public AnonymousClass(int someVal) { 
        this.someVal = someVal; 
    } 
    public int AnonymousMethod(int x) => x + someVal; 
}
```

　 **<u>*注意： 如果给多个线程使用闭包，就可能遇到并发冲突。最好仅给闭包使用不变的类型。这样可以确保不改变值，也不需要同步。*</u>**

　 **<u>*注意： lambda表达式可以用于类型为委托的任意地方。类型是Expression或Expression<T>时，也可以使用lambda表达式，此时编译器会创建一个表达式树。*</u>**

## 8.9 事件

事件基于委托，为委托提供了一种发布/订阅机制。在.NET架构内到处都能看到事件。在Windows应用程序中，Button类提供了Click事件。这类事件就是委托。**<u>*触发Click事件时调用的处理程序方法需要得到定义，而其参数由委托类型定义。*</u>**

### 8.9.1 事件发布程序及订阅

在本节的示例代码中，事件用于连接CarDealer类和Consumer类。CarDealer类提供了一个新车到达时触发的事件。Consumer类订阅该事件，以获得新车到达的通知。

委托EventHandler< TEventArgs >的定义如下：

```C#
public delegate void EventHandler<TEventArgs>(object sender, TEventArgs e) where TEventArgs: EventArgs
```

CarDealer类提供了EventHandler< CarInfoEventArgs >类型的NewCarInfo事件。

**<u>*作为一个约定，事件一般使用带两个参数的方法；其中第一个参数是一个对象，包含事件的发送者，第二个参数提供了事件的相关信息。第二个参数随不同的事件类型而改变*</u>**。

EventHandler< TEventArgs >定义了一个处理程序，它返回void，接受两个参数。对于EventHandler< TEventArgs >，第一个参数必须是object类型，第二个参数是T类型。EventHandler< TEventArgs >还定义了一个关于T的约束；它必须派生自基类EventArgs。

在一行上定义事件是C#的简化记法。编译器会创建一个EventHandler< CarInfoEventArgs >委托类型的变量，并添加方法，以便从委托中订阅和取消订阅。该简化记法的较长形式如下所示。这非常类似于自动属性和完整属性之间的关系。对于事件，使用add和remove关键字添加和删除委托的处理程序：

```C#
private EventHandler<CarInfoEventArgs> newCarInfo; 
public event EventHandler<CarInfoEventArgs> NewCarInfo { 
    add { newCarInfo += value; } 
    remove { newCarInfo -= value; } 
}
```

```C#
public class Consumer { 
    private string _name; 
    public Consumer(string name) { 
        _name = name; 
    }
    public void NewCarIsHere(object sender, CarInfoEventArgs e) { 
        RunClass.print($"我{_name}知道: 车车 {e.Car} 它来了"); 
    } 
}
```

Consumer类用作事件侦听器。这个类订阅了CarDealer类的事件，并定义了NewCarIsHere方法，该方法满足EventHandler< CarInfoEventArgs >委托的要求，该委托的参数类型是object和CarInfoEventArgs（代码文件EventsSample/Consumer.cs）：

**<u>*按格式写好事件处理器。*</u>**

### 8.9.2 弱事件

通过事件，可直接连接发布程序和侦听器。但是，垃圾回收方面存在问题。**<u>*例如，如果不再直接引用侦听器，发布程序就仍有一个引用。垃圾回收器不能清空侦听器占用的内存，因为发布程序仍保有一个引用，会针对侦听器触发事件。*</u>**



**<u>*这种强连接可以通过弱事件模式来解决，即使用WeakEventManager作为发布程序和侦听器之间的中介。*</u>**

**<u>*WeakEventManager < T >在System.Windows程序集中定义，不属于.NET Core。这个示例用.NET Framework 4.6控制台应用程序完成，不运行在其他平台上。*</u>**

使用弱事件，就不需要改变事件发布器（在示例代码CarDealer类中）。无论使用紧密耦合的事件还是弱事件都没有关系，其实现是一样的。**<u>*不同的是使用者的实现。*</u>**<u>使用者需要实现接口IWeakEventListener。</u>这个接口定义了方法ReceiveWeakEvent，**在事件触发时会在弱事件管理器中调用该方法。**<u>该方法的实现充当代理，调用方法NewCarIsHere</u>。

```C#
public class Consumer1: IWeakEventListener { 
    private string _name; 
    public Consumer(string name) { this._name = name; } 
    public void NewCarIsHere(object sender, CarInfoEventArgs e) { 
        RunClass.print("Consumer1{_name}: car {e.Car} is new"); 
    }
    bool IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e) { 
        NewCarIsHere(sender, e as CarInfoEventArgs); 
        return true; 
    } 
}
```

连接订阅与发布也有区别：

```C#
static void EventDipatch1() { 
    var dealer = new CarDealer(); 
    var daniel = new Consumer("Daniel"); 
    WeakEventManager<CarDealer, CarInfoEventArgs>.AddHandler(dealer, "NewCarInfo", daniel.NewCarIsHere);
    dealer.NewCar("Mercedes"); 
    var sebastian = new Consumer("Sebastian"); 
    WeakEventManager<CarDealer, CarInfoEventArgs>.AddHandler(dealer, "NewCarInfo", sebastian.NewCarIsHere); 
    dealer.NewCar("Ferrari"); 
    WeakEventManager<CarDealer, CarInfoEventArgs>.RemoveHandler(dealer, "NewCarInfo", sebastian.NewCarIsHere); 
    dealer.NewCar("Red Bull Racing");
}
```



**<u>*注意： 动态创建订阅器时，为了避免出现资源泄露，必须特别留意事件。也就是说，需要在订阅器离开作用域（不再需要它）之前，确保取消对事件的订阅，或者使用弱事件。事件常常是应用程序中内存泄露的一个原因，因为订阅器有长时间存在的作用域，所以源代码也不能被垃圾回收。*</u>**

## 9 字符串与正则表达式

在C#中string关键字的映射实际上指向.NET基类System.String。**<u>*System.String是一个功能非常强大且用途广泛的基类，但它不是.NET库中唯一与字符串相关的类。*</u>** 

主要内容

.NET基类System.String的特性。

构建字符串— —如果多次修改一个字符串，例如，创建一个长字符串，然后显示该字符串或将其传递给其他方法或应用程序，String类就会变得效率低下。对于这种情况，应使用另一个类System.Text.StringBuilder，因为它是专门为这种情况设计的。

格式化表达式 — —这些格式化表达式将用于后面几章中的Console.WriteLine（）方法。格式化表达式使用两个有用的接口IFormatProvider和IFormattable来处理。在自己的类上实现这两个接口，实际上就可以定义自己的格式化序列，这样，Console.WriteLine（）和类似的类就可以按指定的方式显示类的值。

正则表达式 — —.NET还提供了一些非常复杂的类来识别字符串，或从长字符串中提取满足某些复杂条件的子字符串。例如，找出字符串中所有重复出现的某个字符或一组字符，或者找出以s开头且至少包含一个n的所有单词，又或者找出遵循雇员ID或社会安全号码结构的字符串。虽然可以使用String类，编写方法来完成这类处理，但这类方法编写起来比较繁琐。而使用System.Text.RegularExpressions名称空间中的类就比较简单，System.Text. RegularExpressions专门用于完成这类处理。

## 9.1 .NET基类System.String

使用运算符重载可以连接字符串。

C#还允许使用类似于索引器的语法来提取指定的字符。

这个类可以完成许多常见的任务，如替换字符、删除空白和把字母变成大写形式等。可用的方法如表所示。

| 方法           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| Compare        | 比较字符串的内容，考虑区域值背景（区域设置），判断某些字符是否相等 |
| CompareOrdinal | 与Compare一样，但不考虑区域值背景                            |
| Concat         | 把多个字符串实例合并为一个实例                               |
| CopyTo         | 把从选定下标开始的特定数量字符复制到数组的一个全新实例中     |
| Format         | 格式化包含各种值的字符串和如何格式化每个值的说明符           |
| IndexOf        | 定位字符串中第一次出现某个给定子字符串或字符的位置           |
| IndexOfAny     | 定位字符串中第一次出现某个字符或一组字符的位置               |
| Insert         | 把一个字符串实例插入到另一个字符串实例的指定索引处           |
| Join           | 合并字符串数组，创建一个新字符串                             |
| LastIndexOf    | 与IndexOf一样，但定位最后一次出现的位置                      |
| LastIndexOfAny | 与IndexOfAny一样，但定位最后一次出现的位置                   |
| PadLeft        | 与IndexOf一样，但定位最后一次出现的位置                      |
| PadRight       | 在字符串的右侧，通过添加指定的重复字符填充字符串             |
| Replace        | 用另一个字符或子字符串替换字符串中给定的字符或子字符串       |
| Split          | 在出现给定字符的地方，把字符串拆分为一个子字符串数组         |
| Substring      | 在字符串中检索给定位置的子字符串                             |
| ToLower        | 把字符串转换为小写形式                                       |
| ToUpper        | 把字符串转换为大写形式                                       |
| Trim           | 删除首尾的空白                                               |

具体可参考：

[String 类 (System) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.string?view=net-6.0)

C#提供了相当多便利的方法，在遇到一些常见的问题时，可以在使用前查查api。

### 9.1.1 构建字符串

**<u>*如上所述，String类是一个功能非常强大的类，它实现许多很有用的方法。但是，String类存在一个问题：重复修改给定的字符串，效率会很低，它实际上是一个不可变的数据类型，这意味着一旦对字符串对象进行了初始化，该字符串对象就不能改变了。*</u>**

**<u>*表面上修改字符串内容的方法和运算符实际上是创建一个新字符串，根据需要，可以把旧字符串的内容复制到新字符串中。*</u>**

一个示例：

```C#
string greetingText = "Hello from all the guys at Wrox Press. "; 
greetingText += "We do hope you enjoy this book as much as we enjoyed writing it.";
```

在执行这段代码时，

1. 首先创建一个System.String类型的对象，并把它初始化为文本“Hello from all the guys at Wrox Press.”，注意句号后面有一个空格。
2. 此时.NET运行库会为该字符串分配足够的内存来保存这个文本（39个字符），再设置变量greetingText来表示这个字符串实例。

3. 从语法上看，下一行代码是把更多的文本添加到字符串中。实际上并非如此，在此是创建一个新字符串实例，给它分配足够的内存，以存储合并的文本（共103个字符）。

4. 把最初的文本“Hello from all the people at Wrox Press.”复制到这个新字符串中，再加上额外的文本“We do hope you enjoy this book as much as we enjoyed writing it.”。
5. 然后更新存储在变量greetingText中的地址，使变量正确地指向新的字符串对象。现在没有引用旧的字符串对象——不再有变量引用它，下一次垃圾收集器清理应用程序中所有未使用的对象时，就会删除它。



考虑以下场景:

```C#
print($"Not encoded:\n {greetingText}"); 
for(int i = 'z'; i>= 'a'; i--) { 
    char old1 = (char)i; 
    char new1 = (char)(i+1); 
    greetingText = greetingText.Replace(old1, new1); //引用替换
} 
for(int i = 'Z'; i>='A'; i--) { 
    char old1 = (char)i; 
    char new1 = (char)(i+1); 
    greetingText = greetingText.Replace(old1, new1);//引用替换 
} 
print($"Encoded:\n {greetingText}");
```

**<u>*在本示例中，Replace（）方法以一种智能的方式工作，在某种程度上，它并没有创建一个新字符串(repalce实际上就返回了一个新对象的引用)，除非其实际上要对旧字符串进行某些改变。原来的字符串包含23个不同的小写字母和3个不同的大写字母。所以Replace（）分配一个新字符串，共计分配26次，每个新字符串都包含103个字符。因此加密过程需要在堆上有一个总共能存储2678个字符的字符串对象，该对象最终将等待被垃圾收集！显然，如果使用字符串频繁进行文字处理，应用程序就会遇到严重的性能问题。*</u>**



为了解决这类问题，Microsoft提供了System.Text.StringBuilder类，StringBuilder类不像String类那样能够支持非常多的方法。在StringBuilder类上可以进行的处理仅限于替换和追加或删除字符串中的文本。但是，它的工作方式非常高效。

**<u>*在使用String类构造一个字符串时，要给它分配足够的内存来保存字符串。然而，StringBuilder类通常分配的内存会比它需要的更多。开发人员可以选择指定StringBuilder要分配多少内存，但如果没有指定，在默认情况下就根据初始化StringBuilder实例时的字符串长度来确定所用内存的大小。*</u>**

StringBuilder类有两个主要的属性：

● Length指定包含字符串的实际长度。 ● Capacity指定字符串在分配的内存中的最大长度。

对字符串的修改就在赋予StringBuilder实例的内存块中进行，这就大大提高了追加子字符串和替换单个字符的效率。删除或插入子字符串仍然效率低下，因为这需要移动随后的字符串部分。**<u>*只有执行扩展字符串容量的操作时，才需要给字符串分配新内存，这样才能移动包含的整个字符串。*</u>**在添加额外的容量时，从经验来看，如果StringBuilder类检测到容量超出，且没有设置新值，就会使自己的容量翻倍。

```C#
var greetingBuilder = new StringBuilder("Hello from all the guys at Wrox Press. ", 150); 
greetingBuilder.AppendFormat("We do hope you enjoy this book as much " + "as we enjoyed writing it");

// var greetingBuilder = new StringBuilder("Hello from all the guys at Wrox Press. ", 150); 
// greetingBuilder.AppendFormat("We do hope you enjoy this book as much " + "as we enjoyed writing it"); 
print("Not Encoded:\n" + greetingBuilder); 
for(int i = 'z'; i>='a'; i--) { 
    char old1 = (char)i; 
    char new1 = (char)(i+1); 
    greetingBuilder.Replace(old1, new1); 
    //greetingBuilder = greetingBuilder.Replace(old1, new1); 
} 
for(int i = 'Z'; i>='A'; i--) { 
    char old1 = (char)i; char new1 = (char)(i+1); 
    greetingBuilder.Replace(old1, new1); 
    //greetingBuilder = greetingBuilder.Replace(old1, new1); 
} 
print("Encoded:\n" + greetingBuilder);
```

StringBuilder，内存空间自己指定，只有在需要时扩展，再去申请内存。

在调用AppendFormat（）方法时，其他文本就放在空的空间中，不需要分配更多的内存。

对于replace 方法，不再复制字符串，而是在自己的内存位置进行修改。

### 9.1.2 StringBuilder成员

详细见：

[StringBuilder 类 (System.Text) | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/api/system.text.stringbuilder?view=net-6.0)

除了前面介绍的Length和Capacity属性外，还有一个只读属性MaxCapacity，它表示对给定的StringBuilder实例的容量限制。在默认情况下，这由int.MaxValue给定（大约20亿，如前所述）。但在构造StringBuilder对象时，也可以把这个值设置为较低的值。

**<u>*不能把StringBuilder强制转换为String（隐式转换和显式转换都不行）。如果要把StringBuilder的内容输出为String，唯一的方式就是使用ToString（）方法。*</u>**

 **<u>*前面介绍了StringBuilder类，说明了使用它提高性能的一些方式。但要注意，这个类并不总能提高性能。StringBuilder类基本上应在处理多个字符串时使用。但如果只是连接两个字符串，使用System.String类会比较好。*</u>**

## 9.2 字符串格式

**<u>*之前的章节介绍了用$前缀给字符串传递变量。本章讨论这个C# 6新功能背后的理论，并囊括格式化字符串提供的所有其他功能。*</u>**

### 9.2.1 字符串插值

*<u>C# 6引入了给字符串使用$前缀的字符串插值。下面的示例使用$前缀创建了字符串s2，**这个前缀允许在花括号中包含占位符来引用代码的结果。**</u>*

```C#
string s1 = "World"; string s2 = $"Hello, {s1}";
```

**<u>*在现实中，这只是语法糖。对于带$前缀的字符串，编译器创建String.Format方法的调用。所以前面的代码段解读为：*</u>**

```C#
string s1 = "World"; string s2 = String.Format("Hello, {0}", s1);
```

String.Format方法的第一个参数接受一个格式字符串，其中的占位符从0开始编号，其后是放入字符串空白处的参数。

1. FormattableString

   把字符串赋予FormattableString，**<u>*就很容易得到翻译过来的插值字符串*</u>**。插值字符串可以直接分配，因为FormattableString比正常的字符串更适合匹配。这个类型定义了Format属性（返回得到的格式字符串）、ArgumentCount属性和方法GetArgument（返回值）：

   ```C#
   int x = 3, y = 4; 
   FormattableString s = $"The result of {x} + {y} is {x + y}"; 
   print($"format: {s.Format }"); 
   for (int i = 0; i < s.ArgumentCount ; i++) { 
       print($"argument {i}: {s.GetArgument(i)} "); 
   }
   ```

   输出：

   ```C#
   format: The result of {0} + {1} is {2}
   argument 0: 3 
   argument 1: 4 
   argument 2: 7 
   ```

   **<u>*注意： 类FormattableString在System名称空间中定义，但是需要.NET 4.6。如果想在.NET旧版本中使用FormattableString，可以自己创建这种类型，或使用NuGet包StringInterpolationBridge。*</u>**

   

2. 给字符串插值使用其他区域值

插值字符串默认使用当前的区域值，这很容易改变。辅助方法Invariant把插值字符串改为使用不变的区域值，而不是当前的区域值。因为插值字符串可以分配给FormattableString类型，所以它们可以传递给这个方法。FormattableString定义了允许传递IFormatProvider的ToString方法。接口IFormatProvider由CultureInfo类实现。把CultureInfo.InvariantCulture传递给IFormatProvider参数，就可把字符串改为使用不变的区域值：

略过，和所处区域的时间表示格式有关。

3. 转义花括号

如果希望在插值字符串中包括花括号，可以使用两个花括号转义它们。

可以转义花括号，从格式字符串中建立一个新的格式字符串。看看这个代码段：

```C#
string s = "Hello"; 
print($"{{s}} displays the value of s: {s}");

string formatString = $"{s}, {{0}}"; 
//相当于
//string formatString = String.Format("{0}, {{0}}", s);
string s2 = "World"; 
System.Console.WriteLine(formatString, s2);
```

 

### 9.2.2 日期时间与数字的格式

除了给占位符使用字符串格式之外，还可以根据数据类型使用特定的格式。

下面先从日期开始**<u>*。在占位符中，格式字符串跟在表达式的后面，用冒号隔开。*</u>**下面所示的例子是用于DateTime类型的D和d格式：

```C#
var day = new DateTime(2025, 2, 14); 
WriteLine($"{day:D}"); 
WriteLine($"{day:d}");
WriteLine($"{day:dd-MMM-yyyy}");
```

时间的格式字符串详见:

[标准日期和时间格式字符串 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/standard-date-and-time-format-strings)



数字的格式字符串：

[标准数字格式字符串 | Microsoft Docs](https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/standard-numeric-format-strings)

### 9.2.3 自定义字符串格式

```C#
public class Person : IFormattable { 
    //方法 IFormattable => ToString(String, IFormatProvider)
    public string FirstName { get; set; } 
    public string LastName { get; set; } 
    public override string ToString() => FirstName + " " + LastName; 
    public virtual string ToString(string format) => ToString(format, null); 
    public string ToString(string format, IFormatProvider formatProvider) { 
        switch (format) { 
            case null: 
            case "A": return ToString(); 
            case "F": return FirstName; 
            case "L": return LastName; 
            default: 
                throw new FormatException($"invalid format string {format}"); 
        } 
    } 
}

public static void TestFormat4(){
    var p1 = new Person { FirstName = "Stephanie", LastName = "Nagel" }; 
    print(p1.ToString("F") );
    print($"{p1:L}");// =>相当于 p1.ToString("L")
}
```

格式字符串不限于内置类型，可以为自己的类型创建自定义格式字符串。为此，只需要实现接口IFormattable。

有了这些代码（指的上述实现ToString(string format, IFormatProvider formatProvider)接口的代码），就可以明确传递格式字符串，或**<u>*隐式使用字符串插值*</u>**，以调用ToString方法。隐式的调用使用带两个参数的ToString方法。



## 9.3 正则表达式

### 9.3.1 正则表达式概述

正则表达式语言是一种专门用于字符串处理的语言。它包含两个功能： 

● 一组用于标识特殊字符类型的转义代码。你可能很熟悉DOS命令中使用\*字符表示任意子字符串（例如，DOS命令Dir Re\*会列出名称以Re开头的所有文件）。正则表达式使用与\*类似的许多序列来表示“任意一个字符”、“一个单词的中断”和“一个可选的字符”等。

 ● 一个系统，在搜索操作中把子字符串和中间结果的各个部分组合起来。

使用正则表达式，可以对字符串执行许多复杂而高级的操作，例如： 

● 识别（可以是标记或删除）字符串中所有重复的单词，例如，把“The computer books books”转换为“The computer books”。 

● 把所有单词都转换为标题格式，例如，把“this is a Title”转换为“This Is A Title”。 

● 把长于3个字符的所有单词都转换为标题格式，例如，把“this is a Title”转换为“This is a Title”。

● 确保句子有正确的大写形式。 

● 区分URI的各个元素（例如，给定http://www.wrox.com， 提取出其中的协议、计算机名和文件名等）。

当然，这些都是可以在C#中用System.String和System.Text.StringBuilder的各种方法执行的任务。但是，在一些情况下，还需要编写相当多的C#代码。

**<u>*如果使用正则表达式，这些代码一般可以压缩为几行。*</u>** 实际上，这是实例化了一个对象System.Text.RegularExpressions.RegEx（甚至更简单，调用静态的RegEx（）方法），给它传递要处理的字符串和一个正则表达式（这是一个字符串，它包含用正则表达式语言编写的指令）。

Watt撰写的图书Beginning Regular Expressions



正则表达式的定义存在多种说法，具体如下。

- 正则表达式就是用某种模式去匹配一类字符串的公式，主要用来描述字符串匹配的工具。
- 正则表达式描述了一种字符串匹配的模式。它可以用来检查字符串中是否含有某种子串、将匹配的子串做替换或者从某个字符串中取出符合某个条件的子串等。
- 正则表达式是由普通字符（如字符a~z）和特殊字符（称为元字符）组成的文字模式。
- 正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。
- 正则表达式就是用于描述某些规则的工具，这些规则通常用于处理字符串中的查找或替换字符串。换句话说，正则表达式就是记录文本规则的代码。
- 正则表达式就是用一个“字符串”来描述一个特征，然后去验证另一个“字符串”是否符合这个特征。

### 9.3.2 正则表达式入门

#### 理解元字符（Metacharacter）

在正则表达式中，元字符（Metacharacter）是一类非常特殊的字符，它能够匹配一个位置或字符集合中的一个字符，如.、\w 等。

根据功能，**<u>*元字符可分为两种类型：匹配位置的元字符和匹配字符的元字符。*</u>**

##### 匹配位置的元字符

匹配位置的元字符包括3 个字符：^、$和\b。其中，^（脱字符号，通常在文章中插入字时使用）和$（美元符号）只匹配一个位置，**<u>*它们分别匹配行的开始和结尾*</u>**。

以下正则表达式**<u>*匹配以“String”开始的行*</u>**，即被匹配的行的第一个字符串为“String”。

```
^String
```

以下正则表达式**<u>*匹配以“String”结尾的行*</u>**，即被匹配的行的最后一个字符串为“String”。

```
String$
```

以下正则表达式***匹配一个空行***，该行中不包含任何字符串。

```
^$
```

 以下正则表达式**<u>*匹配任意行*</u>**。该表达式只匹配行中的开始位置，因为任意行都包括其开始位
置，所以该表达式将匹配任意行。

```
^
```

元字符\b 和^、$具有相似性，它也是匹配一个位置。\b 可以匹配单词的开始或结尾，即单词的分界处。通常情况下，英文单词之间往往由空格符号、标点符号或换行符号来分隔，**<u>*但是元字符\b 不匹配空格符号、标点符号和换行符号中的任何一个，它仅仅匹配一个位置。*</u>**

以下正则表达式匹配**<u>*以“Str”开头*</u>**的字符串，如“String”、“String Format”等。

```
\bStr 
```

正则表达式\bStr 匹配的字符串必须以“Str”开头，并且“Str”之前是单词的分界处。正则表达式\bStr 不能描述或限定“Str”之后的字符串的形式。以下正则表达式匹配以“ing”结尾的字符串，如“String”、“This is a String”等。

```
ing\b
```

正则表达式ing\b 匹配的字符串必须以“ing”结尾，且“ing”之后是单词的分界处。以下正则表达式匹配一个完整的单词“String”。

```
\bString\b
```

*<u>**NOTE:在某些特定环境或语言下，还可以分别采用\\<和\\>来匹配单词的开始位置和结束位置。它们在效果上和元字符\b 等效，即都匹配单词的边界的两个位置，即开始位置和结束位置**</u>*

**<u>*这些都是针对某一行的*</u>**

##### 匹配字符的元字符

匹配字符的元字符包括7 个字符：.（点号）、\w、\W、\s、\S、\d 和\D。其中，

.（点号）匹配除换行符之外的任意字符；

\w 匹配单词字符（包括字母、数字、下画线和汉字）；

\W 匹配任意的非单词字符；

\s 匹配任意的空白字符，如空格、制表符、换行符、中文全角空格等；

\S 匹配任意的非空白字符；

\d 匹配任意的数字；

\D 匹配任意的非数字字符。

eg:

以下正则表达式匹配一个非空行，该行中可以包含除换行符之外的任意字符。(长度为1，表示只能有除换行符之外的任意一个字符)

```
^.$
```

以下正则表达式匹配一个非空行，且该行中只能包含字母、数字、下画线和汉字中的任意一个字符。

```
^\w$
```

以下正则表达式匹配以字母“a”开头的长度等于8 的任意单词。

```
\ba\w\w\w\w\w\w\w\b
```

以下正则表达式匹配以字母“a”开头、后跟随形如“3 个字符”＋“3 个字符”＋“1 个非数字字符”、长度等于8 的任意单词。

```
\ba\w\w\w\d\d\d\D\b
```

匹配字符串“ante123_”



常用元字符

| 字符 | 说明                                                       |
| ---- | ---------------------------------------------------------- |
| ^    | 匹配行的开始位置                                           |
| $    | 匹配行的结束位置                                           |
| \b   | 匹配单词的开始或结束位置. 匹配除换行符之外的任意字符       |
| \w   | 匹配单词字符（包括字母、数字、下画线和汉字）               |
| \W   | 匹配任意的非单词字符（包括字母、数字、下画线和汉字）       |
| \s   | 匹配任意的空白字符，如空格、制表符、换行符、中文全角空格等 |
| \S   | 匹配任意的非空白字符                                       |
| \d   | 匹配任意的数字(0-9）                                       |
| \D   | 匹配任意的非数字字符元(0-9除外的字符)                      |

#### 文字匹配

**<u>*在正则表达式中，元字符通常一次只能匹配一个位置或字符集合中的一个字符。*</u>**

##### 字符类

通常情况下，如果要匹配数字、字母、空白等字符时，可以直接使用与这些集合相对应的元字符。然而，如果要匹配的字符集合（如集合[0,1,2,3,4,5]）没有与之相对应的元字符时，则需要自定义匹配的字符集合。此时，可以使用字符类解决这个问题。字符类是一个字符集合，如果该字符集合中的任何一个字符被匹配，则它就会找到该匹配项。

eg:

以下正则表达式可以匹配任何数字（即0、1、2、3、4、5、6、7、8、9）。

```
[0123456789]
```

以下正则表达式匹配HTML 标记中的“\<H1>”、“\<H2\>”、“\<H3\>”、“\<H4\>”、“\<H5\>”或“\<H6\>”。

```
<H[123456]>
```

以下正则表达式匹配字符串“Jack”或者“jack”。

```
[Jj]ack
```

然而，正则表达式[0123456789]的书写非常不方便。**<u>*因此，正则表达式引入了连接符“-”来定义字符的范围。以下正则表达式等价于正则表达式[0123456789]。*</u>**

以下正则表达式等价于正则表达式[0123456789]。以下正则表达式可以匹配任意小写字母。以下正则表达式可以匹配任意大写字母。

```
[0-9] 
[a-z] 
[A-Z]
```

注意：**<u>*当且仅当在字符类中的连接符“-”不是第一个字符时，它才具有特殊的含义*</u>**：它可以指定字符类的最大边界和最小边界之间的任何字符。它的具体含义由具体的字符类决定。因此，字符类的最大边界和最小边界，以及字符在ASCII 或Unicode 表中出现的顺序共同确定了连接符“-”指定的字符的范围。

在字符类中，若字符“^”是字符类的第一个字符，则表示否定该字符类，即匹配除了该字符类之外的任意字符。

以下正则表达式可以匹配任何非元音字符。

```
[^aAeEiIoOuU]
```



 常用的字符类

| 字符或表达式 | 说明                                                       |
| ------------ | ---------------------------------------------------------- |
| .            | 匹配除换行符之外的任意字符                                 |
| \w           | 匹配单词字符（包括字母、数字、下画线和汉字）               |
| \W           | 匹配任意的非单词字符（包括字母、数字、下画线和汉字）       |
| \s           | 匹配任意的空白字符，如空格、制表符、换行符、中文全角空格等 |
| \S           | 匹配任意的非空白字符                                       |
| \d           | 匹配任意的数字                                             |
| \D           | 匹配任意的非数字字符                                       |
| [aeiou]      | 匹配字符集合中的任何字符                                   |
| [0-9a-zA-Z]  | 匹配任何数字、字母（大写字母和小写字母）和下画线，等同于\w |
| [^0-9a-zA-Z] | 匹配除任何数字、字母、下画线之外的任何字符，等同于\W       |
| \p{name}     | 匹配{name}指定的命名字符类中的任何字符                     |
| \P{name}     | 匹配除{name}指定的命名字符类中之外的任何字符               |

**<u>*注意：表达式\p{name}和\P{name}为.NET Framework 所支持。*</u>**

##### 字符转义

正则表达式定义了一些特殊的元字符，如^、$、.等。**<u>*由于这些字符在正则表达式中被解释成其他的指定的意义，如果需要匹配这些字符，则需要使用字符转义来解决这一问题。转义字符为“\\”（反斜杠），它可以取消这些字符（如^、$、.等）在表达式中具有的特殊意义。*</u>**

以下正则表达式匹配字符串“www.myweburl.com”。

```
www\.myweburl\.com
```

##### 反义

在使用正则表达式时，如果需要匹配不在字符类指定范围内的字符时，可以使用反义规则。

常用的反义表达式

| 字符或表达式 | 说明                                                 |
| ------------ | ---------------------------------------------------- |
| \W           | 匹配任意的非单词字符（包括字母、数字、下画线和汉字） |
| \S           | 匹配任意的非空白字符                                 |
| \D           | 匹配任意的非数字字符                                 |
| \B           | 匹配不是单词开头和结束的任何位置                     |
| [^a]         | 匹配除字符a之外的任意字符                            |
| [^aeiou]     | 匹配除字符集合（aeiou）中的字符之外的任意字符        |

##### 限定符

正则表达式的元字符一次一般只能匹配一个位置或一个字符，如果想要匹配零个、一个或多个字符时，则需要使用限定符。限定符用于指定允许特定字符或字符集自身重复出现的次数。

**<u>*如{n}表示重复n 次、{n,}表示重复至少n 次、{n,m}表示重复至少n 次，最多m 次。*</u>**

常用限定符

| 字符或表达式 | 说明                                     |
| ------------ | ---------------------------------------- |
| {n}          | 重复n次                                  |
| {n,}         | 重复至少n次                              |
| {n,m}        | 重复至少n次，最多m次                     |
| *            | 重复至少0次，等同于{0,}                  |
| +            | 重复至少1次，等同于{1,}                  |
| ?            | 重复0次或1次，等同于{0,1}                |
| ***?**       | **尽可能少地使用重复的第一个匹配**       |
| **+?**       | **尽可能少地使用重复但至少使用一次**     |
| **??**       | **使用零次重复（如有可能）或一次重复**   |
| **{n}?**     | **等同于{n}**                            |
| **{n,}?**    | **尽可能少地使用重复，但至少使用n次**    |
| **{n,m}?**   | **介于n次和m次之间、尽可能少地使用重复** |

如果在限定符\*、+、?、{n}、{n,}和{n,m}之后再添加一个字符“?”，则表示尽可能少地重复字符“?”之前的限定符号的重复次数，这种方式匹配被称为懒惰匹配。与之相对应的是贪婪匹配，即仅仅使用单个限定符\*、+、?、{n}、{n,}和{n,m}的匹配。常用的懒惰限定符如上表加粗所示。

以下正则表达式匹配以字母a 开头、以字母b 结束的最长字符串。此时，这是一种贪婪匹配。

```
a.*b 
```


以下正则表达式匹配以字母a 开头、以字母b 结束的最短字符串。此时，这是一种懒惰匹配。

```
a.*?b
```

如果将正则表达式a.\*b 应用于字符串“aabab”，则匹配字符串“aabab”。如果将正则表达式a.\*?b 应用于字符串“aabab”，则匹配字符串“aab”和字符串“ab”，而不会匹配字符串“aabab”

### 字符运算

正则表达式0\d{2}-\d{8}和0\d{3}-\d{7}分别匹配区号为3 位和4 位的固定电话号码，如果需要同时匹配区号为3 位和4 位的固定电话号码时，使用替换可以满足这一需求。最简单的替换是使用字符“|”表示，它表示如果某一个字符串匹配了正则表达式中的字符“|”的左边或者右边的规则，那么该字符串也匹配了该正则表达式。（或）

eg:

```
0\d{2}-\d{8}|0\d{3}-\d{7}
```


正则表达式的常用替换

| 字符或表达式       | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| \|                 | 匹配\|（竖线）字符的左侧或右侧                               |
| (?(表达式)yes\|no) | 表达式要么与“yes”部分匹配；要么与“no”部分匹配。其中，“no”部分可省略 |
| (?(name)yes\|no)   | 以name命名的字符串要么与“yes”部分匹配，要么与“no”部分匹配。其中，“no”部分可省略 |

注意：字符\|(竖线)在匹配表达式时，首先匹配\|(竖线)字符的左侧部分，当左侧部分不匹配时，它才尝试匹配|字符的右侧部分。

eg:

```
\d{5}-\d{3}|\d{5}
\d{5}|\d{5}-\d{3}
```

根据字符\|的匹配原则（优先匹配左侧表达式），正则表达式\d{5}\|\d{5}-\d{3}只能匹配5 位的数字字符串，而不会匹配用连接符号连接的8 位数字字符串。然而，正则表达式\d{5}-\d{3}\|\d{5}能够匹配用连接符号连接的8 位数字字符串或者5 位的数字字符串。**<u>*因为，该表达式首先尝试匹配用连接符号连接的8 位数字字符串，只有当未匹配时，才匹配5 位的数字字符串。*</u>**

#### 分组

分组又称为子表达式，即把一个正则表达式的全部或部分分成一个或多个组。其中，分组使用的字符为“(”和“)”，即左圆括号和右圆括号。分组之后，可以将在“(”和“)”之间的表达式看成一个整体来处理。以下正则表达式可以匹配重复出现字符串“abc”一次或两次的字符串。此时，表达式将“abc”看成一个整体来进行重复匹配。

此时，表达式将“abc”看成一个整体来进行重复匹配。

```
(abc){1,2}
```

以下正则表达式可以匹配简单的IP 地址。

```
(\d{1,3}\.){3}\d{1,3}
```

#### 反向引用

当一个正则表达式被分组之后，每一个组将自动被赋予一个组号，该组号可以代表该组的表达式。其中，组号的编制规则为：从左到右、以分组的左括号“(”为标志，第一个分组的组号为1，第二个分组的组号为2，依此类推。

反向引用提供了查找重复字符组的简便方法。它们可以被认为是再次匹配同一个字符串的快捷指令。反向引用可以使用数字命名（即默认名称）的组号，也可以使用指定命名的组号。具体说明如表所示。


| 表达式      | 说明                   |
| ----------- | ---------------------- |
| \\数字      | 使用数字命名的反向引用 |
| \\k\<name\> | 使用指定命名的反向引用 |

注意：在表中，表达式\\k\<name\>为.NET Framework 所支持。

以下正则表达式匹配具有两个重复字符的单词。

```
\b(\w)\1\b 
```

以下正则表达式首先匹配单词的开头处，然后匹配一个字符和数字，再重复该字符和数字，最后是单词的结尾处。

```
\b(\w)(\d)\1\2\b
```

表1.9 常用分组说明
| 字符                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| (experssion)          | 匹配字符串experssion，并将匹配的文本保存到自动命名的组里     |
| (?\<name\>experssion) | 匹配字符串experssion，并将匹配的文本以name进行命名。该名称不能包含标点符号，不能以数字开头 |
| (?:experssion)        | 匹配字符串experssion，不保存匹配的文本，也不给此组分配组号   |
| (?=experssion)        | 匹配字符串experssion前面的位置                               |
| (?!experssion)        | 匹配后面不是字符串experssion的位置                           |
| (?<=experssion)       | 匹配字符串experssion后面的位置                               |
| (?<!experssion)       | 匹配前面不是字符串experssion的位置                           |
| (?>experssion)        | 只匹配字符串experssion一次                                   |

### 正则的其他运算

#### 零宽度断言

在前面的小节中，元字符\b、^和$都匹配一个位置，且这个位置满足一定的条件。**<u>*这里，把满足的这一个条件称为断言或零宽度断言。*</u>**（匹配位置）

表1.10 零宽度断言
|字符（断言）| 说明|
|-----------|-----------|
|^ |匹配行的开始位置|
|$ |匹配行的结束位置|
|\A| 匹配必须出现在字符串的开头|
|\Z| 匹配必须出现在字符串的结尾或字符串结尾处的\换行符号n之前|
|\z| 匹配必须出现在字符串的结尾|
|\G |匹配必须出现在上一个匹配结束的地方|
|\b |匹配字符的开始或结束位置|
|\B |匹配不是在字符的开始或结束位置|

在上一小节的表1.9 中，表达式(?=experssion)、(?!experssion)、(?<=experssion)和(?<!experssion)都是匹配一个位置。下面将详细介绍表达式(?=experssion)和(?<=experssion)。

(?=experssion)又称为**<u>*零宽度正预测先行断言*</u>**，**<u>*它断言自身位置的后面能够匹配表达式experssion*</u>**。以下正则表达式匹配以字符串“ed”结尾的单词的前面部分，即匹配单词的除字符串“ed”之外的部分。

```
\b\w+(?=ed\b)
```

#### 负向零宽度断言

零宽度断言只能指定或匹配一个位置。而负向零宽度断言与零宽度断言恰恰相反，它能够指定或匹配不止一个位置，即所说的“反义”。**<u>*特别是在匹配字符串中不包含指定的字符时，负向零宽度断言特别有用。*</u>**以下正则表达式中的表达式a(?!b)将断言字符“a”之后不能为字符“b”。

```
\b\w*a(?!b)\w*\b
```

因此，正则表达式\b\\w\*a(?!b)\w\*\\b 匹配单词字符串，且该字符串中的字符“a”之后不能为字符“b”。

表达式(?!experssion)**<u>*又称为负向零宽度断言或者零宽度负预测先行断言*</u>**，它断言自身位置的后面不能匹配字符串experssion。以下正则表达式首先匹配长度为3 的单词字符串，该字符串之后不能是数字字符串。

```
\b\w{3}(?!\d+)
```

#### 匹配选项

匹配选项可以指定正则表达式匹配中的行为，***如忽略大小写、处理多行、处理单行、从右到左开始执行匹配***等。

注意：本节中下面介绍的匹配选项为.NET Framework 所支持。

.NET Framework 正则表达式中的常用匹配选项说明如表1.11 所示。
表1.11 常用匹配选项
|选项| 内联字符 |说明|
|------|---------|---------------------------|
|None| N/A |指定不设置任何选项|
|IgnoreCase |i |指定不区分大小写|
|Multiline| m| 指定多行模式，即修改^和$的含义，以使它们分别与任何行的开头和结尾匹配|
|ExplicitCapture |n| 指定必须指定分组的名称或组号|
|Compiled |N/A |指定正则表达式将被编译为程序集|
|Singleline |s |指定单行模式|
|IgnorePatternWhitespace |x |指定消除表达式中空白字符，并启用字符(#)后面的注释|
|RightToLeft |N/A |指定匹配是从右向左而不是从左向右进行的|
|ECMAScript |N/A |指定已为表达式启用了符合ECMAScript的行为|
|CultureInvariant |N/A |指定忽略语言中的区域性差异|

#### 注释

正则表达式中除了表达式的基本内容外，还可以包括注释。其中，注释一般通过表达式（?#注释）实现。以下正则表达式在第一个分组中添加了注释“不能以数字开头”。

```
(?<!\d+(?#不能以数字开头))[a-z_A-Z]+
```

注意：如果要在正则表达式中包含注释，则最好打开IgnorePatternWhitespace 选项，即忽略模式里的空白字符。因此，此时可以在注释中添加空格、换行符号、制表符号等。一旦启用了该选项，则符号#之后的内容全部被忽略。

正则表达式(?<!\\d+)[a-z_A-Z]+可以写成以下形式。

```
(?<! 		# 断言是否能匹配该组中的表达式 
\d+ 		# 长度至少为1 的数字字符串
) 			# 表达式结束
[a-z_A-Z]+   # 只能包括大写字母、小写字母或下画线的长度至少为1 的字
```

#### 优先级顺序

正则表达式存在元字符、转义符、限定符、|等运算或表达式。在匹配过程中，正则表达式都事先规定了这些运算或表达式的优先级。正则表达式也可以像数学表达式一样来求值。也就是说，正则表达式可以从左至右、并按照一个给定的优先级来求值。表1.12 是按照优先级从高到低的顺序列出的正则表达式运算符的优先级顺序表。

表1.12 优先级顺序表
|运算符或表达式 |说明|
|------------|-------------|
|\||转义符|
|()、(?:)、(?=)、[]| 圆括号和方括号|
|*、+、?、{n}、{n,}、{n,m} |限定符|
|^、$、\（元字符） |位置和顺序|
|\||“或”运算 |

#### 递归匹配

递归匹配在匹配具有**<u>*嵌套结构的字符串*</u>**时特别有效。**<u>给定算术表达式((1+2)*(3+4))，该表达式具有嵌套结构。如果需要使用正则表达式检查该表达式的结构是否正确，则使用递归匹配能够解决该问题</u>**。

**<u>*注意：本节下面介绍的递归匹配为.NET Framework 所支持。*</u>**
在.NET Framework 中，正则表达式用于递归匹配的表达式说明如表1.13 所示。
表1.13 用于递归匹配的表达式说明
|表达式 |说明|
|--------------|-------------|
|(?\<name\>expression) |把匹配的内容命名为name，并压入堆栈|
|(?<-name>expression) |从堆栈中弹出最后压入的命名为name的匹配内容。如果堆栈为空，则当前组匹配失败|
|(?(name)yes|no) |
|(?!)| 零宽负向先行断言。由于没有后缀表达式，因此匹配总是失败|

以下正则表达式能够匹配算术表达式((1+2)*(3+4))。

```
\([^()]*(((?<bracket>\()[^()]*)+((?<-bracket>\))[^()]*)+)*(?(bracket)(?!))\)
```

下面是对该正则表达式进行的详细分析。

```
\( 						 # 匹配最外层的左括号
	[^()]* 				  # 匹配最外层左括号后面的、不是括号“()”的内容
	(
        (
            (?<bracket>\()  # 如果匹配到左括号，则命名为bracket，并压入堆栈
            [^()]* 		   # 匹配当前左括号后面的、不是括号“()”的内容
        )+				#没有转义的括号不匹配，组的结束，+号是组的限定符
        (
            (?<-bracket>\))  # 如果匹配到右括号，则弹出命名为bracket 的内容
            [^()]* 			# 匹配右括号后面的，不是括号“()”的内容
        )+					#没有转义的括号不匹配，组的结束，+号是组的限定符
	)*
	(?(bracket)(?!)) 		#如果匹配到最外层的右括号前面，则检查堆栈内容是否为空。如果不为空，
							#则匹配失败
\) 							#匹配最外层的右括号
```

### 9.3.3 C#中的正则表达式

首先解释下逐字字符串（在字符串前面跟一个@)

当字符串文本包含反斜杠字符（例如在文件路径中）时，出于便捷性和更强的可读性的考虑，使用逐字字符串。 由于逐字字符串将新的行字符作为字符串文本的一部分保留，因此可将其用于初始化多行字符串。 使用双引号在逐字字符串内部嵌入引号。 下面的示例演示逐字字符串的一些常见用法：



```csharp
string filePath = @"C:\Users\scoleridge\Documents\";
//Output: C:\Users\scoleridge\Documents\

string text = @"My pensive SARA ! thy soft cheek reclined
    Thus on mine arm, most soothing sweet it is
    To sit beside our Cot,...";
/* Output:
My pensive SARA ! thy soft cheek reclined
   Thus on mine arm, most soothing sweet it is
   To sit beside our Cot,...
*/

string quote = @"Her name was ""Sara.""";
//Output: Her name was "Sara."
```



C#中的正则表达式匹配选项

|成员名|      说明|
|----------|------------------|
|CultureInvariant| 指定忽略字符串的区域值(与时间有关) |
|IgnoreCase|     忽略输入字符串的大小写|
|Multiline|修改字符^和$，把它们应用于每一行的开头和结尾，而不仅仅应用于整个字符串的开头和结尾|
|RightToLeft|从右到左地读取输入字符串，而不是默认地从左到右读取（适合于一些亚洲语言或其他以这种方式读取的语言）|
|Singleline|指定句点的含义（.），它原来表示单行模式，现在改为匹配每个字符|



# 10 集合

第6章介绍了数组和Array类实现的接口**<u>*。数组的大小是固定的。如果元素个数是动态的，就应使用集合类。*</u>** 

List\<T\>是与数组相当的集合类。还有其他类型的集合：队列、栈、链表、字典和集。其他集合类提供的访问集合元素的API可能稍有不同，它们在内存中存储元素的内部结构也有区别。**<u>*本章将介绍所有的集合类和它们的区别，包括性能差异。*</u>**

 **<u>*还可以了解在多线程中使用的位数组和并发集合。*</u>**

## 10.1 集合接口和类型

*<u>**大多数集合类都可在System.Collections和System.Collections.Generic名称空间中找到。**</u>*

*<u>**泛型集合类位于System.Collections.Generic名称空间中；**</u>*

*<u>**专用于特定类型的集合类位于System.Collections. Specialized名称空间中。**</u>*

*<u>**线程安全的集合类位于System.Collections.Concurrent名称空间中。**</u>*

*<u>**不可变的集合类在System.Collections.Immutable名称空间中。**</u>*



当然，组合集合类还有其他方式。集合可以根据集合类实现的接口组合为列表、集合和字典。

集合和列表实现的接口，如表所示。

|接口|      说明|
|------------------------|------------------------|
|IEnumerable\<T\>|如果将foreach语句用于集合，就需要IEnumerable接口。这个接口定义了方法GetEnumerator（），它返回一个实现了IEnumerator接口的枚举|
|ICollection\<T>|ICollection\<T>接口由泛型集合类实现。使用这个接口可以获得集合中的元素个数（Count属性），把集合复制到数组中（CopyTo（）方法），还可以从集合中添加和删除元素（Add（）、Remove（）、Clear（））|
|IList\<T>|IList\<T>接口用于可通过位置访问其中的元素列表，这个接口定义了一个索引器，可以在集合的指定位置插入或删除某些项（Insert（）和RemoveAt（）方法）。IList<T>接口派生自ICollection\<T> 接口|
|ISet\<T>|ISet\<T>接口由集实现。集允许合并不同的集，获得两个集的交集，检查两个集是否重叠。ISet\<T>接口派生自ICollection\<T> 接口|
|IDictionary<TKey, TValue>|IDictionary<TKey, TValue>接口由包含键和值的泛型集合类实现。使用这个接口可以访问所有的键和值，使用键类型的索引器可以访问某些项，还可以添加或删除某些项|
|ILookup<TKey, TValue>|ILookup<TKey, TValue>接口类似于IDictionary<TKey, TValue>接口，实现该接口的集合有键和值，且可以通过一个键包含多个值|
|IEqualityComparer\<T>|接口IEqualityComparer\<T>由一个比较器实现，该比较器可用于字典中的键。使用这个接口，可以对对象进行相等性比较.|
|IComparer\<T>|接口IComparer\<T>由比较器实现，通过Compare（）方法给集合中的元素排序|

## 10.2 列表

.NET Framework为动态列表提供了泛型类List\<T>。这个类实现了IList、ICollection、IEnumerable、IList\<T>、ICollection\<T>和IEnumerable\<T> 接口。

### 10.2.1 创建

**<u>*使用默认的构造函数创建一个空列表。元素添加到列表中后，列表的容量就会扩大为可接纳4个元素。如果添加了第5个元素，列表的大小就重新设置为包含8个元素。如果8个元素还不够，列表的大小就重新设置为包含16个元素。每次都会将列表的容量重新设置为原来的2倍。*</u>**

**<u>*如果列表的容量改变了，整个集合就要重新分配到一个新的内存块中。*</u>**

**<u>*在List\<T\>泛型类的实现代码中，使用了一个T类型的数组。通过重新分配内存，创建一个新数组，Array.Copy（）方法将旧数组中的元素复制到新数组中。*</u>**为节省时间，如果事先知道列表中元素的个数，就可以用构造函数定义其容量。下面创建了一个容量为10个元素的集合。如果该容量不足以容纳要添加的元素，就把集合的大小重新设置为包含20或40个元素，每次都是原来的2倍。

#### 1. 集合初始值设定项

还可以使用集合初始值设定项给集合赋值。使用集合初始值设定项，可以在初始化集合时，在花括号中给集合赋值：

```C#
var intList = new List<int>() {1, 2}; var stringList = new List<string>() {"one", "two"};
```

　 注意： 集合初始值设定项没有反映在已编译的程序集的IL代码中。**<u>*编译器会把集合初始值设定项转换成对初始值设定项列表中的每一项调用Add（）方法。*</u>**

#### 2. 添加元素

使用Add（）方法可以给列表添加元素，如下所示。实例化的泛型类型定义了Add（）方法的参数类型：



#### 3. 插入元素

#### 4. 访问元素

#### 5. 删除元素

#### 6. 搜索

#### 7. 排序

