# C#运行环境

## 什么是.net(dotnet)?

全称应该为.net framework。.NET框架是一个多语言组件开发和执行环境，它提供了一个跨语言的统一编程环境。.NET框架又包括三个主要组成部分：公共语言运行库（CLR：Common Language Runtime）、[服务框架](https://baike.baidu.com/item/服务框架)（Services Framework）和上层的两类应用模板——传统的Windows应用程序模板（Win Forms）和基于ASP.NET的面向Web的网络应用程序模板（Web Forms和Web Services）。

.NET FrameWork的核心是其运行库执行环境，称为公共语言运行库(CLR，Common Language Runtime)。

.Net 编程语言的编译器会将代码编译成中间语言（Intermediate Language,IL）代码。IL代码看起来像面向对象的机器码，使用工具ildasm.exe可以打开包含.net代码的dll或exe文件来检查il代码。CLR包含了一个及时（just-in-time,jit)编译器，当程序开始运行时，jit编译器会从il代码生成本地代码。

## .net编程语言的编译过程以及CLR作用？

**在.net中，**
**(1)将源代码编译成mircrosoft中间语言（Intermediate Language,IL）代码。**
**(2)CLR把IL编译为平台专用的本地代码。**
**IL代码在.net程序集中可用。在运行时，jit编译器编译IL代码，创建特定于平台的本地代码。**

**CLR还包括一个带有类型加载器的类型系统，类型加载器负责从程序集中加载类型。CLR的另一个功能是垃圾回收器，垃圾回收器从托管堆中清除不再引用的内存。CLR还负责线程的处理。在C#中创建托管的线程不一定来自底层操作系统。线程的虚拟化和管理由CLR负责。**

# C#语言基础

# 1. 变量

变量声明

```C#
int i;
```

该语句声明int变量i。**实际上编译器不允许在表达式中使用这个变量，除非用一个值初始化了该变量。**
如果在一条语句中声明和初始化了多个变量，那么所有的变量都具有相同的数据类型： 

```C#
int x = 10, y =20; // x and y are both ints 
```

要声明不同类型的变量，需要使用单独的语句。在一条多变量的声明中，不能指定不同的数据类型：

```C#
int x = 10; bool y = true; // Creates a variable that stores true or false int x = 10, bool y = true; // This won't compile!
```

##  1.1 变量的初始化

变量的初始化是C#强调安全性的另一个例子。简单地说，C#编译器需要用某个初始值对变量进行初始化，之后才能在操作中引用该变量。**大多数现代编译器把没有初始化标记为警告**，**但C#编译器把它当成错误来看待**。这就可以防止我们无意中从其他程序遗留下来的内存中检索垃圾值。 C#有两个方法可确保变量在使用前进行了初始化：
 ● 变量是类或结构中的字段，如果没有显式初始化，则创建这些变量时，其默认值就是0（类和结构在后面讨论）。
 ● 方法的局部变量必须在代码中显式初始化，之后才能在语句中使用它们的值。此时，初始化不是在声明该变量时进行的，但编译器会通过方法检查所有可能的路径，如果检测到局部变量在初始化之前就使用了其值，就会标记为错误。

## 1.2 类型推断

**类型推断使用var关键字。声明变量的语法有些变化：使用var关键字替代实际的类型。编译器可以根据变量的初始化值“推断”变量的类型。**

 类型推断需要遵从一些规则：
● 变量必须初始化。否则，编译器就没有推断变量类型的依据。
● 初始化器不能为空。 
● 初始化器必须放在表达式中。 
● 不能把初始化器设置为一个对象，除非在初始化器中创建了一个新对象。

## 1.3 变量的作用域

变量的作用域是可以访问该变量的代码区域。一般情况下，确定作用域遵循以下规则： 
● 只要类在某个作用域内，其字段（也称为成员变量）也在该作用域内。 
● 局部变量存在于表示声明该变量的块语句或方法结束的右花括号之前的作用域内。 
● 在for、while或类似语句中声明的局部变量存在于该循环体内。

有两种冲突情况

1.局部作用域内的冲突
大型程序在不同部分为不同的变量使用相同的变量名很常见。只要变量的作用域是程序的不同部分，就不会有问题，也不会产生多义性。但要注意，同名的局部变量不能在同一作用域内声明两次。声明两次会无法通过编译。
2.局部变量与类字段的冲突
某些情况下，可以区分名称相同（尽管其完全限定名不同）、作用域相同的两个标识符。此时编译器允许声明第二个变量。原因是C#在变量之间有一个基本的区分，它把在类型级别声明的变量看成字段，而把在方法中声明的变量看成局部变量。
**<u>但是，如果要引用类级别变量，该怎么办？可以使用语法object.fieldname，在对象的外部引用类或结构的字段。</u>**

## 1.4 常量

顾名思义，常量是其值在使用过程（生命周期）中不会发生变化的变量。在声明和初始化变量时，在变量的前面加上关键字const，就可以把该变量指定为一个常量。
常量具有如下特点：
● 常量必须在声明时初始化。指定了其值后，就不能再改写了。 
● 常量的值必须能在编译时用于计算。因此，不能用从变量中提取的值来初始化常量。如果需要这么做，应使用只读字段（详见第3章）。 
● **常量总是隐式静态的。但注意，不必（实际上，是不允许）在常量声明中包含修饰符static。** 

在程序中使用常量至少有3个好处： 
● 由于使用易于读取的名称（名称的值易于理解）替代了较难读取的数字和字符串，常量使程序变得更易于阅读。 
● 常量使程序更易于修改。例如，在C#程序中有一个SalesTax常量，该常量的值为6%。如果以后销售税率发生变化，把新值赋给这个常量，就可以修改所有的税款计算结果，而不必查找整个程序去修改税率为0.06的每个项。
● 常量更容易避免程序出现错误。如果在声明常量的位置以外的某个地方将另一个值赋给常量，编译器就会标记错误。

## 1.5 预定义数据类型(变量的类型)

两中大的分类：

1.值类型
2.引用类型

从概念上看，其区别是值类型直接存储其值，而引用类型存储对值的引用。
这两种类型存储在内存的不同地方：值类型存储在堆栈（stack）中，而引用类型存储在托管堆（managed heap）上。注意区分某个类型是值类型还是引用类型，因为这会有不同的影响。例如，int是值类型，这表示下面的语句会在内存的两个地方存储值20：

C#把基本类型（如int和bool）规定为值类型，而把包含许多字段的较大类型（通常在有类的情况下）规定为引用类型，C#设计这种方式是为了得到最佳性能。如果要把自己的类型定义为值类型，**就应把它声明为一个结构。**

**大多数更复杂的C#数据类型，包括我们自己声明的类，都是引用类型。它们分配在堆中，其生存期可以跨多个函数调用，可以通过一个或几个别名来访问。CLR实现一种精细的算法，来跟踪哪些引用变量仍是可以访问的，哪些引用变量已经不能访问了。CLR会定期删除不能访问的对象，把它们占用的内存返回给操作系统。这是通过垃圾回收器实现的。**

### 1.5.1 .net类型

数据类型的C#关键字（如int、short和string）从编译器映射到.NET数据类型。例如，在C#中声明一个int类型的数据时，声明的实际上是.NET结构System.Int32的一个实例。这听起来似乎很深奥，但其意义深远：这表示在语法上，可以把所有的基本数据类型看成支持某些方法的类。例如，要把int i转换为string类型，可以编写下面的代码： string s = i.ToString(); **<u>应强调的是，在这种便利语法的背后，类型实际上仍存储为基本类型。</u>**基本类型在概念上用.NET结构表示，所以肯定没有性能损失。 

下面看看C#中定义的内置类型。我们将列出每个类型，以及它们的定义和对应.NET类型的名称。C#有15个预定义类型，其中13个是值类型，两个是引用类型（string和object）。

### 1.5.2 C#类型

具体的定义略，可以参考，**[美] Christian Nagel. C#高级编程(第10版) C# 6 & .NET Core 1.0 (2.4.3). 清华大学出版社.**

**有些C#类型的名称与C++和Java类型一致，但定义不同。例如，在C#中，int总是32位有符号的整数。而在C++中，int是有符号的整数，但其位数取决于平台（在Windows上是32位）。在C#中，所有的数据类型都以与平台无关的方式定义，以备将来从C#和.NET迁移到其他平台上。**

**如果对一个int、uint、long还是ulong类型的整数没有任何显式的声明，则该变量默认为int类型。为了把输入的值指定为其他整数类型，可以在数字后面加上如下字符：**

```C#
uint ui = 1234U; long l = 1234L; ulong ul = 1234UL;
```

**bool值和整数值不能相互隐式转换。如果变量（或函数的返回类型）声明为bool类型，就只能使用值true或false。如果试图使用0表示false，非0值表示true，就会出错。**

**char类型的字面量是用单引号括起来的，如’A'。如果把字符放在双引号中，编译器会把它看成字符串，从而产生错误。**

**<u>*C#有string关键字，转换为.NET类System.String。有了它，像字符串连接和字符串复制这样的操作就很简单了。尽管它为引用类型，string类已实现，其语义遵循一般的、直观的字符串规则。*</u>**

**名称空间的别名**,如下

```C#
using alias = NamespaceName;
```



## 1.6  XML文档

如前所述，除了C风格的注释外，C#还有一个非常出色的功能（本章将讨论这一功能）：根据特定的注释自动创建XML格式的文档说明。这些注释都是单行注释，但都以3条斜杠（///）开头，而不是通常的两条斜杠。在这些注释中，可以把包含类型和类型成员的文档说明的XML标记放在代码中。

编译器可以识别一些格式的注释文档。

## 1.7  C#预处理器指令

**注意： C++开发人员应该知道，在C和C++中预处理器指令非常重要。但是，在C#中，并没有那么多的预处理器指令，它们的使用也不太频繁。C#提供了其他机制来实现许多C++指令的功能，如定制特性。还要注意，C#并没有一个像C++那样的独立预处理器，所谓的预处理器指令实际上是由编译器处理的。尽管如此，C#仍保留了一些预处理器指令名称，因为这些命令会让人觉得就是预处理器。**

# 2. 对象与类型

结构不同于类，因为它们不需要在堆上分配空间（类是引用类型，总是存储在堆（heap）上），而结构是值类型，通常存储在栈（stack）上，另外，结构不支持继承。对于类和结构，都使用关键字new来声明实例：这个关键字创建对象并对其进行初始化。

**类和结构的一个重要区别是，类类型的对象通过引用传递，结构类型的对象按值传递。**

类中的成员说明：

| 成员     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 字段     | 字段是类的数据成员，它是类型的一个变量，该类型是类的一个成员 |
| 方法     | 方法是与特定类相关联的函数                                   |
| 常量     | 常量与类相关（尽管它们没有static修饰符）。编译器使用真实值代替常量 |
| 属性     | 属性是可以从客户端访问的函数组，其访问方式与访问类的公共字段类似。C#为读写类中的属性提供了专用语法，所以不必使用那些名称中嵌有Get或Set的方法。因为属性的这种语法不同于一般函数的语法，所有在客户端代码中，虚拟的对象被当作实际的东西 |
| 构造函数 | 构造函数是在实例化对象时自动调用的特殊函数。它们必须与所属的类同名，且不能有返回类型。构造函数用于初始化字段的值 |
| 索引器   | 索引器允许对象用访问数组的方式访问。索引器参见第8章          |
| 运算符   | 运算符执行的最简单的操作就是加法和减法。在两个整数相加时，严格地说，就是对整数使用“+”运算符。C#还允许指定把已有的运算符应用于自己的类（运算符重载）。第8章将详细论述运算符 |
| 事件     | 事件是类的成员，在发生某些行为（如修改类的字段或属性，或者进行了某种形式的用户交互操作）时，它可以让对象通知调用方。客户可以包含所谓“事件处理程序”的代码来响应该事件。第9章将详细介绍事件 |
| 析构函数 | 析构函数或终结器的语法类似于构造函数的语法，但是在CLR检测到不再需要某个对象时调用它。它们的名称与类相同，但前面有一个“～”符号。不可能预测什么时候调用终结器。终结器详见第5章 |
| 类型     | 类可以包含内部类。如果内部类型只和外部类型结合使用，就很有趣 |

​                                               

属性（property）的概念是：它是一个方法或一对方法，在客户端代码看来，它（们）是一个字段。

